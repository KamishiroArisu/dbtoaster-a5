

The estimation of probabilities of continuous distributions frequently devolves into the computation of complex integrals.  PIP's architecture allows it to identify cases where efficient algorithms exist to obtain a solution.  For more complex problems not covered by these cases, PIP relies on Monte Carlo integration \cite{montecarlo}, a conceptually simple technique that allows for the (approximate) numerical integration of even the most general  functions. Conceptually, to compute the expectation of function $q(\vec x)$, one simply approximates the integral by taking $n$ samples $\vec{x}_1, \dots, \vec{x}_n$ for $\vec{X}$ from their distribution $p(\vec X)$  and  taking  the  average of the function evaluated on all $n$ values.
%
%\begin{equation}\label{eq:mc_expectation}
%\frac{1}{n} \cdot \sum_{i=1}^n q(\vec{x}_i).
%\end{equation}

In general, even taking a sample from a complicated PDF is difficult.  Constraints imposed by queries break traditional Monte Carlo assumptions of normalization on $p(\vec X)$ and require that the sampling technique account for them or lose precision.  A variety of techniques exist to address this problem, from straightforward rejection sampling, where constraint-violating samples are repeatedly discarded, to more heavy duty Markov-chain Monte Carlo (MCMC, cf.\ e.g., \cite{GRS1995}) style techniques such as the Metropolis-Hastings algorithm \cite{metropolis,GRS1995}. 

Recently,  a paper on the MCDB system\cite{MCDB} has promoted an integrated sampling-based  approach to  probabilistic databases.  Conceptually,  MCDB uses a {\em sample-first}\/ approach: it   first  computes  samples  of  entire databases and then processes queries  on these samples.  This is a very general and flexible approach, largely due to its modular approach to probability distributions via black box sample generators called VG~Functions.  Using Tuple-Bundles, a highly compressed representation of the sampled database instances, MCDB evaluates queries on these instances in parallel, sharing computation across instances where possible.  

{\em  Conditional tables}\/  (c-tables, \cite{IL1984})  are relational tables in which tuples have associated conditions expressed as boolean expressions over  comparisons of random variables  and constants. C-tables are a natural way to  represent  the  {\em  deterministic skeleton}\/  of a probabilistic relational  database in  a succinct  and tabular  form.  That  is, complete information  about uncertain data is encoded using random  variables, excluding only  specifications  of the  joint  probability  distribution of  the random  variables   themselves.   This  model   allows  representation of  input databases  with  nontrivial statistical  dependencies that are normally associated with graphical models. 

For {\em discrete} probabilistic  databases, a canon of systems has been developed that essentially use c-tables, without referring to them as such. MystiQ  \cite{dalvi07efficient}  uses  c-tables internally  for  query processing  but  uses  a  simpler  model for  input  databases.   Trio \cite{WidomTrio2008}  uses  c-tables with  additional  syntactic sugar  and calls conditions {\em lineage}\/.  MayBMS \cite{AJKO2008}  uses a  form of  c-tables called  U-relations that define how relational algebra representations of queries can encode the corresponding condition transformations.

ORION \cite{ORION} is a probabilistic database management system for
continuous distributions that can alternate between sampling
and transforming distributions. However, their representation
system is not based on c-tables but essentially on the
world-set decompositions of \cite{AKO07WSD}, a factorization
based approach related to graphical models.
Selection queries in this model may require an exponential blow-up in the
representation size, while selections are efficient in c-tables.


\def\bagopen{\{\!|\,}
\def\bagclose{\,|\!\}}


\subsection{C-tables}
A c-table  over
a set  of variables is  a relational table\footnote{
In the following, we use a multiset semantics for tables: Tables may
contain duplicate tuples. Sets transformations are defined in comprehension notation $\bagopen \cdot \mid \cdot \bagclose$ with $\in$ as an iterator.  Transformations preserve duplicates.  We use $\uplus$ to denote bag union, which can be thought of as list concatenation if the multisets are represented as unsorted lists.
}
extended by a  column for holding a \textit{local  condition} for each
tuple.   A local condition  is a  Boolean combination  (using ``and'',
``or'', and ``not'') of  atomic conditions, which are constructed from
variables  and constants  using  $=$, $<$,  $\leq$,  $\neq$, $>$,  and
$\geq$.   The fields  of the  remaining data  columns may  hold domain
values or variables.

Given  a variable  assignment $\theta$  that maps  each variable  to a
domain  value  and  a  condition $\phi$,  $\theta(\phi)$  denotes  the
condition  obtained  from  $\phi$   by  replacing  each  variable  $X$
occurring  in  it   by  $\theta(X)$.   Analogously,  $\theta(\vec{t})$
denotes  the tuple  obtained  from tuple  $\vec{t}$  by replacing  all
variables using $\theta$.

The semantics  of c-tables are defined  in terms of  possible worlds as
follows.  A  possible world is  identified with a  variable assignment
$\theta$.  A relation $R$ in  that possible world is obtained from its
c-table $C_R$ as
$$R  :=  \bagopen  \theta(\vec{t})   \mid  (\vec{t},  \phi)  \in  C_R,
   \theta(\phi) \mbox{  is true} \bagclose.$$ That is,  for each tuple
   $(\vec{t},  \phi)$  of  the  c-table,  where $\phi$  is  the  local
   condition   and  $\vec{t}$   is   the  remainder   of  the   tuple,
   $\theta(\vec{t})$ exists in the world if and only if $\theta(\phi)$
   is true.  Note  that each c-table has at  least one possible world,
   but worlds  constructed from  distinct variable assignments  do not
   necessarily represent different database instances.



\subsection{Relational algebra on c-tables}


Evaluating relational algebra on c-tables (and without the slightest difference, on probabilistic c-tables, since probabilities need not be touched at all) is surprisingly straightforward. The evaluation of the operators of relational
algebra on multiset c-tables is summarized in Figure \ref{fig:ctables-relalg}.
An explicit operator ``distinct'' is used to perform duplicate elimination.  


\begin{figure}[t!]
\begin{center}
\begin{eqnarray*}
C_{\sigma_\psi(R)} &=&
   \bagopen (\vec{r}, \phi \land \psi[\vec{r}]) \mid (\vec{r}, \phi) \in C_R
   \bagclose
\\
&\dots& \mbox{$\psi[\vec{r}]$ denotes $\psi$ with each reference to}
\\
&& \mbox{a column $A$ of $R$ replaced by $\vec{r}.A$.}
\\[1ex]
C_{\pi_{\vec{A}}(R)} &=&
   \bagopen (\vec{r}.\vec{A}, \phi) \mid (\vec{r}, \phi) \in C_R \bagclose
\\
C_{R \times S} &=& \bagopen (\vec{r}, \vec{s}, \phi \land \psi) \mid
   (\vec{r}, \phi) \in C_R, (\vec{s}, \psi) \in C_S \bagclose
\\
C_{R \cup S} &=& C_R \uplus C_S
\\
C_{\mathrm{distinct}(R)} &=&
\bagopen (\vec{r},
    \bigvee \{ \phi \mid (\vec{r}, \phi) \in C_R \} )
    \mid (\vec{r}, \cdot) \in C_R \bagclose
\\
C_{R - S} &=& \bagopen (\vec{r}, \phi \land \psi) \mid
   (\vec{r}, \phi) \in C_{\mathrm{distinct}(R)}, \\
&& \quad\quad
   \mbox{if } (\vec{r}, \pi) \in C_{\mathrm{distinct}(S)} \mbox{ then } \psi := \neg \pi \\
&& \quad\quad
   \mbox{else } \psi := \mbox{true} \bagclose
\end{eqnarray*}

\vspace{-3mm}

\caption{Relational algebra on c-tables.}
\label{fig:ctables-relalg}
\end{center}
\vspace*{-0.25in}
\end{figure}


\begin{example}\em
We continue the example from the introduction. The input c-tables are
\[
C_{\mathrm{Order}} = \bagopen ((Joe, NY, X_1), \mbox{true}),
((Bob, LA, X_3), \mbox{true}) \bagclose
\]
\[
C_{\mathrm{Shipping}} = \bagopen ((NY, X_2), \mbox{true}),
   ((LA, X_4), \mbox{true}) \bagclose.
\]
The relational algebra query is
\begin{multline*}
\pi_{\mathrm{Price}}(\sigma_{\mathrm{ShipTo} = \mathrm{Dest}}( \\
\sigma_{\mathrm{Cust}='Joe'}(\mathrm{Order}) \times
\sigma_{\mathrm{Duration} \ge 7}(\mathrm{Shipping}))).
\end{multline*}
%
We compute
\begin{multline*}
C_{\sigma_{\mathrm{Cust}='Joe'}(\mathrm{Order})} = \bagopen ((Joe, NY, X_1), \mbox{true})
\bagclose
\end{multline*}
\vspace*{-0.35in}
\begin{multline*}
C_{\sigma_{\mathrm{Duration} \ge 7}(\mathrm{Shipping})} =\\
\bagopen ((NY, X_2), X_2 \ge 7), ((LA, X_4),X_4 \ge 7) \bagclose
\end{multline*}
\vspace*{-0.35in}
\begin{multline*}
C_{\sigma_{\mathrm{Cust}='Joe'}(\mathrm{Order}) \times
\sigma_{\mathrm{Duration} \ge 7}(\mathrm{Shipping})} = \\
\bagopen ((Joe, NY, X_1, NY, X_2), X_2 \ge 7),\\
((Joe, NY, X_1, LA, X_4), 
X_4 \ge 7) \bagclose
\end{multline*}
\end{example}


\subsection{Probabilistic c-tables; expectations}
\label{sec:montecarlo}


A \textit{probabilistic  c-table} (cf.\ \cite{GT2006, KochMayBMS2008}) is a c-table in  which each variable is
simply considered a (discrete  or continuous) {\em random variable}\/,
and a joint probability distribution is given for the random variable.
As  a convention,  we will  denote  the discrete  random variables  by
$\vec{X}$ and the continuous ones by $\vec{Y}$.  Throughout the paper,
we  will  always  assume  without  saying that  {\em  discrete  random
variables have a finite domain}\/.

We    will   assume    a    suitable   function    $p(\vec{X}=\vec{x},
\vec{Y}=\vec{y})$ specifying a joint distribution which is essentially
a  PDF  on the  continuous  and a  probability  mass  function on  the
discrete variables.  To clarify  this, $p$ is such that
we can define the expectation of a function $q$ as
\[
E[q] =
\sum_{\vec{x}} \int_{y_1} \cdots \int_{y_n}
p(\vec{x}, \vec{y}) \cdot q(\vec{x}, \vec{y}) \; d \vec{y} \approx 
\frac{1}{n} \cdot \sum_{i=1}^n q(\vec{x}_i, \vec{y}_i)
\]
given samples $(\vec{x}_1, \vec{y}_1), \dots, (\vec{x}_n, \vec{y}_n)$ from
the distribution $p$.

%ck: That's BS, moments are covered by expectations.
%Throughout this paper, we will consider expectations and their special
%cases (such as event probabilities), but we will not discuss higher moments.
%Note though that the extension of our framework is conceptually simple.


We can specify events (sets of possible worlds) via Boolean conditions
$\phi$  that  are true  on  a  possible  world (given  by  assignment)
$\theta$  iff the condition  obtained by  replacing each  variable $x$
occurring  in  $\phi$  by  $\theta(x)$ is  true.   The  characteristic
function  $\chi_\phi$  of condition  (event)  $\phi$  returns  1 on  a
variable  assignment  if  it   makes  $\phi$  true  and  returns  zero
otherwise.   The probability  $\Pr[\phi]$  of event  $\phi$ is  simply
$E[\chi_\phi]$.

The expected  sum of a function $h$  applied to the tuples  of a table
$R$,
{\small\begin{verbatim}
  select expected_sum(h(*)) from R;
\end{verbatim}}
can be computed as
\[
E \Big[ \sum_{\vec{t}  \in R}  h(\vec{t}) \Big]  =
E \Big[ \sum_{(t, \phi) \in C_R} \chi_\phi \cdot h(t) \Big] =
\sum_{(t, \phi) \in C_R} E \Big[ \chi_\phi \cdot (h \circ t) \Big]
\]
(the latter by linearity of expectation).
%, or equivalently
%\[
%   \sum_{(t,  \phi) \in  C_R} \sum_{\vec{x}}  \cdot  \int_{y_1} \cdots
%   \int_{y_n}  p(\vec{x}, \vec{y})  \cdot  \chi_\phi(\vec{x}, \vec{y})
%   \cdot h(t[\vec{x}, \vec{y}]) \; d \vec{y}.
%\]
Here $t(\vec{x}, \vec{y})$ denotes
the tuple $t$, where any variable that may occur is replaced by
the value assigned to it in $(\vec{x}, \vec{y})$.


\begin{example}\em
Returning to our running example, for $C_R = \bagopen (x_1, x_2 \ge 7) \bagclose$, the expected sum of prices is
\begin{multline*}
   \sum_{(t,  \phi) \in  C_R}
   \int_{x_1} \cdots
   \int_{x_4}  p(\vec{x})  \cdot  \chi_\phi(\vec{x})
   \cdot t(\vec{x}).\mathrm{Price} \; d \vec{y}
= \\
   \int_{x_1} \cdots
   \int_{x_4}  p(\vec{x})  \cdot  \chi_{X_2 \ge 7}(\vec{x})
   \cdot x_1 \; d \vec{y}.
\end{multline*}
\end{example}\ \\


{\bf Counting and group-by}\/.
Expected count aggregates are obviously special cases of expected sum
aggregates where $h$ is a constant function $1$.
We generally consider expected sum aggregates with grouping by (continuously)
uncertain columns to be of doubtful value.
Group-by on nonprobabilistic columns (i.e., which contain no random variables)
poses no difficulty in the c-tables framework: the above summation simply
proceeds within groups of tuples from $C_R$ that agree on the group columns.
In particular, by delaying any sampling process until after the relational
algebra part of the query has been evaluated on the c-table representation,
we find it easy to create as many samples as we need for each group in a 
goal-directed fashion. This is a considerable strong point of the c-tables
approach used in PIP.


