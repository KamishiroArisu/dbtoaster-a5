

The estimation of probabilities of continuous distributions frequently devolves into the computation of complex integrals.  PIP's architecture allows it to identify cases where efficient algorithms exist to obtain a solution.  For more complex problems not covered by these cases, PIP relies on Monte Carlo integration \cite{montecarlo}, a conceptually simple technique that allows for the (approximate) numerical integration of even the most general  functions. Conceptually, to compute the expectation of function $q(\vec x)$, one simply approximates the integral by taking $n$ samples $\vec{x}_1, \dots, \vec{x}_n$ for $\vec{X}$ from their distribution $p(\vec X)$  and  taking  the  average of the function evaluated on all $n$ values,
%
\begin{equation}\label{eq:mc_expectation}
\frac{1}{n} \cdot \sum_{i=1}^n q(\vec{x}_i).
\end{equation}

In general, even taking a sample from a complicated PDF is difficult.  Constraints imposed by queries break traditional Monte Carlo assumptions of normalization on $p(\vec X)$ and require that the sampling technique account for them or lose precision.  A variety of techniques exist to address this problem, from straightforward rejection sampling, where constraint-violating samples are repeatedly discarded, to more heavy duty Markov-chain Monte Carlo (MCMC, cf.\ e.g., \cite{GRS1995}) style techniques such as the Metropolis-Hastings algorithm \cite{metropolis,GRS1995}. 

Recently,  the paper  \cite{MCDB} on  the MCDB  system  has promoted an integrated  sampling-based  approach to  probabilistic databases.  Conceptually,  MCDB uses a {\em sample-first}\/ approach: it   first  computes  samples  of  entire databases and then processes queries  on these samples.  This is a very general and flexible approach, largely due to its modular approach to probability distributions via black box sample generators called VG Functions.  Using Tuple-Bundles, a highly compressed representation of the sampled database instances, MCDB evaluates queries on these instances in parallel, sharing computation across instances where possible.  

{\em  Conditional tables}\/  (c-tables, \cite{IL1984})  are relational tables in which tuples have associated conditions expressed as boolean expressions over  comparisons of random variables  and constants. C-tables are a natural way to  represent  the  {\em  deterministic skeleton}\/  of a probabilistic relational  database in  a succinct  and tabular  form.  That  is, complete information  about uncertain data is encoded using random  variables, excluding only  specifications  of the  joint  probability  distribution of  the random  variables   themselves.   This  model   allows  representation of  input databases  with  nontrivial statistical  dependencies that are normally associated with graphical models. 

For {\em discrete} probabilistic  databases, a canon of systems has been developed that essentially use c-tables, without referring to them as such. MystiQ  \cite{dalvi07efficient}  uses  c-tables internally  for  query processing  but  uses  a  simpler  model for  input  databases.   Trio \cite{WidomTrio2008}  uses  c-tables with  additional  syntactic sugar  and calls conditions {\em lineage}\/.  MayBMS \cite{AJKO2008}  uses a  form of  c-tables called  U-relations that define how relational algebra representations of queries can encode the corresponding condition transformations.

ORION \cite{ORION} is a probabilistic database management system for
continuous distributions that can alternate between sampling
and transforming distributions. However, their representation
system is not based on c-tables but essentially on the
world-set decompositions of \cite{AKO07WSD}, a factorization
based approach related to graphical models.
Selection queries in this model may require an exponential blow-up in the
representation size, while selections are efficient in c-tables.


\def\bagopen{\{\!|\,}
\def\bagclose{\,|\!\}}


\subsection{C-tables}
A c-table  over
a set  of variables is  a relational table \footnote{
In the following, we use a multiset semantics for tables: Tables may
contain duplicate tuples. Using $\in$ as an iterator over multisets in
comprehension notation $\bagopen \cdot \mid \cdot \bagclose$ preserves
duplicates. We use $\uplus$ to denote bag union, which can be thought of
as list concatenation if the multisets are represented as unsorted lists.
}
extended by a  column for holding a \textit{local  condition} for each
tuple.   A local condition  is a  Boolean combination  (using ``and'',
``or'', and ``not'') of  atomic conditions, which are constructed from
variables  and constants  using  $=$, $<$,  $\leq$,  $\neq$, $>$,  and
$\geq$.   The fields  of the  remaining data  columns may  hold domain
values or variables.

Given  a variable  assignment $\theta$  that maps  each variable  to a
domain  value  and  a  condition $\phi$,  $\theta(\phi)$  denotes  the
condition  obtained  from  $\phi$   by  replacing  each  variable  $X$
occurring  in  it   by  $\theta(X)$.   Analogously,  $\theta(\vec{t})$
denotes  the tuple  obtained  from tuple  $\vec{t}$  by replacing  all
variables using $\theta$.

The semantics  of c-tables are defined  in terms of  possible worlds as
follows.  A  possible world is  identified with a  variable assignment
$\theta$.  A relation $R$ in  that possible world is obtained from its
c-table $C_R$ as
$$R  :=  \bagopen  \theta(\vec{t})   \mid  (\vec{t},  \phi)  \in  C_R,
   \theta(\phi) \mbox{  is true} \bagclose.$$ That is,  for each tuple
   $(\vec{t},  \phi)$  of  the  c-table,  where $\phi$  is  the  local
   condition   and  $\vec{t}$   is   the  remainder   of  the   tuple,
   $\theta(\vec{t})$ exists in the world if and only if $\theta(\phi)$
   is true.  Note  that each c-table has at  least one possible world,
   but worlds  constructed from  distinct variable assignments  do not
   necessarily represent different database instances.



\subsection{Relational algebra on c-tables}


Evaluating relational algebra on c-tables (and without the slightest difference, on probabilistic c-tables, since probabilities need not be touched at all) is surprisingly straightforward. The evaluation of the operators of relational
algebra on multiset c-tables is summarized in Figure \ref{fig:ctables-relalg}.
An explicit operator ``distinct'' is used to perform duplicate elimination.  


\begin{figure}[t!]
\begin{center}
\begin{eqnarray*}
C_{\sigma_\psi(R)} &=&
   \bagopen (\vec{r}, \phi \land \psi[\vec{r}]) \mid (\vec{r}, \phi) \in C_R
   \bagclose
\\
&\dots& \mbox{$\psi[\vec{r}]$ denotes $\psi$ with each reference to}
\\
&& \mbox{a column $A$ of $R$ replaced by $\vec{r}.A$.}
\\[1ex]
C_{\pi_{\vec{A}}(R)} &=&
   \bagopen (\vec{r}.\vec{A}, \phi) \mid (\vec{r}, \phi) \in C_R \bagclose
\\
C_{R \times S} &=& \bagopen (\vec{r}, \vec{s}, \phi \land \psi) \mid
   (\vec{r}, \phi) \in C_R, (\vec{s}, \psi) \in C_S \bagclose
\\
C_{R \cup S} &=& C_R \uplus C_S
\\
C_{\mathrm{distinct}(R)} &=&
\bagopen (\vec{r},
    \bigvee \{ \phi \mid (\vec{r}, \phi) \in C_R \} )
    \mid (\vec{r}, \cdot) \in C_R \bagclose
\\
C_{R - S} &=& \bagopen (\vec{r}, \phi \land \psi) \mid
   (\vec{r}, \phi) \in C_{\mathrm{distinct}(R)}, \\
&& \quad\quad
   \mbox{if } (\vec{r}, \pi) \in C_{\mathrm{distinct}(S)} \mbox{ then } \psi := \neg \pi \\
&& \quad\quad
   \mbox{else } \psi := \mbox{true} \bagclose
\end{eqnarray*}

\vspace{-3mm}

\caption{Relational algebra on c-tables.}
\label{fig:ctables-relalg}
\end{center}
\vspace*{-0.25in}
\end{figure}


\begin{example}\em
We continue the example from the introduction. The input c-tables are
\[
C_{\mathrm{Order}} = \bagopen ((Joe, NY, X_1), \mbox{true}),
((Bob, LA, X_3), \mbox{true}) \bagclose
\]
\[
C_{\mathrm{Shipping}} = \bagopen ((NY, X_2), \mbox{true}),
   ((LA, X_4), \mbox{true}) \bagclose.
\]
The relational algebra query is
\begin{multline*}
\pi_{\mathrm{Price}}(\sigma_{\mathrm{ShipTo} = \mathrm{Dest}}( \\
\sigma_{\mathrm{Cust}='Joe'}(\mathrm{Order}) \times
\sigma_{\mathrm{Duration} \ge 7}(\mathrm{Shipping}))).
\end{multline*}
%
We compute
\begin{multline*}
C_{\sigma_{\mathrm{Cust}='Joe'}(\mathrm{Order})} = \bagopen ((Joe, NY, X_1), \mbox{true})
\bagclose
\end{multline*}
\vspace*{-0.35in}
\begin{multline*}
C_{\sigma_{\mathrm{Duration} \ge 7}(\mathrm{Shipping})} =\\
\bagopen ((NY, X_2), X_2 \ge 7), ((LA, X_4),X_4 \ge 7) \bagclose
\end{multline*}
\vspace*{-0.35in}
\begin{multline*}
C_{\sigma_{\mathrm{Cust}='Joe'}(\mathrm{Order}) \times
\sigma_{\mathrm{Duration} \ge 7}(\mathrm{Shipping})} = \\
\bagopen ((Joe, NY, X_1, NY, X_2), X_2 \ge 7),\\
((Joe, NY, X_1, LA, X_4), 
X_4 \ge 7) \bagclose
\end{multline*}
%
The c-table for the overall result is as shown in Example \ref{ex:intro}. 
%
\punto
\end{example}


