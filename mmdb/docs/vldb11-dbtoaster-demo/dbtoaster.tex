\label{sec:dbtoaster}

The \compiler\ project investigates processing techniques and architectural
design for dynamic data management systems. Its two core research themes are
that of incremental query processing, and program synthesis where we can tailor
the design of system internals to yield lightweight, efficient data management
tools. Algorithmic trading, where specialized engines abound, is a natural use
case for \compiler. High-frequency data ingestion and the competitive advantage
of low latencies has led to widespread use of low-level code and processing
hardware such as FPGAs. We describe the computational and software development
aspects of the \compiler\ platform and toolchain below.

\tinysection{Dynamic Data Management}
\compiler\ constructs dynamic data management tools that process database
updates as incrementally as possible. Its query model is identical to that of
view maintenance~\cite{griffin-sigmod:95}, where given a SQL query on a
database, it generates a program to maintain query results as the database
changes. Its novelty lies in the nature of this maintenance program, and its use
of \textit{agile} views and \textit{multi-level} view maintenance.

Like view maintenance, \compiler\ materializes a query as a view, and maintains
the view using a (first-level) \textit{delta} query. Going beyond view
maintenance, we observe that a delta query is simply a parameterized SQL query.
This first-level delta query can also be materialized, and subsequently
maintained by a second-level delta query. There are a bounded number
of higher-level delta queries we can construct. Thus query processing works by a
sequence of maintenance statements, where each statement maintains a
\textit{k}-level view based on some computation applied to a
\textit{k+1}-level view. Further details on the compilation process and
structure of incremental programs can be found in~\cite{KAK2011,koch-pods:10}.
\comment{
As an example, \compiler\ turns the following query:

\begin{verbatim}
select sum(a.vol-*b.vol)
from bids b, asks a where b.price=a.price;
\end{verbatim}

\noindent into an imperative style program as shown below.

\begin{verbatim}
double q;
hash_map<double, double> c_b, sv_b, c_a, sv_a;
// c_b,c_a = count per price for bids, and asks.
// sv_b,sv_a = total vol per price for bids, and asks. 

on_insert_asks(double price, double vol): 
 q += vol * c_a[price] - sv_a[price];
 cb[price] += 1; sv_b[price] += vol;

on_insert_bids(double price, double vol):
 q += sv_b[price] - vol * c_b[price];
 sv_a[price] += vol; c_a[price] += 1;
\end{verbatim}
}

\comment{
\tinysection{Query Engine Compilation and Synthesis}
The \compiler\ compilation framework uses two internal representations to
synthesize stream engines, the first is a query calculus used to compute
higher-level delta queries as mentioned above and for a variety of
simplifications relating to constant folding, unification, variable elimination
and factorization. The second representation is a collection-oriented functional
language, extended with constructs such as persistence and resource annotations
to better utilise the hardware for computations performed by queries.

\todo{SQL queries, preaggregation, construction of incremental plan 
(polynomialization, delta transformation, simplification, repeat), low-level
compilation}

\todo{Diagram of platform: query, compiler, code generator backends, use of
generated code in runtimes}
}

\comment{
In its current incarnation, \compiler\ acts as a one-shot compiler that
transforms standard SQL queries into incremental programs as described above.
}
\compiler\ provides an extensible, retargettable code generator that currently
has support for running incremental programs in a variety of imperative,
functional and query languages (C++, Java, OCaml, pgplsql, PLSQL), as well as on
massively parallel processing infrastructures (Hadoop, and DBToaster Cumulus, a
fine-grained shared nothing stream engine under development). In this
demonstration, we will compile SQL queries to Java for our coarse-grained stream
engine, Jasper.


\tinysection{Programming with DBToaster} 
The benefits of type-safety, analysis and optimization opportunities offered by
language integrated queries and embedded domain specific query languages has
greatly improved the development process for applications interacting with data
management systems. To this day however, the focus has been on using databases
either as a persistence layer~\cite{wiedermann-popl:07}, or as
coprocessors~\cite{grust-sigmod:09}. The \compiler\ project faces outwards from
data management techniques, viewing such trends as an opportunity to export and
embed query processing, optimization, indexing and storage, transaction
management, and concurrency directly into application code.

\comment{
\note{Comment on the advantages of native code querying, esp. in terms
of UDFs (aka abstraction in the PL literature).}
}


Our current focus is on main-memory view maintenance. \compiler\ uses an
embedded SQL DSL called \dsl\ (\dslurl) to integrate with application code
written in \targetlang. As an example snippet, assuming we have a
\texttt{SOBI} method as described in Section~\ref{sec:intro} defined using the
\texttt{query.from(\ldots).where(\ldots).list(\ldots)} style syntax of \dsl
\footnote{\dsl\ supports a larger subset of SQL than SPJAG queries,
we use this form to generically illustrate the comprehension composition
syntax of language integrated queries.}\ , we route orders based on connection
state:

\begin{verbatim}
HashMap<String, ConnectionState> conns =
  openConnections({"NASDAQ"; "NYSE"});
OrderAction action = SOBI(exposure, funds, threshold);
if ( conns.get("NASDAQ").latency >
       conns.get("NYSE").latency )
  action.execute(conns.get("NASDAQ"));
else action.execute(conns.get("NYSE"));
\end{verbatim}

\dsl\ generates SQL query strings in a type-safe manner and executes them
over a \driver\ connection. We are developing a bare-bones \driver\ driver to
support the execution of SQL queries, which involves (just-in-time) query
compilation via the \compiler\ compiler into \targetlang\ code, dynamic loading
of the \targetlang\ classes corresponding to the newly created query engine, and
finally engine execution.


Applications can access
result sets which are internally backed by the data structures maintained by
\compiler\ engines. In addition to the standard pull-based interfaces provided
by the JDBC API, we provide an API for push-based notifications and application
code execution via callbacks. 
\comment{
Other event-driven mechanisms that we will develop
in the future include proxy datastructures and futures \todo{[CIDR]}.
}
To summarize, in this demonstration, we will show how \compiler\ can be used to
create a pure Java application that embeds an in-process relational stream
engine.


\tinysection{The DBToaster Runtime}
In addition to supporting direct application use of queries, \compiler\ provides
a query runtime to facilitate managed execution of queries, in particular to
provide a coarse-grained approach to scaling query workloads by performing
resource allocation and distributed execution. The \compiler\ runtime is a
distributed stream processing engine called \spe\ which has been inspired by
earlier efforts on the Borealis project~\cite{borealis-design:05}. \spe\ is
implemented in Java making it well suited to JVM-based target
languages for \compiler. Jasper internally invokes \compiler\ to generate
operators. Our operators are arbitrarily complex queries that may
perform nesting, multiway joins, essentially the full fragment of SQL
supported by \compiler, enabling the specification of operators or
\textit{modules} in a declarative language. \spe\ can provide window query
functionality around modules (which simply invoke insert or delete triggers in
\compiler\ code), as well core runtime and distribution mechanisms such as
checkpointing, or migrating operators (all \compiler\ code includes
automatic serialization of internal state).

\comment{
\todo{What kind of coupling do we provide for application and queries with this
managed runtime? Are apps also compiled into migratable modules, or do we
provide a layer of indirection at their interaction to let us do whatever we
want under the hood?}
}