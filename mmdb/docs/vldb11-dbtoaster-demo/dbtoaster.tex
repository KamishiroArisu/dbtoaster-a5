\label{sec:dbtoaster}

The \compiler\ project investigates processing techniques and architectural
design for dynamic data management systems. Its two core research themes are
that of incremental query processing, and program synthesis where we can tailor
the design of system internals to yield lightweight, efficient data management
tools. Algorithmic trading, where specialized engines abound, is a natural use
case for \compiler. High-frequency data ingestion and the competitive advantage
of low latencies has led to widespread use of low-level code and processing
hardware such as FPGAs. We describe the computational and software development
aspects of the \compiler\ platform and toolchain below.

\tinysection{Dynamic Data Management}
\compiler\ constructs dynamic data management tools that process database
updates as incrementally as possible. Its query model is identical to that of
view maintenance \todo{[IVM citations]}, where given a SQL query on a database,
it generates a program to maintain query results as the database changes. Its
novelty lies in the nature of this maintenance program, and its use of
\textit{agile} views and \textit{multi-level} view maintenance.
\todo{Blurb about agile views, etc.}

\tinysection{Query Engine Compilation and Synthesis}
The \compiler\ compilation framework uses two internal representations to
synthesize stream engines, the first is a query calculus used to compute
higher-level delta queries as mentioned above and for a variety of
simplifications relating to constant folding, unification, variable elimination
and factorization. The second representation is a collection-oriented functional
language, extended with constructs such as persistence and resource annotations
to better utilise the hardware for computations performed by queries.

\todo{SQL queries, preaggregation, construction of incremental plan 
(polynomialization, delta transformation, simplification, repeat), low-level
compilation}

\todo{Diagram of platform: query, compiler, code generator backends, use of
generated code in runtimes}

In its current incarnation, \compiler\ acts as a one-shot compiler that
transforms standard SQL queries into incremental programs as described above.
\compiler\ supports an extensible, retargettable code generator that currently
has support for running incremental programs in a variety of imperative or
functional languages (C++, Java, OCaml), as well as on massively parallel
processing infrastructures (Hadoop, and DBToaster Cumulus, a fine-grained
shared-nothing streaming runtime currently under development). In this
demonstration, we will compile SQL queries to Java, for use in our
coarse-grained stream engine, Jasper (we describe this in more detail below).


\tinysection{Programming with DBToaster} 
The benefits of type-safety and the ability to analyse and optimize expressions
offered by language integrated queries and embedded domain specific query
languages has greatly improved the development process for applications
interacting with data management systems. To this day however, the focus has
been on using databases either as a persistence layer \todo{[xxx]}, or as
coprocessors \todo{[Ferry]}. The \compiler\ project faces outwards from data
management techniques, viewing such trends as an opportunity to export
and embed query processing, optimization, indexing and storage,
transaction management, and concurrency directly into application code.

\note{Comment on the advantages of native code querying, esp. in terms of UDFs
(aka abstraction in the PL literature).}


Our current focus is on main-memory view maintenance. \compiler\ uses an
embedded SQL DSL called \dsl\ (\dslurl) to integrate with application code
written in \targetlang.
\todo{Simple \dsl\ example with \targetlang\ app logic.}
\dsl\ generates SQL query strings in a type-safe manner and executes them
over a \driver\ connection. We are developing a bare-bones \driver\ driver to
support the execution of SQL queries, which involves (just-in-time) query
compilation via the \compiler\ compiler into \targetlang\ code, dynamic loading
of the \targetlang\ classes corresponding to the newly created query engine, and
finally engine execution.


Applications can access
result sets which are internally backed by the data structures maintained by
\compiler\ engines. In addition to the standard pull-based interfaces provided
by the JDBC API, we provide an API for push-based notifications and application
code execution via callbacks. Other event-driven mechanisms that we will develop
in the future include proxy datastructures and futures \todo{[CIDR]}. To
summarize, in this demonstration, we will show how \compiler\ can be used to
create a pure Java application that embeds an in-process relational stream
engine.


\tinysection{The DBToaster Runtime}
In addition to supporting direct application use of queries, \compiler\ provides
a query runtime to facilitate managed execution of queries, in particular to
provide a coarse-grained approach to scaling query workloads by performing
resource allocation and distributed execution. The \compiler\ runtime is a
distributed stream processing engine called \spe\ which has been inspired by
earlier efforts on the Borealis project~\todo{[CIDR 05]}. \spe\ is
implemented in Java making it well suited to JVM-based target
languages for \compiler, and internally invokes \compiler\ to generate
operators. Our operators are arbitrarily complex queries that may
perform nesting, multiway joins, essentially the full fragment of SQL
supported by \compiler, enabling the specification of operators or
\textit{modules} in a declarative language. \spe\ can provide window query
functionality around modules (which simply invoke insert or delete triggers in
\compiler\ code), as well core runtime and distribution mechanisms such as
checkpointing, or migrating operators (given that all \compiler\ code includes
automatic serialization of internal state).

\todo{What kind of coupling do we provide for application and queries with this
managed runtime? Are apps also compiled into migratable modules, or do we
provide a layer of indirection at their interaction to let us do whatever we
want under the hood?}

\todo{Architecture diagram and components: data structures, compiling
operators, Jasper (a simple, generic stream processor), external windowing of
queries with Jasper+DBToaster}