\label{sec:intro}

In recent years, high-frequency algorithmic trading systems have come to account for a majority
of volume traded at the major US and European financial markets (for instance,
for 73\% of all US equity trading volume in the first quarter of 2009
\cite{Iati2009}). The success of automated trading systems depends critically on
the speeds at which trading strategies are processed: trading systems that react faster to market events
tend to make money at the cost of slower systems. Unsurprisingly, algorithmic
trading has become a substantial source of business for the IT industry; for
instance, it is the leading vertical among the customer bases for high-speed
switch manufacturers (e.g., Arista \cite{Becht2010}) and data stream processing.




A typical algorithmic trading system is run by mathematicians who develop
trading strategies and by programmers and systems experts who implement these
strategies to perform fast enough, using mainly low-level programming languages
such as C. Developing trading strategies requires a feedback loop of simulation,
back-testing with historical data, and strategy refinement based on the insights
gained. This loop, and the considerable amount of low-level programming that it
causes, is the root of a very costly {\em productivity bottleneck}\/: in fact,
the number of programmers often exceeds the number of strategy designers by
an order of magnitude.


Trading algorithms often perform a considerable amount of data crunching
and statistical processing that could in principle be implemented using SQL
views, coupled with some relatively straightforward control and trading logic.
%
Differently from other areas of finance such as technical analysis,
where stream processing engines
\cite{motwani-cidr:03,borealis-design:05} can be applied,
data processing in trading algorithms using views cannot be performed by DBMS or
data stream processing systems today: the former are not able to (1) {\em update
their views at the required rates}\/ (for popular stocks, hundreds of orders per
second may be executed, even outside burst times) and the latter are not able to
(2) {\em maintain large enough data state}\/ and support suitable query
languages (non-windowed SQL aggregates) on this state.

%
A data management system that could handle these two requirements would yield a
very substantial productivity increase that can be directly monetized --
a silver bullet for algorithmic trading.



To understand the need to maintain and query a data that may contain relatively old items, which renders stream windows unsuitable, note that
many stock exchanges provide a detailed view of the market microstructure
through complete bid and ask {\em limit order books}. The bid order book is a
table of purchase offers with their prices and volumes, and correspondingly the
ask order book indicates investors' selling orders. Exchanges execute trades by
matching bids and asks by price and favoring earlier timestamps. Investors
continually add, modify or withdraw limit orders, thus one may view order books
as relational tables subject to high update volumes. The availability of order
book data has provided substantial opportunities for automatic algorithmic
trading.



\begin{example}\em
To illustrate this, we discuss Static Order Book Imbalance (SOBI) trading
strategies. These act if the shapes of the distributions of bid and ask
order books -- say, captured by moments expressible as aggregate queries --
differ significantly. A simple example SOBI strategy \cite{sobi-kearns}
computes a volume-weighted average price (VWAP) over those
orders whose volume makes up the fixed $k$-fraction of the total stock volume
with strike prices closest to the last price, for both
bid and ask order books. It then compares the two VWAPs and, based on
this, predicts a future price drift.
For simplicity, we present the queries relevant for computing
VWAP for the bids only:
\begin{verbatim}
select sum(volume) as bid_vol from bids;

select sum(b2.price * b2.volume / bid_vol) as bid_vwap
from   bids b2
where (select sum(volume) from bids b1
       where b1.price > b2.price)  <=  k * bid_vol
\end{verbatim}
Overall, the strategy could be
\begin{verbatim}
imbal  := bid_vwap + ask_vwap - 2 * lprice;
volume := exposure * funds / lprice;
if       imbal > threshold then  buy(lprice, volume);
else if -imbal > threshold then sell(lprice, volume)
\end{verbatim}
where lprice is the last price and
ask\_vwap is the query analogous to bid\_vwap
on the ask order book.
For the imbalance measure, note that if e.g.\ the last price was 100 and
the volume-weighted average bid and ask prices are 95 and 110, respectively,
then imbal is +5.
Buying and selling at the last price will allow to preempt the
anticipated price move and later reverse the trade once the
move has happened.

Focusing on the $k$-fraction of the order book closest to the last price
renders the SOBI strategy less prone to attacks known as {\em axes}\/ (large
tactical orders far from the last price that will thus not be executed but
may confuse competing algorithms).

Another class of SOBI strategies uses the ratio
among the total volumes of the two order books, again avoiding axes by cutting off
outlier orders. This ratio is an indicator of a future price drift (upwards if
the volume in the buy order book exceeds the volume in the sell order book,
and downwards if the opposite is the case). This can be exploited by preempting
the drift by trading at the current price and later reversing the trade after the price move has materialized.
\punto
\end{example}


Returning to the two requirements mentioned above,
for trading algorithms to be successful, (1)
views such as VWAP need to be maintained and monitored by the algorithms at or
close to the trading rate. However, (2) the views cannot be expressed through
time-, row- or punctuation-based window semantics.
This scenario is, however, exactly the sweet spot for agile views
\cite{KAK2011}, which combine (update) stream processing with aggressive
incremental view maintenance.

In the following, we describe our approach to creating algorithmic
trading platforms based on an update stream processors we have developed and
{\em agile views}\/ \cite{KAK2011}, which are materialized views
that are continuously maintained by aggressively incremental code generated
by our DBToaster compiler \cite{ahmad-vldb:09,koch-pods:10,KAK2011}.
It is this platform and the
associated declarative trading strategy definition and development environment
that we propose to demonstrate at VLDB 2011.


