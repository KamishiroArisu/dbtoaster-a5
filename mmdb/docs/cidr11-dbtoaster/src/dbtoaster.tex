\label{sec:compilation}

View maintenance is at the heart of a DDMS and its state transitions. Current
incremental view maintenance (IVM)
techniques~\cite{roussopoulos-tods:91,griffin-sigmod:95,zhou-icde:07,zhou-vldb:07}
start with a query $q$, and produce a pair $\tuple{m,q'}$ corresponding to the
materialization $m$ of $q$, and the delta query $q'$ responsible for maintaining the
materialization respectively. The delta query can be thought of as an
SQL query over the current database, parameterized by the update.
On an update $u$, IVM performs the work: $m \mbox{
{\tt+}= } q'(u)$. Here, a materialized view is updated with the result of a
delta query taking parameters from $u$, and this must ensure $m = q(db_{new})$,
where $db_{new}$ is the result of applying the update to the database.

\subsection{View Maintenance in DBToaster}
DBToaster makes the following key insight regarding IVM: current IVM techniques
evaluate delta queries from scratch, performing much redundant work. Evaluating the delta
query $q'$ incurs the cost of accessing and processing all tuples in the base
tables $q$, excepting the one table being updated in the case of self-joins. DBMS suffer this cost
\textit{even if there is no change to any of the aforementioned base tables}.
DBToaster materializes the result of the delta query, adds it to the database
schema and maintains it at runtime.
That is, IVM takes $q$, produces $\tuple{m,q'}$ and performs
$m \; \mbox{{\tt +}=} \; q'(u)$ at runtime. We call this one step of
\textit{compilation}. DBToaster starts with $q$, produces
$\tuple{m,q'}$, then \textit{recurs}, taking $q'$ to produce $\tuple{m', q''}$
and repeating. Here $m'$ is maintained as $m' \; \mbox{{\tt +}=} \; q''(u)$.
We can again recur with $q''$, materializing as $m''$, maintaining with
$q'''$, a third-order delta, and so forth.


\def \sql#1{{\scriptsize {\tt #1}}}
\begin{figure*}[htbp]

\vspace{-8mm}

\begin{tabular}{ll|l|l|ll}
\multicolumn{2}{l}{Input (parent query)}
& Update 
& \multicolumn{3}{l}{Outputs: materialized map, delta query}
\\
\hline
$q =$
& \sql{select l.ordkey, o.sprior,}
& \texttt{+customer}
& $m[ordkey,sprior]$
& $q' =$
& \sql{select l.ordkey, o.sprior,}
\\
& \sql{\ \ \ \ \ \ \ sum(l.extprice) from}
& \texttt{(ck,nm,nk,bal)}
& & & \sql{sum(l.extprice)}
\\
& \sql{customer c, orders o, lineitem l}
& & & & \sql{from orders o, lineitem l}
\\
& \sql{where c.custkey = o.custkey}
& & & & \sql{where @ck = o.custkey} 
\\
& \sql{and l.ordkey = o.ordkey}
& & & & \sql{and l.ordkey = o.ordkey}
\\
& \sql{group by l.ordkey, o.sprior;}
& & & & \sql{group by l.ordkey, o.sprior;}
\\
\hline
$q'$:
& Recursive call,
& \texttt{+lineitem} 
& $m'[custkey,ordkey,sprior]$
& $q'' =$ & \sql{select @ok, o.sprior,@ep*sum(1)}
\\
& see previous output
& \texttt{(ok,ep)} & & & \sql{from orders o where}
\\
& & & & & \sql{$ck$ = o.custkey and @ok = o.ordkey}
\\
\hline
$q''$:
& Recursive call,
& \texttt{+order} 
& $m''[custkey,ordkey,sprior]$
& $q'''=$ & \sql{select @sp, count()}
\\
& see previous output
& \texttt{(ck,ok,sp)}
& & & \sql{where $ck$ = @ck and $ok$ = @ok;}
\end{tabular}
\caption{Recursive query compilation in DBToaster. For query $q$, we produce a
sequence of materializations and delta queries for maintenance: $\tuple{m,q'},
\tuple{m',q''}, \tuple{m'',q'''}$. This is a partial compilation trace, our
algorithm considers all permutations of updates.}
\label{fig:compex}
\vspace{-4mm}
\end{figure*}

DBToaster performs \textit{recursive query compilation} by successively
computing and materializing delta queries for higher-order deltas, such as
$q''$, a second-order delta query. DBToaster terminates given one critical
property of delta queries: \textit{a delta query is structurally simpler than its
parent query} \cite{koch-pods:10}. In particular \textit{k}-th order delta query, $q^{(k)}$ has fewer
input relations than a \textit{k-1}-th order query $q^{(k-1)}$, but additional
parameters corresponding to attributes that are present in $q^{(k-1)}$.
DBToaster represents materialized views in main memory as map data structures.
Maps are group-by aggregates, with keys of group-by attributes, and values as
the aggregate.

Figure~\ref{fig:compex} provides a concrete example of compiling a query $q$,
similar to TPC-H Query 3. 
The map produced as the materialized view for $q$ is $m$; the
aggregate value stored for group $[ordkey,sprior]$ can be accessed as
$m[ordkey,sprior]$.
The first-order delta query $q'$ includes a
parameter {\tt @ck}, supplied by the insertion to the customer table.
We materialize $q'$ with its parameter {\tt @ck} as $m'[custkey,ordkey,sprior]$.
To maintain $m$ on insertions {\tt +customer(ck,nm,nk,bal)}, we use
a map lookup $m'[\mbox{{\tt ck}},ordkey,sprior]$, instead of evaluating
$q'(\mbox{{\tt ck}})$. In this lookup, the values of $ordkey$, $sprior$ come
from $m$. Map $m$ maintains aggregates for every $ordkey$, $sprior$ seen in the
update stream, as does $m'$. The maintenance statement to keep $m$ up to date
from $m'$ is:

\comment{
\tinysection{Materialized views as maps}
Figure~\ref{fig:compex} provides a concrete example of compiling a query $q$,
similar to TPH-C Query 3. We represent our materialized views as map
data structures in main memory, and the map produced as the view for $q$ is
$m[ordkey,sprior]$. The map's key corresponds to group-by attributes and the
map's value is the unnamed aggregate value. We can answer $q$ from the
key-value entries in $m$. The first-order delta query $q'$ includes a parameter
{\tt @ck}, supplied by the insertion to the customer table.

\tinysection{Map lookups}
We materialize $q'$ with its parameter {\tt @ck} as $m'[custkey,ordkey,sprior]$.
When maintaining $m$ on insertions {\tt +customer(ck,nm,nk,bal)}, we can now use
a map lookup $m'[\mbox{{\tt ck}},ordkey,sprior]$, instead of evaluating
$q'(\mbox{{\tt ck}})$. In this lookup, the values of $ordkey$, $sprior$ come
from $m$. Map $m$ maintains aggregates for every $ordkey$, $sprior$ seen in the
update stream, as does $m'$. The maintenance statement to keep $m$ up to date
from $m'$ is:
}

{\footnotesize
\begin{verbatim}
on_insert_customer(ck,nm,nk,bal):
  m[ordkey,sprior] += m'[ck,ordkey,sprior];
\end{verbatim}
}

\noindent
Note that $ordkey$ and $sprior$ do not occur as arguments of the {\tt
on\_insert\_customer} trigger: Conceptually, map $m$ is updated by looping over
all $(ordkey, sprior)$ pairs in its domain. Read and write locations are (for a
large class of queries, always) in one-to-one correspondence, allowing for an
embarrassingly parallel implementation (see Section~\ref{sec:distribution}).

Figure~\ref{fig:compex} shows the recursive nature of the algorithm: we compile
$q'$ to $m',q''$ on insertion {\tt +lineitem}, and then $q''$ to
$\tuple{m'',q'''}$ on insertion {\tt +order}. The delta query $q'''$ is the
terminal step since the query does not depend on the database (there are no
relations, only parameters). Our algorithm considers all possible update
orderings, for example deltas of $q$ for insertions and deletions to {\tt order}
and then {\tt lineitem}.  We express the path taken as part of the map name:
$m'$ and $m''$ are $m\_c$ and $m\_cl$ respectively.  Due to limited space, we
only show the transition program for insertions.


\comment{
\tinysection{Compilation example}
We present an example of recursive compilation on a query similar to
TPC-H Query 3:

\comment{
\def \ql#1{{\tt #1}}
\hspace{-6mm}
\begin{tabular}{ll}
$q =$ & \ql{select\ \ \ l.ordkey, o.sprior, sum(l.extprice)}\\
      & \ql{from\ \ \ \ \ customer c, orders o, lineitem l}\\
      & \ql{where\ \ \ \ c.custkey = o.custkey}\\
      & \ql{and\ \ \ \ \ \ l.ordkey = o.ordkey}\\
      & \ql{group by l.ordkey, o.sprior;}
\end{tabular}
}


\noindent Let us denote this query as $q$, and its materialization $m$.
Technically $m$ has result schema {\tt ordkey, sprior} and an unnamed
aggregate value. We represent our materialized views as map data structures,
writing this as $m[ordkey, sprior]$. In this case the map's
key corresponds to group-by attributes and the map's value is the unnamed aggregate
value. We can answer $q$ by yielding the key-value entries in $m$.

\comment{
We represent our materialized views as map data structures, and
denote this by a two-level map $m[][ordkey, sprior]$. Since we materialize
delta queries, which are parameterized SQL queries, the first level of our maps
corresponds to parameters, while the second level to the query's result schema.
In this case the map's second level key corresponds to group-by attributes and
the map's value is the unnamed aggregate value. Thus we can answer the query by
iterating over all entries (group-by values) in map $m$, and yielding each
aggregate value.
}

We can take the delta (as defined in existing IVM literature
\todo{[REFs]}) of an insertion, {\tt +c(ck,nm,nk,bal)} to the {\tt customer}
relation, to produce a first-order delta query:

\comment{
\hspace{-6mm}
\begin{tabular}{ll}
$q' =$  & \ql{select\ \ \ l.ordkey, o.sprior,sum(l.extprice)}\\
        & \ql{from\ \ \ \ \ orders o, lineitem l}\\
        & \ql{where\ \ \ \ @ck = o.custkey}\\
        & \ql{and\ \ \ \ \ \ l.ordkey = o.ordkey}\\
        & \ql{group by l.ordkey, o.sprior;}
\end{tabular}
}

\noindent Above, {\tt @ck} is a parameter that is filled in by the update {\tt
+c(ck,nm,nk,bal)}. We materialize $q'$ as $m'[ck,ordkey,sprior]$, where $m'$ has
an additional attribute in its key for parameter $ck$. When maintaining $m$ on
insertion {\tt +c(ck,nm,nk,bal)}, instead of evaluating $q'(\mbox{{\tt ck}})$,
with {\tt ck} from the update, we can use a map lookup of $m'[\mbox{{\tt
ck}},ordkey,sprior]$. In this lookup, the values of $ordkey$, $sprior$ come from
$m$. Map $m$ maintains aggregates for every $ordkey$, $sprior$ seen in the
update stream, thus, so does $m'$. We iterate over every entry in $m$, to
maintain $m$ from $m'$, leading to the maintenance statement:

\begin{verbatim}
on_insert_customer(ck,nm,nk,bal):
  for each ordkey,sprior in m:
    m[ordkey,sprior] += m'[ck,ordkey,sprior];
\end{verbatim}

\noindent In this document, we omit for loops in update statements. They are
implicit based on the function arguments -- above $ordkey$,$sprior$ are not
arguments, thus require a loop over the map being updated.
\comment{
\noindent We need not explicitly represent the for loop above. Observe that
neither $ordkey$ nor $sprior$ are part of the function's arguments. We consider
variables not occuring in arguments to implicitly require loops over the map
appearing on the left hand side of a map update statement. The above becomes:

\begin{verbatim}
on_insert_customer(ck,nm,nk,bal):
  m[ordkey,sprior] += m'[ck,ordkey,sprior];
\end{verbatim}
}
The algorithm also computes deltas to $q$ for insertions to {\tt order} or {\tt
lineitem}, however we omit these due to limited space. We show the full
transition program for all insertions at the end of the example.

We now incrementally maintain $m'$, say on insertion {\tt +l(ok,ep)} with a
second-order delta query:

\comment{
\hspace{-6mm}
\begin{tabular}{ll}
$q'' =$  & \ql{select\ \ \ @ok, o.sprior,@ep*count()}\\
         & \ql{from\ \ \ \ \ orders o}\\
         & \ql{where\ \ \ \ $ck$ = o.custkey and @ok = o.ordkey}\\
         & \ql{group by o.sprior;}
\end{tabular}
}

\comment{
\hspace{-6mm}
\begin{tabular}{ll}
$q'' =$  & \ql{select\ \ \ @ok, o.sprior,sum(@ep)}\\
         & \ql{from\ \ \ \ \ orders o}\\
         & \ql{where\ \ \ \ $ck$ = o.custkey and @ok = o.ordkey}\\
         & \ql{group by o.sprior;}
\end{tabular}
}

\noindent This delta removes {\tt l.ordkey} as a group-by attribute,
since the update only affects a single group given by the value of parameter
{\tt @ok}.

\comment{
Furthermore, since we are summing up a parameter {\tt @ep}, we can
apply distributivity laws of sum aggregates and rewrite this to:

\hspace{-6mm}
\begin{tabular}{ll}
$q'' =$  & \ql{select\ \ \ @ok, o.sprior,@ep*count()}\\
         & \ql{from\ \ \ \ \ orders o}\\
         & \ql{where\ \ \ \ $ck$ = o.custkey and @ok = o.ordkey}\\
         & \ql{group by o.sprior;}
\end{tabular}
}

\noindent Above, we use $ck$ to distinguish parameters that are part of some map
key, and parameters that are part of the update such as {\tt @ok}. The parameter
$ck$ originates from {\tt c.custkey} in $q$, so map key components can be
passed through multiple levels of compilation. We materialize $q''$ as
$m''[ck,ok,sprior]$ and produce the maintenance statement on line 8 below.

\comment{
\begin{verbatim}
on_insert_lineitem(ok,ep):
  m'[ck,ok,sprior] += ep * m''[ck,ok,sprior];
\end{verbatim}
}

\noindent Finally, we can take the delta of an insertion {\tt +o(ck,ok,sp)} to
maintain $m''$:

\comment{
\hspace{-6mm}
\begin{tabular}{ll}
$q''' =$  & \ql{select\ \ \ @sp,count()}\\
          & \ql{where\ \ \ \ $ck$ = @ck and $ok$ = @ok;}
\end{tabular}
}

\noindent This delta query is the terminal point of recursive compilation, since
we have replaced all relations with updates. This query yields a scalar value of
0-1 based on whether the parameters in {\tt +o(ck,ok,sp)} satisfy the predicate,
as we loop over the entries of the map to be maintained, namely $m''$. The
maintenance statement is shown on line 16 below.

\comment{
\begin{verbatim}
on_insert_order(ck,ok,sp):
  m''[ck',ok',sp] +=
    if ck'==ck and ok'==ok then 1 else 0
\end{verbatim}

\noindent This can be simplified by noting that only a single entry is
incremented by a non-zero value, yielding:

\begin{verbatim}
on_insert_order(ck,ok,sp): m''[ck,ok,sp] += 1
\end{verbatim}
}

\noindent Our compilation algorithm considers all possible update orders, and
materializes each delta query encountered.  For each update order, there are different maps created.  We express the path taken as part of the map name: $m'$ and $m''$ are $m\_c$ and $m\_cl$ respectively.  Some paths produce maps based on equivalent queries; DBToaster detects these and reuses the same map.  The full transition program is:
}

{\footnotesize
\begin{verbatim}
1.  on_insert_customer(ck,nm,nk,bal) :
2.    m[ordkey, sprior] += m_c[ck, ordkey, sprior];
3.    m_l[ordkey, sprior] += m_cl[ck, ordkey, sprior];
4.    m_o[ck] += 1;
5. 
6.  on_insert_lineitem(ok,ep) :
7.    m[ok, sprior] += ep *  m_l[ok, sprior];
8.    m_c[custkey, ok, sprior] +=
9.      ep *  m_cl[custkey, ok, sprior];
10.   m_co[ok] += ep;
11.
12. on_insert_order(ck,ok,sp) :
13.   m[ok, sp] += m_co[ok] * m_o[ck]; 
14.   m_l[ok, sp] += m_o[ck];
15.   m_c[ck, ok, sp] += m_co[ok];
16.   m_cl[ck, ok, sp] += 1;
\end{verbatim}
}

\tinysection{Transition program properties}
For many queries, compilation yields \textit{simple} code that has no joins
and no nested loops, only single-level loops that perform probing as
in hash joins.
\comment{
The transition program also exploits distributivity to push down aggregates
through joins, yielding small map sizes since maps maintain group-by aggregates.
}
Simple code is beneficial for analysis and optimizations in machine
compilation and code generation.

Transition programs leverage more space to trade off time by materializing delta
queries. These space requirements are dependent on the active domain sizes of
attributes, and often attributes do not have many distinct values, for example
there are roughly 2800 unique stock ids on NASDAQ and NYSE. Additionally pruning
duplicate maps during compilation facilitates much reuse of maps given recursion
through all permutations of updates. Finally, there are numerous opportunities
to vary space-time requirements for transitions: we need not materialize all
higher-order deltas. For example we could maintain $q$ with $m^i$, a
materialized $i$-th order delta and perform more work during the update to
evaluate $q^{(i-1)}, \ldots, q^{(1)}$. We could further amortize space by
exploiting commonality across multiple queries, merging maps to service multiple delta
queries.



\tinysection{Insights}
\comment{
We highlight a few insights drawn from our experience in
several iterations of algorithm design. Compiling the transition function for
view maintenance is advantageous and feasible (in that it terminates) due to the
property that higher order delta queries successively get simpler and simpler.
The terminal delta consists of parameters alone, and does not depend on the
database.
}
Queries are closed under taking deltas, that is, a delta query is of the same
language as the parent query. In the above example, we have materialized all
deltas, thus the transition program consists of simple arithmetics on parameters
and map lookups. In general, closed deltas mean evaluation using a relational
engine, such as an existing DBMS kernel. However, we believe we can innovate in
the design of main-memory query processors. We touch on this below.

Finally, our concept of higher-order deltas draws novel, natural analogies to
mathematics. We have a rich formal framework, partially described
in~\cite{koch-pods:10}, where the techniques sketched here are proven correct.
In our framework, queries are polynomials, queries admit transformations
compactly represented by a \textit{ring} algebraic structure, and we demonstrate
polynomial degrees are reduced under taking deltas, much like derivatives in
calculus.

\tinysection{Discussion}
To summarize, in contrast to today's IVM, DBToaster uses materialization of
higher order deltas for continuous query evaluation that is \textit{as
incremental as possible}. DBToaster is capable of handling a wide range of
queries, including, as discussed next, nested queries. This has not been
addressed in the IVM literature, and lets our technique cover complex, composed
queries, where being as incremental as possible is highly advantageous.

The use of rings on queries with equi-joins and sum aggregations can be cast as
the generalized distributive law (GDL)~\cite{aji-toit:00} applied to query
processing. GDL facilitates fast algorithms for many applications including
belief propagation and message passing algorithms, and Viterbi's algorithm. With
this analogy, we hope to leverage other techniques from this field, for example
approximation techniques.


\subsection{Compilation Enhancements}
\noindent We briefly discuss further compilation issues and optimizations beyond
the fairly simple query seen in Figure~\ref{fig:compex}.


\comment{
\tinysection{Deletions}
Our example above only mentions inserts, but handling deletions turns out to be
straightforward. Our framework represents both the database and queries entirely
as maps\footnote{We have toyed with calling our system a MapStore, but prefer a
name with mystique, DBToaster.}, including base relations. Base relations are
multisets, or, maps with keys according to the relation's schema and values from
tuple's cardinalities, e.g. a tuple $\tuple{a=3,b=5}$ occurring three times in
relation $R(a,b)$ is a map entry $m[3,5] \mapsto 3$. Deletions are simply tuples
with negative multiplicities, and are implemented in their own transition
function.

\tinysection{Simplifying Delta Queries}
Transition compilation internally uses several techniques to simplify queries
as we are taking deltas. We present two of these here, starting with
unification leading to variable elimination. Consider the SQL query:
\begin{verbatim}
select sum(l.extendedprice) from partsupp ps, lineitem l
where @pk = ps.partkey and ps.partkey = l.partkey
      and ps.suppkey = l.suppkey and l.quantity < 10
\end{verbatim}
By unifying the parameter {\tt @pk}, \todo{finish, needs a better example\ldots} 

The second simplification is factorization. Consider the query:
\texttt{select sum(c.acctbal*(l.extprice-l.discount))
from customer c, lineitem l}.
We can write this as a product of two separate, simpler, aggregates:
\begin{verbatim}
(select sum(c.acctbal) from customer c) * 
(select sum(l.extprice-l.discount) from lineitem l)
\end{verbatim}

\noindent and independently compute deltas for each aggregate. Factorization is
frequently possible when considering star schemas in analytics applications, and
generalizes to structural decompositions, such as hypertree decomposition
\todo{[REF Gottlob]}. While there has been much work in decomposing join
hypergraphs, structurally decomposing aggregate queries would be interesting
future work.
}

\tinysection{Nested queries}
We can compile transitions for nested queries, which has not been feasible in
existing IVM techniques. In particular nested scalar subqueries used in
predicates are problematic because taking deltas of such predicates does not
result in simpler expressions. Our algorithm would not terminate if we did not
handle this: we explicitly find simpler terms and recur on them. VWAP
in Section 1 exemplifies a nested query.

Nested subqueries contain correlated attributes (e.g. price in VWAP)
defined in an outer scope. We consider correlated attributes as parameters, or,
internally in our framework, as binding patterns, seen in data integration.
Nested queries induce \textit{binding propagation}, similar to sideways
information passing in datalog. That is, we support the results of one query
being used (or \textit{propagated}) to the parameters of a correlated subquery,
indicating an evaluation ordering.
We transform queries to use minimal propagation, which performs additional
aggregation of maps, over dimensions of the map key that are not propagated. For
example a map $m[x,y,z]$ would be aggregated (\textit{marginalized}) to
$m'[x,y]$ if $x,y$ were the only correlated attributes.



\comment{
\tinysection{Initial values}

\tinysection{Windows, Constraints, Other Aggregates}
\begin{itemize}
  \item Do you really want to include this section? What do you have to say
  that's strong here \note{i.e. what can you say about compiling to specific
  data structures beyond maps?}
  \item Our model of transitions generally addresses the issues of incremental
  processing and can handle stream processing features such as windows.
  \item In fact we can exploit additional schema information such as
  key/foreign-key relationsips, integrity constraints and so forth to further
  simplify our programs. \note{Give simple example with an integrity
  constraint, i.e. we can avoid generating a statement if we know an entry
  cannot exist in another relation due to integrity.}
  \item Min/max handling. The hard case is deletion, since we have to recompute
  from scratch. Our compilation framework uses a query representation where
  everything is a map, including base tables. Thus we can easily express
  materializing relations in addition to group-by aggregates, requiring no
  change to handle other aggregates. This also applies to queries without
  aggregation, for example a SPJ query. \footnote{We have toyed with calling our
  system a MapStore, but prefer a name with mystique, DBToaster.}
\end{itemize}
}



\tinysection{Towards optimizing engine physicality}
We are adopting a functional programming (FP) approach to compilation to better
capture the need for binding patterns in delta queries, and to apply
optimizations from FP, such as exploiting structural recursion
(SR)~\cite{buneman-kleisli:95}. SR enable optimizations of arbitrarily nested
collections such as sets, bags and lists. We can use SR optimizations to
manipulate \textit{physical-level properties}, such as tuple construction and
pipelining.

Delta queries consist of cross products and joins of many maps, due to
factorization of, and binding propagation in queries. In a traditional DBMS,
cross products and joins consume and produce relations, ``flattening''
intermediate results into rows. Column-stores have argued for late tuple
construction~\cite{abadi-icde:07}. We produce intermediate results in nested
form (cf. nested relations and objects), potentially nested deeply after
combining several maps. With SR and function composition, we can
programmatically control where, and how much tuple construction we perform.

We can also entirely avoid constructing \textit{any} intermediate results, let
alone flattening intermediates. This enables \textit{automatic} transformation
of a join-tree into an n-way join, which, for example on a series of cross
products, yields an n-level pipelined nested loops implementation that avoids
expensive intermediates, leading to a much richer space of join plans. DBToaster
would be the first engine to incorporate automated, programmatic manipulation of
physical aspects of plans, since we reason about processing with data
structures, not an operator abstraction that hides and encapsulates data
structures. Our techniques will be equally applicable to main-memory DBMS due to
closed delta queries.


