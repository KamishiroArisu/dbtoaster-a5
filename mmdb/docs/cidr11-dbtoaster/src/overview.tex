\comment{
\begin{figure}
(a) DDMS: show state machine, with databases as states and updates as transitions.

(b) DBMS: database sits and waits for queries to arrive; answers them.

(c) Data stream processor: Set of sitting queries; a stream of data passes by.

\caption{Data management systems architectures: DDMS vs. DBMS vs. data stream processors.}
\end{figure}
}

% Should we have an even higher-level overview here, giving a high-level picture of the  DDMS API

DDMSes are update processors.  Data enters the DDMS via its update stream, is
processed, incorporated into its persistent state, and the results are passed to
the end-user.  Thus the logical abstraction for discussing DDMSes is
process-centric\cite{demers-sigmod:07}: The DDMS represented as a(n infinite) state machine with the
machine's state representing an entire relational database at one point in time.

The state of the state machine is organized into a schema of
base relations, materialized views, and other auxiliary datastructures.  We
refer to the parts of the schema representing the user's views of interest as the \textit{visible schema}.

At the highest level, transitions in this model correspond to modifications of a traditional DBMS' base relations.  However, these transitions can be complex, data-dependent beasts; The transition's effect (eg., on a view constructed from a three table join) can depend on the results of a subquery (joining the other two tables).  These subqueries can be integrated directly into the DDMS.

Viewing the database as a state machine suggests that we can precompute each state transition function to make it as efficient as possible.  While ``compiling'' the DDMS, we can identify subqueries present in each transition function and construct an \textit{auxiliary schema}.  These views, not visible to the user, substantially reduce the overall work required to compute each transition.

\begin{figure}
\begin{center}
\includegraphics[scale=0.35]{graphics/CIDRarch.pdf}
\end{center}
\caption{Dynamic Data Management System (DDMS) and Application Interface
Architecture}
\label{fig:ddmsarch}
\end{figure}


\tinysection{DDMS architecture}
Figure~\ref{fig:ddmsarch} provides an architectural design for a DDMS. View
queries and stream queries are specified with embedded SQL or StreamSQL
statements. The application must also specify how the DDMS can invoke
application logic on dynamic results. Unlike JDBC or ODBC interfaces, the key
requirement here is asynchronous result handling, through callbacks, futures and
promises (objects enabling proxies of values to be computed, that are bound
following delayed evaluation), or via registration on a DDMS event loop and
queue. We will also support ad-hoc queries that can apply standard processing on
top of DDMS views, through an existing DBMS side-by-side with the DDMS handling
updates.



Internally, a DDMS is built around the concept of transitioning database state,
and this is realized first and foremost through a transition compiler (discussed
in more detail in the next section). Compilation results in transition programs,
that modify the database state upon update events, comprising the core runtime
engine of a DDMS. The visible and auxiliary views that are part of the state
rely on a storage manager to aid in physical aspects of handling large states,
including implementing a variety of layouts and indexes to facilitate
processing. The runtime includes a continuous query optimizer that guides the
decisions to be made across the database schema, state and storage, in terms of
the cost of applying transitions on updates.




\comment{
Structure of this section:
\begin{itemize}
\item
Mention that viewing the problem in a slightly different way can produce a
dramatically different implementation.


\item
State machine abstraction

\item
Programming model: Boolean views are events, which trigger application code

\item
Architecture diagram:
Compiler/Optimizer: produces low-level view maintenance code.
Update stream.
Event notification facility.
Event notification by invocation by the view maintenance code?
Ad-hoc querying in client-side library?

\item updates can potentially modify many viees

\item
System description.
This really cannot be understood if taken out of context and should be moved to
the following sections.

\begin{itemize}
\item
Query optimization: The next section describes a method of incremental view
maintenance that relies on materializing multiple layers of auxiliary views.
This trades off view maintenance time cost against space cost. The optimizer
will exploit the potential to save space by  deciding which auxiliary view
layers to materialize and which to leave implicit. It will also perform
multi-view optimization, deciding which auxiliary views from different visible
views can be merged.


What do we say about the structural recursion optimization, and where do we say it?

\item
Low-level data structures: we will describe the multi-level hash table data
structure in section 4. Work on parallelization will be required. Our data
structures are a bit unusual since they represent exclusively aggregates and
their values are exclusively numerical. It is a conseqence of our approach that
loops in query processing are always over a set of complete dimensions of the
multi-dimensional table data structures we use; thus all our loops are naturally
implemented as full scans over these dimensions. However, many fields in these
tables will be zero and indexing or compression could be employed to omit
scanning over all-zero areas.

\end{itemize}
\end{itemize}
}


