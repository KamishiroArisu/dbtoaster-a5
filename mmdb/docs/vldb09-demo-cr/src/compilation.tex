
\section{Query Compilation}

\def\algsum{\mathrm{sum}}
\def\algagg{\mathrm{agg}}
\def\algtop{\mathrm{top}}
\def\algtopk{\mathrm{topk}}

\def\algsumr{\mbox{sumr}}
\def\algsumf{\mbox{sumf}}
\def\distinct{\mbox{distinct}}
\def\routerjoin{\bowtie\!=}

We now present \compiler's compilation algorithm through an example illustrating
how queries are turned into efficient procedural code. Our compilation framework
applies to the core relational algebra and group-by aggregates, and uses a custom
query algebra to define map data structures. These maps are closely related to
views definable by SQL aggregate group-by queries but at the same time are main
memory data structures that are easy to access in applications. Due to space
limitations, we present a small fraction of our map algebra simplifications as
needed for our example query. Our full map algebra is approximately 70
simplification rules.

\noindent\textbf{Compilation example.} Consider the query below on three
relations and schemas $R(A,B), S(B,C), T(C,D)$:

\vspace{-1mm}
\begin{verbatim}
  select sum(A*D) from R, S, T
      where R.B=S.B and S.C=T.C
\end{verbatim}
\vspace{-1mm}

Given the data and query model above, we assume relations $R, S, T$ are
manipulated via update streams which consist of the standard requests
of inserting, updating and deleting tuples. For ease of presentation, we can
consider updates as pairs of delete and insert requests. We start with handling
an insert to the relation $R$, with a tuple $\{\tuple{a,b}\}$. Assuming
the variable $q$ maintains the query result, we can show:

\smallskip
Insert R(a,b):
\begin{eqnarray*}
\Delta q &=& \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T)
\\ &=&
\algsum_{A*D}(\{a\} \times \sigma_{B=b}(S) \bowtie T)
\\ &=&
\algsum_{a*D}(\sigma_{B=b}(S) \bowtie T)
\\ &=&
a * \underbrace{\algsum_{D}(\sigma_{B=b}(S) \bowtie T)}_{q_D[b]}
\end{eqnarray*}

Above $q_D[b]$ is an example of a map that we use to compute the change in query
result $q$, a map with key-value entries of keys $b$, and values defined as
the result of the query: $\algsum_{D}(\sigma_{B=b}(S) \bowtie T)$. While we do
not go into the full details of the derivation validity, we can see it is a
simplification of the original query by considering the relation $R$ as a
singleton relation $\{\tuple{a,b}\}$. We can symmetrically derive for inserting
into relation $T$ as: $\Delta q = d * q_A[c]$, resulting in a map
$q_A[c] = \algsum_{A}(R \bowtie \sigma_{C=c}(S))$. An insert on $S$ is:

\smallskip
Insert S(b,c):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie \{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{A*D}(\sigma_{B=b}(R) \times \sigma_{C=c}(T))
\\ &=&
\underbrace{\algsum_{A}(\sigma_{B=b}(R))}_{q_A[b]} *
\underbrace{\algsum_{D}(\sigma_{C=c}(T))}_{q_D[c]}
\end{eqnarray*}



\begin{figure*}[tb]
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|}
\hline
Recursion level & Event & Query, $Q$, to compile & Code for $\Delta Q$
& Maps used in code & Map definition\\
\hline
1 & $\pm R(a,b)$ & $\algsum_{A*D}(R \bowtie S \bowtie T)$
& $\pm a*q_D[b]$ & $q_D[b]$ & $\algsum_{D}(\sigma_{B=b}(S) \bowtie T)$
\\
\hline
1 & $\pm S(b,c)$ & $\algsum_{A*D}(R \bowtie S \bowtie T)$
& $\pm q_A[b] * q_D[c]$ & $q_A[b]$ & $\algsum_{A}(\sigma_{B=b}(R))$
\\
& & & & $q_D[c]$ & $\algsum_{D}(\sigma_{C=c}(T))$
\\
\hline
1 & $\pm T(c,d)$ & $\algsum_{A*D}(R \bowtie S \bowtie T)$
& $\pm d*q_A[c]$ & $q_A[c]$ & $\algsum_{A}(R \bowtie \sigma_{C=c}(S))$
\\
\hline
2 & $\pm R(a,b)$ & $\algsum_{A}(R \bowtie \sigma_{C=c}(S))$
& $\mbox{foreach($c$): } \pm a * q_1[b,c]$ & $q_1[b,c]$ &
$\algsum_{1}(\sigma_{BC=bc}(S))$
\\
2 & $\pm R(a,b)$ & $\algsum_{A}(\sigma_{B=b}(R))$
& $\pm a$ & (no new maps) & \\
\hline
2 & $\pm S(b,c)$ & $\algsum_{A}(R \bowtie \sigma_{C=c}(S))$
& $\pm q_A[b]$ & (no new maps) & 
\\
2 & $\pm S(b,c)$ & $\algsum_{D}(\sigma_{B=b}(S) \bowtie T)$
& $\pm q_D[c] $ & (no new maps) & 
\\
\hline
2 & $\pm T(c,d)$ & $\algsum_{D}(\sigma_{B=b}(S)\bowtie T)$
& $\mbox{foreach($b$): }\pm d * q_1[b,c]$ & $q_1[b,c]$ &
$\algsum_{1}(\sigma_{BC=bc}(S))$
\\
2 & $\pm T(c,d)$ & $\algsum_{D}(\sigma_{B=b}(T))$
& $\pm d$ & (no new maps) & \\
\hline
3 & $\pm S(b,c)$ & $\algsum_{1}(\sigma_{BC=bc}(S))$
& $\pm 1$ & (no new maps) & \\
\hline
\end{tabular}
\end{center}

\vspace{-2mm}

\caption{\compiler's recursive compilation of the
'\texttt{select sum(a*d) from R, S, T}' query, showing the query being compiled,
the procedural code required to incrementally compute the query result, maps
required by the code, and the query defining the map. Above, the event $\pm R$
indicates both an insert and delete on $R$, and we present the code
in one piece, although \compiler\ would produce different event handlers.}
\label{tab:derivation}

\vspace{-2mm}
\end{figure*}


Note the elimination of any join in the above query since we are able to exploit
distributivity properties of summation and multiplication, and the cross product
operator. At this point we have presented one level of compilation, for an
insertion into each base relation $R, S, T$, resulting in incremental query
result computation code, a set of maps which we have to maintain, and queries
defining the map contents. At this point, we recursively compile the map
definition queries, considering each of the three types of insertion (to
$R,S,T$). We subsequently aggressively inline any code generated into a handler
for each type of insertion. For example, consider the maps $q_A[c], q_A[b]$
above, whose entries are dependent on the relation $R$. We recursively compile
incremental maintenance of this map for insertions to $R$ as:

\smallskip
Insert R(a,b):
\begin{eqnarray*}
\Delta q_A[b] &=& \algsum_{A}(\{\tuple{a,b}\}) = a
\\
\mbox{foreach $c$: }
\Delta q_A[c] &=& \algsum_{A}(\{\tuple{a,b}\} \bowtie \sigma_{C=c}(S))
\\ &=&
\algsum_{a}(\sigma_{BC=bc}(S))
\\ &=&
a * \underbrace{\algsum_{1}(\sigma_{BC=bc}(S))}_{q_1[b,c]}
\end{eqnarray*}

Above, we use $\algsum_{1}$ to refer to a count aggregate, that is 
$\algsum_{1}(\sigma_{BC=bc}(S))$ is a count of $\tuple{b,c}$ tuples in S.
Note the \textit{foreach} statement when computing $\Delta q_A[c]$. This arises
since a single tuple $\tuple{a,b}$ in $R$ affects all map entries with keys
$c^*$ where the relation $S$ contains tuples $\tuple{b,c^*}$. Again our
compilation is symmetric for the relations $R$ and $T$ due to the nature of the
join graph in this query. Thus the maintenance code for maps $q_D[b]$, and 
$q_D[c]$ is:

\smallskip
Insert T(c,d):
\begin{eqnarray*}
\Delta q_D[c] &=& d\\
\Delta q_D[b] &=& \mbox{foreach(c): } d * q_1[b,c]
\end{eqnarray*}

\noindent For an insertion to $S$, we must maintain maps $q_A[c], q_D[b]$:

\smallskip
Insert S(b,c):
\begin{eqnarray*}
\Delta q_A[c] &=&
\algsum_{A}(R \bowtie \{\tuple{b,c}\})
\\ &=&
\algsum_{A}(\sigma_{B=b}(R) \times \{c\})
\\ &=&
\algsum_{A}(\sigma_{B=b}(R))
\;=:\; q_A[b]
\\
\Delta q_D[b] &=&
\algsum_{D}(\{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{D}(\{b\} \times \sigma_{C=c}(T))
\\ &=&
\algsum_{D}(\sigma_{C=c}(T))
\;=:\; q_D[c]
\end{eqnarray*}

\noindent Note that we are already maintaining maps $q_A[b], q_D[c]$ above, that
is, we can exploit map sharing opportunities across event handler functions.
Finally, we maintain $q_1[b,c]$ for insertions to $S$ simply as:
$\Delta q_1[b,c] = 1$. We show the resulting handler functions from this example,
including the inlining of code fragments generated at each recursive step.

\vspace{-1mm}
\begin{verbatim}
// Declarations; initializations (to 0) are omitted
double q; // result
double q_A_b[], q_A_c[], q_D_b[], q_D_c[], q_1_bc[][];

// Event handlers
void on_insert_into_R (double a, double b) {
   q += a * q_D_b[b];   q_A_b[b] += a;
   foreach (c in q_A_c.keys()) do
      q_A_c[c] += a * q_1_bc[b][c];
}

void on_insert_into_S (double b, double c) {
   q += q_A_b[b] * q_D_c[c];   q_A_c[c] += q_A_b[b];
   q_D_b[b] += q_D_c[c];       q_1_bc[b][c] += 1;
}
void on_insert_into_T (double c, double d) {
   q += q_A_c[c] * d;   q_D_c[c] += d;
   foreach (b in q_D_b[b].keys()) do
      q_D_b[b] += q_1_bc[b][c] * d;
}
\end{verbatim}
\vspace{-1mm}

Additionally Table~\ref{tab:derivation} compactly describes this compilation
example, including the case of deletion events which turn out to be strictly analogous in
this case due to the fact that sum aggregates have a well defined inverse as
subtraction.


\comment{
Query compilation in \compiler\ is founded on an algebra for manipulating a map
data structure. Our map algebra is related to SQL queries through the use of a
map to represent a group-by aggregate. A map algebra expression, or map for
short, is defined as one of the following forms:
\[
f_1 + f_2
\quad\;\;
f_1 * f_2
\quad\;\;
c
\quad\;\;
x
\quad\;\;
\algsumf_f(Q)
\]
where $f, f_1, f_2$ are map algebra expressions, $c$ are numerical constants,
$x$ are variables, and $Q$ are positive relational algebra
expressions.

Variables in maps are {\em free} unless they are {\em bound}. Given a map $f$
with free variables $\vec{x}$ (enumerated in the order in which they first appear
in $f$), $f[\vec{a}]$, where $\vec{a}$ is a tuple of variables and constants of
the same arity as $\vec{x}$ denotes each $x_i$ in $f$ substituted by $a_i$. The
variables $\vec{x}$ in $f[\vec{a}]$ are then called bound. So, for instance, the
free variables of $5 * x + y$ are $x,y$ and $(5 * x + y)[z, 2]$ is $5 * z + 2$
with free variable $z$. The number of free variables in a map is also called the
map's dimension.

(Positive) relational algebra expressions are built using relation names,
selection $\sigma$, projection $\pi$, relational product $\times$, union $\cup$,
constant singleton relations $\{\vec{a}\}$,
and renaming $\rho$.
Column names $A$ are treated like bound variables.
Selection conditions are comparisons
$f \;\theta\; 0$ where $\theta \in \{ =, \neq, <, \le, >, \ge \}$.
Projections may compute additional columns
using map algebra expressions, i.e.\ the syntax is
$\pi_{\vec{A}, f_1 \rightarrow B_1, \dots, f_k \rightarrow B_k}(Q)$. 

We use a multiset semantics for relations as in SQL; none of the operations
of relational algebra eliminate duplicates.
Otherwise, the semantics of relational algebra expressions $Q$ is standard.
Variables in $\vec{x}$ are {\em bound}\/ to constants from above; thus, 
the semantics of an aggregate map $\algsumf_f(Q)$ without free variables
is a single numerical value $v$ such that
\[
\algsumr_A(\pi_{f \rightarrow A}(Q))[] = \{ \tuple{v} \}.
\]
where $\algsumr$ is the ungrouped sum aggregate of SQL.

\subsection{Map compilation}
The goal of this section is to provide an algorithm for compiling map algebra
expressions into efficient C code that incrementally maintains the
maps they define.
We will need the following general-to-specific ordering $\prec$ on maps.


\begin{definition}\em
A map $f$ is called (strictly) {\em more specific than}\/ a map $f'$,
denoted $f \prec f'$, if $f$ can be obtained from $f'$ by replacing
one or more relation names occurring in $f'$ by fixed singleton relations.
\end{definition}


Note that this replacement may occur deep inside a map, not just in the topmost
relational algebra subexpression. For example,
\[
\algsumf_A(\pi_{\algsumf_B(\rho_B(\tuple{b})) + 2}(S))
\prec
\algsumf_A(\pi_{\algsumf_B(\rho_B(R)) + 2}(S))
\]


\begin{figure*}[t!]
%\begin{algorithm}
\begin{eqnarray*}
\Delta_{+R(\vec{r})} c       &:=& 0 \\
\Delta_{+R(\vec{r})} x       &:=& 0 \\
\Delta_{+R(\vec{r})} (f + g) &:=&  (\Delta_{+R(\vec{r})} f) + (\Delta_{+R(\vec{r})} g) \\
\Delta_{+R(\vec{r})} (f * g) &:=& f * (\Delta_{+R(\vec{r})} g) 
                              +   (\Delta_{+R(\vec{r})} f) * g                        
                              +   (\Delta_{+R(\vec{r})} f) * (\Delta_{+R(\vec{r})} g)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\{ \vec{a} \}) &:=& 0
\\
\Delta_{+R(\vec{r})} \algsumf_{A_i}(\rho_{\vec{A}}(R)) &:=& r_i
\\
\Delta_{+R(\vec{r})} \algsumf_A(S) &:=& 0
\\
\Delta_{+R(\vec{r})}  \algsumf_A(Q_1 \cup Q_2) &:=&
\Delta_{+R(\vec{r})} (\algsumf_A(Q_1) + \algsumf_A(Q_2))
\\
\Delta_{+R(\vec{r})} \algsumf_{f[\vec{A};\dots] * g[\vec{B};\dots]}(\rho_{\vec{A}}(Q_1) \times \rho_{\vec{B}}(Q_2)) \; &:=&
\Delta_{+R(\vec{r})} \big( \algsumf_{f[\vec{A};\dots]}(\rho_{\vec{A}}(Q_1))
    * \algsumf_{f[\vec{B};\dots]}(\rho_{\vec{B}}(Q_2)) \big)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\pi_{f + g \rightarrow A}(Q)) &:=&
\Delta_{+R(\vec{r})} \big( \algsumf_A(\pi_{f \rightarrow A}(Q))
   + \algsumf_A(\pi_{g \rightarrow A}(Q)) \big)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\pi_{f[\vec{x}] \rightarrow A}(Q)) &:=&
   (f + \Delta_{+R(\vec{r})} f)
   * \Delta_{+R(\vec{r})} \algsumf_1(Q)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\pi_{f \rightarrow A}(Q)) &:=&
   \algsumf_A(\pi_{\Delta_{+R(\vec{r})} f \rightarrow A}(Q)) \\
   &+& \algsumf_A(\pi_{f \rightarrow A}(\Delta_{+R(\vec{r})} Q)) \\
   &+& \algsumf_A(\pi_{\Delta_{+R(\vec{r})} f \rightarrow A}(\Delta_{+R(\vec{r})} Q))
\\
\Delta_{+R(\vec{r})} \algsumf_A(\sigma_{g \theta 0}(Q)) &:=&
\mbox{if ($\Delta_{+R(\vec{r})} g \;\theta\; 0$) then
   $\algsumf_A(Q + \Delta_{+R(\vec{r})}(Q))$} \\
&& \mbox{else if ($(g + \Delta_{+R(\vec{r})} g \;\theta\; 0) \Rightarrow
(g \;\theta\; 0)$) then $- \algsumf_A(Q)$ else 0}
\end{eqnarray*}
%\end{algorithm}
%
\caption{Recursive algorithm for compiling the
on insert into $R$ values $\vec{r}$ trigger.}
\label{fig:mainalg}
\end{figure*}


Figure~\ref{fig:mainalg} shows our compilation algorithm for maps, the core
procedure of the DBToaster compiler. Given a map $f$, it inductively computes a
delta-expression that does not use relational algebra.

It is easy to verify that the right-hand sides of the rewriting are successively
simpler by either being dominated by the left-hand sides under the general-to-specific
ordering $\prec$ or being sums or products of
strictly shorter expressions.

Thus, the output of the rewriting algorithm given a map is a delta map that does not
contain aggregates or relational algebra. However, the rewriting may add new free
variables, i.e., starting from a map $f[\vec{x}]$, we may obtain an aggregate-free
map $g[\vec{x}, \vec{y}]$. We then {\em marginalize}\/ over these as follows,
\[
\Delta f[\vec{x}] = \sum_{\vec{y}} g(\vec{x}, \vec{y}). 
\]

Rather than explaining the rules in full detail here, we simply note that these
rules can be thought of as being similar to pattern matching, where the right
hand side map can be used to replace any matching left hand side. Furthermore,
note that the chain of derivations directly represent the code we must generate
and execute in our tuple-processing functions.

\subsection{Compilation Example}
We briefly provide an example application of our map rewrites on the following
aggregate query:

\[
s := \algsum_{A*D}(R \bowtie S \bowtie T).
\]

For illustration we simply consider the insertion of a new tuple into
solely the relation R. Also, since this example is only meant to be a brief
illustration due to space restrictions, we omit the case for deletions.

\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T)
\\ &=&
\algsum_{A*D}(\{a\} \times \sigma_{B=b}(S) \bowtie T)
\\ &=&
\algsum_{a*D}(\sigma_{B=b}(S) \bowtie T)
\\ &=&
a * \underbrace{\algsum_{D}(\sigma_{B=b}(S) \bowtie T)}_{s_D[b]}
\end{eqnarray*}

\end{itemize}

 
Next, we incrementally maintain $s_D[b]$, which in this case is maintained by
insertions into S.

\begin{itemize}
\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s_D[b] &=&
\algsum_{D}(\{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{D}(\{b\} \times \sigma_{C=c}(T))
\\ &=&
\algsum_{D}(\sigma_{C=c}(T))
\;=:\; s_D[c]
\end{eqnarray*}
\end{itemize}

Thus the code is:
\begin{verbatim}
on insert into R values (a,b)
{
   s += a * s_D[b];

   // Updates from R to other maps...
}

on insert into S values (b,c)
{
   s += s_A[b] * s_D[c];
   s_D[b] += s_D[c];
   // Updates from S to other maps...
}

// code for T ...
\end{verbatim}
}
