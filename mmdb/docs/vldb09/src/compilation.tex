\section{Query Compilation}


\def\algsum{\mathrm{sum}}
\def\algagg{\mathrm{agg}}
\def\algtop{\mathrm{top}}
\def\algtopk{\mathrm{topk}}



This section presents our framework for compiling aggregation queries down to
efficient procedural code for incrementally maintaining views of these queries.
We start with a definition of a clean
core of the query language supported by DBToaster.
This core is a query algebra for defining maps. These maps are closely related to
tables definable using SQL aggregate group-by queries but at the same time are main
memory data structures that are easy to access in applications.
After that, we present the core query compilation technique.
In the last part of this section, we discuss employing structural decomposition
techniques for reducing the memory consumed by our maps.

%following subsection, we refine this technique to employ join decomposition
%techniques or employ database query optimization ideas to reduce the space
%consumption of auxiliary maps and to reduce the time cost of maintaining
%the maps.


\subsection{The Map Algebra}


\def\algsumr{\mbox{sumr}}
\def\algsumf{\mbox{sumf}}
\def\distinct{\mbox{distinct}}
\def\routerjoin{\bowtie\!=}


The syntax of {\em map algebra expressions}\/ (or {\em maps} for short)
can be defined as follows.
Inductively, a map algebra expression is of one of the forms
\[
f_1 + f_2
\quad\;\;
f_1 * f_2
\quad\;\;
c
\quad\;\;
x
\quad\;\;
\algsumf_f(Q)
\]
where $f, f_1, f_2$ are map algebra expressions, $c$ are numerical constants,
$x$ are variables, and $Q$ are positive relational algebra
expressions.
($f_1 - f_2$ can be expressed as $f_1 + (-1) * f_2$.)

Variables in maps are {\em free} unless they are {\em bound}.
Given a map $f$ with free variables $\vec{x}$ (enumerated in the order in which they
first appear in $f$), $f[\vec{a}]$, where $\vec{a}$ is a tuple of variables and constants
of the same arity as $\vec{x}$ denotes each $x_i$ in $f$ substituted by $a_i$. The
variables $\vec{x}$ in $f[\vec{a}]$ are then called bound.
So, for instance, the free variables of $5 * x + y$ are $x,y$ and
$(5 * x + y)[z, 2]$ is $5 * z + 2$ with free variable $z$.
The number of free variables in a map is also called the map's dimension.
Since $f[\vec{x}]$ where the free variables of $f$ are $\vec{x}$ is again $f$, we
sometimes write $f[\vec{x}]$ to make the free variables of $f$ explicit.


(Positive) relational algebra expressions are built using relation names,
selection $\sigma$, projection $\pi$, relational product $\times$, union $\cup$,
constant singleton relations $\{\vec{a}\}$,
and renaming $\rho$.
(Note the absence of the relational difference operation at this point; we
relax this restriction later.)
W.l.o.g., we will use renaming only directly above relation names, i.e.\ in expressions
$\rho_{\vec{a}}(R)$.
Column names $A$ are treated like bound variables.
Selection conditions are comparisons
$f \;\theta\; 0$ where $\theta \in \{ =, \neq, <, \le, >, \ge \}$.
Projections may compute additional columns
using map algebra expressions, i.e.\ the syntax is
$\pi_{\vec{A}, f_1 \rightarrow B_1, \dots, f_k \rightarrow B_k}(Q)$. 

We use a multiset semantics for relations as in SQL; none of the operations
of relational algebra eliminate duplicates.
Apart from that, the semantics of relational algebra expressions $Q$ is standard.

Variables
in $\vec{x}$ are {\em bound}\/ to constants from above; thus, 
The semantics of an
aggregate map $\algsumf_f(Q)$ without free variables
is a single numerical value $v$ such that
\[
\algsumr_A(\pi_{f \rightarrow A}(Q))[] = \{ \tuple{v} \}.
\]
where $\algsumr$ is the ungrouped sum aggregate of SQL.


\begin{remark}\em
While nongrouped aggregation in SQL corresponds to our semantics of aggregate
maps $\algsumf_f(Q)$ of dimension zero apart from syntax (the result of $f[]$ is a scalar number
while the result of the SQL aggregate is a singleton unary relation),
the semantics of aggregate maps $f = \algsumf_f(Q)$ with
free variables $\vec{x}$ differs from that
of SQL group-by aggregates in that $f$ is a complete function defined everywhere
(indeed, $\algsumr_B(\sigma_{\vec{A}=\vec{a}}(Q))$ produces $\{\tuple{0}\}$ rather
than $\emptyset$ when $\sigma_{\vec{A}=\vec{a}}(Q)$ is the empty relation, and
$\algsumf_B(\emptyset) = 0$) while
the SQL aggregate-group-by query
$\sigma_{\vec{A}=\vec{a}}$(select $\vec{A}$, sum$(B)$ from $Q$ group by $\vec{A}$)
gives no value on tuples $\vec{a}$ that do not exists in $\pi_{\vec{A}}(Q)$.

Thus, for our purposes, SQL group-by aggregates do not generalize non-grouped
SQL aggregates. We avoid this in our map algebra -- this allows for a clean
compositional compilation framework, and for a focus on essential challenges
below. Still, the map algebra supports a wide range of practical queries.
%, and we will
%generalize it later to support even more once we have laid the
%necessary foundations.
\end{remark}


\begin{example}\em
\label{ex:compiler1}
The summation part\footnote{The average is the ratio
of this sum to a
counting version of this query in which $\algsumf_{P_2 * V_2}$ is replaced by
$\algsumf_1$.}
 of the VWAP query from the introduction was, in algebra notation with $\distinct$
denoting
tuple elimination and $\routerjoin$ denoting right outer join,
\begin{multline*}
\algsumr_{P_2 * V_2}(\algsumr_{V_0 \rightarrow S_0}(\rho_{P_0, V_0}(B))
\; \bowtie_{k * S_0 > S_1} \\
\algsumr_{V_1 \rightarrow S_1 \;\mathrm{grpby}\; P_2}(
\rho_{P_1, V_1}(B) \; \routerjoin_{P_1 > P_2} \\
\distinct(\pi_{P_2}(\rho_{P_2, V_2'}(B)))) \bowtie \rho_{P_2, V_2}(B)).
\end{multline*}

%Since $\distinct(\pi_{\vec{A}}(R)) \bowtie R = R$ in bag algebra,
%
This translates to our map algebra as
\[
\algsumf_{P_2 * V_2}(
\pi_{m_0[]  \rightarrow S_0}(\{\tuple{}\})
\; \bowtie_{k * S_0 > S_1}
\pi_{P_2, m_1[P_2] \rightarrow S_1}(B))[]
\]
%
where the maps $m_0$ and $m_1$ are
\begin{eqnarray*}
m_0[] &:=&
\algsumf_{V_0}(\rho_{P_0, V_0}(B))[]
\\
m_1[p_2] &:=&
\algsumf_{V_1}(\sigma_{P_1 > p_2}(\rho_{P_1, V_1}(B)))[p_2]
\end{eqnarray*}
The query can be simplified using standard relational algebra equivalences
further to
\begin{equation}
q[] = \algsumf_{P_2 * V_2}(
\sigma_{m[P_2] > 0}(\rho_{P_2, V_2}(B)))[]
\end{equation}
where
\[
m[p_2] = k * m_0[] - m_1[P_2].
\]
%\punto
\end{example}



\subsection{Map Compilation Algorithm}


The goal of this section is to provide an algorithm for compiling map algebra
expressions into efficient C code that incrementally maintains the
maps they define.
We will need the following general-to-specific ordering $\prec$ on maps.


\begin{definition}\em
A map $f$ is called (strictly) {\em more specific than}\/ a map $f'$,
denoted $f \prec f'$, if $f$ can be obtained from $f'$ by replacing
one or more relation names occurring in $f'$ by fixed singleton relations.
\end{definition}


Note that this replacement may occur deep inside a map, not just in the topmost
relational algebra subexpression. For example,
\[
\algsumf_A(\pi_{\algsumf_B(\rho_B(\tuple{b})) + 2}(S))
\prec
\algsumf_A(\pi_{\algsumf_B(\rho_B(R)) + 2}(S))
\]


\nop{
We use the notation $Q_{R \rightarrow R \cup \{\vec{r}\}}$ to denote
the relational algebra expression obtained from $Q$
by recursively replacing all occurrences of relation name $R$ in $Q$
by $R \cup \{\vec{r}\}$,
i.e., leaves $\algsumf_f(Q')$ are also replaced by
$\algsumf_f(Q'_{R \rightarrow R \cup \{\vec{r}\}})$.
Analogously, let $f_{R \rightarrow R \cup \{\vec{r}\}}$ denote the map obtained by
replacing all subexpressions $\algsum_g(Q)$ by
$\algsum_g(Q_{R \rightarrow R \cup \{\vec{r}\}})$.

Note that $\cup$ commutes with all the operations of positive relational 
(bag) algebra. Thus, we can always push unions to the top, turning an arbitrary
expression of positive relational algebra into a union of SPC (select-project-product)
queries (of possibly exponential size in the query).
We denote this operation by $\uparrow_{\cup}(Q)$.
} % end nop


\begin{figure*}[t!]
%\begin{algorithm}
\begin{eqnarray*}
\Delta_{+R(\vec{r})} c       &:=& 0 \\
\Delta_{+R(\vec{r})} x       &:=& 0 \\
\Delta_{+R(\vec{r})} (f + g) &:=& (\Delta_{+R(\vec{r})} f) + (\Delta_{+R(\vec{r})} g) \\
\Delta_{+R(\vec{r})} (f * g) &:=&         f                * (\Delta_{+R(\vec{r})} g)
                              +   (\Delta_{+R(\vec{r})} f) * g                        
                              +   (\Delta_{+R(\vec{r})} f) * (\Delta_{+R(\vec{r})} g)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\{ \vec{a} \}) &:=& 0
\\
\Delta_{+R(\vec{r})} \algsumf_{A_i}(\rho_{\vec{A}}(R)) &:=& r_i
\\
\Delta_{+R(\vec{r})} \algsumf_A(S) &:=& 0
\\
\Delta_{+R(\vec{r})}  \algsumf_A(Q_1 \cup Q_2) &:=&
\Delta_{+R(\vec{r})} (\algsumf_A(Q_1) + \algsumf_A(Q_2))
\\
\Delta_{+R(\vec{r})} \algsumf_{f[\vec{A};\dots] * g[\vec{B};\dots]}(\rho_{\vec{A}}(Q_1) \times \rho_{\vec{B}}(Q_2)) \; &:=&
\Delta_{+R(\vec{r})} \big( \algsumf_{f[\vec{A};\dots]}(\rho_{\vec{A}}(Q_1))
    * \algsumf_{f[\vec{B};\dots]}(\rho_{\vec{B}}(Q_2)) \big)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\pi_{f + g \rightarrow A}(Q)) &:=&
\Delta_{+R(\vec{r})} \big( \algsumf_A(\pi_{f \rightarrow A}(Q))
   + \algsumf_A(\pi_{g \rightarrow A}(Q)) \big)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\pi_{f[\vec{x}] \rightarrow A}(Q)) &:=&
   (f + \Delta_{+R(\vec{r})} f)
   * \Delta_{+R(\vec{r})} \algsumf_1(Q)
\\
\Delta_{+R(\vec{r})} \algsumf_A(\pi_{f \rightarrow A}(Q)) &:=&
   \algsumf_A(\pi_{\Delta_{+R(\vec{r})} f \rightarrow A}(Q)) \\
   &+& \algsumf_A(\pi_{f \rightarrow A}(\Delta_{+R(\vec{r})} Q)) \\
   &+& \algsumf_A(\pi_{\Delta_{+R(\vec{r})} f \rightarrow A}(\Delta_{+R(\vec{r})} Q))
\\
\Delta_{+R(\vec{r})} \algsumf_A(\sigma_{g \theta 0}(Q)) &:=&
\mbox{if ($\Delta_{+R(\vec{r})} g \;\theta\; 0$) then
   $(\algsumf_A(Q) \cup \Delta_{+R(\vec{r})}\algsumf_A(Q)))$} \\
&& \mbox{else if ($(g + \Delta_{+R(\vec{r})} g \;\theta\; 0) \Rightarrow
(g \;\theta\; 0)$) then $- \algsumf_A(Q)$ else 0}
\end{eqnarray*}
%\end{algorithm}

\vspace{-4mm}

\caption{Recursive algorithm for compiling the
on insert into $R$ values $\vec{r}$ trigger.}
\label{fig:mainalg}
\end{figure*}


Figure~\ref{fig:mainalg} shows our compilation algorithm for maps, the core procedure of the DBToaster compiler.
Given a map $f$, it inductively
computes a delta-expression that does not use relational algebra.
It is easy to verify that the right-hand sides of the rewriting are successively
simpler by either being dominated by the left-hand sides under the general-to-specific
ordering $\prec$ or being sums or products of
strictly shorter expressions.

Thus, the output of the rewriting algorithm given a map is a delta map that does not
contain aggregates or relational algebra. However, the rewriting may add new free
variables, i.e., starting from a map $f[\vec{x}]$, we may obtain an aggregate-free
map $g[\vec{x}, \vec{y}]$. We then {\em marginalize}\/ over these as follows,
\[
\Delta f[\vec{x}] = \sum_{\vec{y}} g(\vec{x}, \vec{y}). 
\]

Note that the insertion delta can be used for deletions as well because a deletion of
a tuple $\vec{r}$ from a relation $R$ can be expressed as $R - \{\vec{r}\}$ and,
although our map algebra has been defined to exclude relation difference,
it can be straightforwardly extended by safe difference, i.e. difference expressions
$R-S$ where it is guaranteed by construction that $R \subseteq S$, as will be inductively the case here. A map $\algsumf_A(R - S)$ is equivalent to
$\algsumf_A(R)$ - $\algsumf_A(S)$ if $R \subseteq S$.



\begin{theorem}
The delta processing scheme of the algorithm of Figure~\ref{fig:mainalg} is correct,
that is,
\begin{enumerate}
\item
on inserting tuple $\vec{r}$ into $R$, $f$ becomes
$f + \Delta_{+R(\vec{r})} f$;

\item
on inserting tuple $\vec{r}$ from $R$, $f$ becomes
$f - \Delta_{+R(\vec{r})} f$.
\end{enumerate}
\end{theorem}


This theorem can be shown by induction: in fact, the algorithm itself is an inductive
definition that can be straightforwardly implemented in a functional language such as
ML (as done in the DBToaster project). Note that the pattern matching rules are
deterministic, thus there is a unique derivation that is fully specified by our
algorithm.



\begin{example}\em
Let us now compute the trigger
\[
\mbox{on insert into B values ($p, v$)}
\]
for the summation part of the VWAP query (from Example~\ref{ex:compiler1})
\[
q[] = \algsumf_{P_2 * V_2}(\sigma_{m[P_2] > 0}(\rho_{P_2, V_2}(B)))
\]
where
\begin{eqnarray*}
m[p_2] &=&  k * \algsumf_{V_0}(\rho_{P_0, V_0}(B))   \\
       &-&  \algsumf_{V_1}(\sigma_{\underbrace{P_1 - p_2}_{g[p_2]} > 0}(\rho_{P_1, V_1}(B)))
\end{eqnarray*}

Then
\begin{eqnarray*}
\Delta_{+B(p,v)} m[p_2] &=&
            k * \Delta_{+B(p,v)} \algsumf_{V_0}(\rho_{P_0, V_0}(B))   \\
       &-&  \Delta_{+B(p,v)} \algsumf_{V_1}(\sigma_{P_1 - p_2 > 0}(\rho_{P_1, V_1}(B)))
\\
&=& k * v \\
&-& \mbox{if $(\Delta_{+B(p,v)} g > 0)$ then $v$} \\
& & \mbox{else if $(g[p_2] \ge p-p_2 > 0)$ then $-v$ else 0}
\\
\Delta_{+B(p,v)} g[p_2] &=& p - p_2 - g[p_2]
\\
\Delta_{+B(p,v)} q'[p_2] &=&
\mbox{if ($(m[p_2] > 0) \neq (m[p_2] + \Delta m[p_2] > 0))$ then}
\\
&& ~~~
      \mbox{sgn}(m[p_2] + \Delta_{+B(p,v)} m[p_2]) \\
&& ~~~ * \;  \mbox{$\underbrace{\algsumf_{P_2 * V_2}(\sigma_{P_2=p_2}(\rho_{P_2,V_2}(B)))[p_2]}_{s[p_2]}$} \\
&& \mbox{else 0}
\\
\Delta_{+B(p,v)} q[] &=&
\big( \mbox{if $(m[p] + \Delta_{+B(p,v)} m[p] > 0)$} \\
&&~~~ \mbox{then $p * v$ else $0$} \big)
\\
&+& \sum_{p_2} q'[p_2]
\\
\Delta_{+B(p,v)} s[p_2] &=& \mbox{if $(p = p_2)$ then v else 0}.
\end{eqnarray*}

Thus we generate the following code (map values are initially 0):
\begin{verbatim}
on insert into B values (p, v)
{
  if(! dom_m.member(p))
     { dom_m.add(p); m[p] = 0; }

  // computing deltas
  delta q = (m[p] > 0) ? (p * v) : 0;

  foreach p_2 in dom_m do
  {
     delta g[p_2] = p - p_2 - g[p_2];
     delta m[p_2] = k * v - ((p > p_2) ? v : 0);
     delta s[p_2] = (p = p_2) ? v : 0;
     delta q += ((m[p_2] > 0) !=
                 (m[p_2] + delta m[p_2] > 0)) ?
        sgn(m[p_2] + delta m[p_2])
           * (s[p_2] + delta s[p_2]) : 0;
  }

  // updating the maps
  q += delta q;
  foreach p_2 in dom_m do
  {
     m[p_2] += delta m[p_2];
     s[p_2] += delta s[p_2];
     g[p_2] += delta g[p_2];
  }
}
\end{verbatim}
%
%It makes sense to avoid naive looping over all values $p_2$ by maintaining
%$m_1[p_2]$ as a range data structure (to be described).
%\punto
\end{example}


Note that our delta processing scheme relatively straightforwardly generalizes
to min and max aggregates.\footnote{Indeed, the central decomposition rule
\[
\algsumf_f(Q_1 \cup Q_2) = \algsumf_f(Q_1) + \algsumf_f(Q_2)
\]
has its analog for max$_f$ (and thus min$_f(Q)$, which is $-\mbox{max}_{-f}(Q)$) in
the equivalence
\[
\max_f(Q_1 \cup Q_2) = \max(\max_f(Q_1), \max_f(Q_2)).
\]
}
However, differently from the sum aggregate, we have to
maintain a representation of the base relations to support for incremental view
maintenance under deletions. 




\subsection{Structural Query Decompositions and Memory Consumption}


Clearly, the memory consumption for representing a map with $k$ free
variables is
$O(n^k)$, where $n$ is bounded by the database size. In fact, it can be
seen that our compilation algorithm essentially preserves the (algebraic)
query plan given to it; while the number of branches of the map algebra
version of an operator tree in general increases in the compilation phase, the
dimensionality of intermediate result relations and correspondingly our maps
do not. This gives a strong argument for employing structural query decomposition techniques for generating query plans whose join graph is
as tree-like as possible: For example, for the structural query decomposition framework of hypertree decompositions \cite{GLS2002}, it is know that for relational algebra query plans that have hypertree-width $k$, non-pipelined operator-at-a-time bottom-up evaluation only yields intermediate result relations that are bounded by size $O(n^k)$ \cite{GLS2002}.

It is technical but not hard to see that the following holds.


\begin{theorem}
Let $\algsumf_A(Q)$ be a map in which the relational algebra query $Q$ has hypertree-with
$k$ and does not contain
a nested aggregate and 
\end{theorem}


This result is also true if we replace hypertree decompositions by the weaker
query decompositions of \cite{CK1997}.

Since the standard notion of acylicity in queries  \cite{Yan81, AHV95}
corresponds to hypertree-width one, we need only linearly sized maps for acyclic
relational algebra queries. Note also that while the notion of acylicity is best known
for conjunctive queries, it and the our above result apply more generally
to relational algebra.

DBToaster includes an implementation of a structural query decomposition algorithm
that computes hypertree compositions for relational algebra blocks inside


\begin{example}\em
Given schema $R(A,B)$, $S(B,C)$, $T(C,D)$.
We incrementally maintain the aggregate query
\[
s := \algsum_{A*D}(R \bowtie S \bowtie T).
\]

Compared to the map compilation algorithm of Figure~\ref{fig':mainalg}, we take a
few shortcuts for better readability (and extend the algebra by natural joins);
nevertheless following our algorithm yields equivalent maps. 
\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T)
\\ &=&
\algsum_{A*D}(\{a\} \times \sigma_{B=b}(S) \bowtie T)
\\ &=&
\algsum_{a*D}(\sigma_{B=b}(S) \bowtie T)
\\ &=&
a * \underbrace{\algsum_{D}(\sigma_{B=b}(S) \bowtie T)}_{s_D[b]}
\end{eqnarray*}

\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie \{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{A*D}(\sigma_{B=b}(R) \times \sigma_{C=c}(T))
\\ &=&
\underbrace{\algsum_{A}(\sigma_{B=b}(R))}_{s_A[b]} *
\underbrace{\algsum_{D}(\sigma_{C=c}(T))}_{s_D[c]}
\end{eqnarray*}
%
Note how the algebra expression here decomposes into smaller parts.

\item
Insert T(c,d): (analogous to insertion of R(a,b))
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie S \bowtie \{\tuple{c,d}\})
\\ &=&
\underbrace{\algsum_{A}(R \bowtie \sigma_{C=c}(S))}_{s_A[c]} * d
\end{eqnarray*}
\end{itemize}

We incrementally maintain $s_D[b]$, $s_A[b]$, $s_D[c]$, and
$s_A[c]$ as well.

\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s_A[b] &=& \algsum_{A}(\{\tuple{a,b}\}) = a
\\
\mbox{foreach $c$: }
\Delta s_A[c] &=& \algsum_{A}(\{\tuple{a,b}\} \bowtie \sigma_{C=c}(S))
\\ &=&
\algsum_{a}(\sigma_{BC=bc}(S))
\\ &=&
a * \underbrace{\algsum_{1}(\sigma_{BC=bc}(S))}_{s_1[b,c]}
\end{eqnarray*}

(Analogously insert T(c,d) for maintaining $s_{D}[b], s_{D}[c]$.)

\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s_A[c] &=&
\algsum_{A}(R \bowtie \{\tuple{b,c}\})
\\ &=&
\algsum_{A}(\sigma_{B=b}(R) \times \{c\})
\\ &=&
\algsum_{A}(\sigma_{B=b}(R))
\;=:\; s_A[b]
\\
\Delta s_D[b] &=&
\algsum_{D}(\{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{D}(\{b\} \times \sigma_{C=c}(T))
\\ &=&
\algsum_{D}(\sigma_{C=c}(T))
\;=:\; s_D[c]
\end{eqnarray*}
\end{itemize}

Finally, we want to incrementally maintain $s_1[b,c]$:
\begin{itemize}
\item
Insert S(b,c):
$
\Delta s_1[b,c] =
\algsum_{1}(\{\tuple{b,c}\}) = 1
$
\end{itemize}

Thus the code is:
\begin{verbatim}
on insert into R values (a,b) {
   s += a * s_D[b];
   s_A[b] += a;
   foreach c (in Cs[b]) do
      s_A[c] += a * s_1[b,c];
}

on insert into S values (b,c) {
   s += s_A[b] * s_D[c];
   s_A[c] += s_A[b];
   s_D[b] += s_D[c];
   s_1[b,c] += 1;
}

on insert into T values (c,d) {
   s += s_A[c] * d;
   s_D[c] += d;
   foreach b (in Bs[c]) do
      s_D[b] += s_1[b,c] * d;
}
\end{verbatim}
\punto

We can also consider deletions from base relations:

\begin{itemize}
\item
Delete R(a,b):
\begin{eqnarray*}
\algsum &=& \algsum_{A*D}((R-\{\tuple{a,b}\}) \bowtie S \bowtie T)\\
&=& \algsum_{A*D}((R \bowtie S \bowtie T) -
(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& \algsum_{A*D}(R \bowtie S \bowtie T) -\\
& & \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& \algsum' - \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
%\because
\Delta s &=&  - \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& -a*\algsum_{D}(\sigma_{B=b}(S) \bowtie T)
\end{eqnarray*} 
\end{itemize}

(Similarly for Delete S(b,c) and Delete T(c,d)).

Just as in the case for Inserts, we must also maintain additional data
structures needed by each delta handler, for example $s_{A}[c], s_{A}[b]$ needed
to dealing with deletions to relations S and C. Note that given subtraction is an
inverse operation for addition (hence $\algsum$) and is anticommutative with the
previous result as seen above, the maintenance we perform is
structurally identical to the case for inserts. 

\begin{itemize}
\item
Delete R(a,b):
\begin{eqnarray*}
\Delta s_{A}[b] &=& - \algsum_{A}(\{\tuple{a,b}\}) = -a\\
\Delta s_{A}[c] &=& -a * \algsum_{1}(\sigma_{BC=bc}(S))
\end{eqnarray*}
\end{itemize}
\end{example}


