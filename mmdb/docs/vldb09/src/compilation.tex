\section{Query Compilation}


\def\algsum{\mathrm{sum}}
\def\algagg{\mathrm{agg}}
\def\algtop{\mathrm{top}}
\def\algtopk{\mathrm{topk}}



This section presents our framework for compiling aggregation queries down to
efficient procedural code for incrementally maintaining views of these queries.
We start with a definition of a clean
core of the query language supported by DBToaster.
This core is a query algebra for defining maps. These maps are closely related to
tables definable using SQL aggregate group-by queries but at the same time are main
memory data structures that are easy to access in applications.
After that, we present the core query compilation technique and prove its correctness.
In the following subsection, we refine this technique to employ join decomposition
techniques or employ database query optimization ideas to reduce the space
consumption of auxiliary maps and to reduce the time cost of maintaining the maps.




\subsection{The Map Algebra}


\def\algsumr{\mbox{sumr}}
\def\algsumf{\mbox{sumf}}
\def\distinct{\mbox{distinct}}
\def\routerjoin{\bowtie\!=}


The syntax of the map algebra can be defined as follows.
Inductively, a map algebra expression is of one of the forms $f_1 + f_2$,
$f_1 - f_2$, $f_1 * f_2$, $f_1 / f_2$, $c$, $x$, and $\algsumf_A(Q)[\vec{x}]$,
where $f_1$ and $f_2$ are map algebra expressions, $c$ are numerical constants,
$x$ is a variable, $\vec{x}$ is a tuple of variables, $Q$ is a relational algebra
expression, and $A$ is a column name of the schema of the relation defined by $Q$.
We call the arity of the variable tuple of a map its {\em dimension}\/.
Relational algebra expressions are built using relation names,
selection $\sigma$, projection $\pi$, relational product $\times$, union $\cup$,
and renaming $\rho$. (Note the absence of the relational difference operation
at this point; we
relax this restriction later.) Selection conditions are comparisons
$f = 0$, $f > 0$, or $f \ge 0$.
Projections may compute additional columns
using map algebra expressions. 
The variables from $\vec{x}$ may be used in
any map algebra expression used in selections or projections of $Q$.

We use a multiset semantics for relations as in SQL; none of the operations
of relational algebra eliminate duplicates.
Apart from that, the semantics of relational algebra expressions $Q$ is standard.
Variables
in $\vec{x}$ are {\em bound}\/ to constants from above; thus, the semantics of an
aggregate map $\algsumf_f(Q)[\vec{x}]$, where $\vec{x}$ is bound to a tuple of
constants $\vec{a}$
(denoted $\algsumf_f(Q)[\vec{a}]$) is a single numerical value $v$ such that, if
$Q[\vec{a}]$ is $Q$ with the variables $\vec{x}$ substituted with the constants
$\vec{a}$ and $\algsumr_A$ is the standard sum aggregate function of SQL,
\[
\algsumr_A(Q[\vec{a}])[] = \{ \tuple{v} \}.
\]


\begin{remark}\em
Thus, while nongrouped aggregation in SQL corresponds to our semantics of aggregate
maps $f[]$ of dimension zero apart from syntax (the result of $f[]$ is a scalar number
while the result of the SQL aggregate is a singleton unary relation),
the semantics of aggregate maps $f[\vec{x}]$ of higher dimension differs from that
of SQL group-by in that $f[\vec{x}]$ is a complete function defined anywhere
(indeed, $\algsumr_B(\sigma_{\vec{A}=\vec{a}}(Q))$ produced $\{\tuple{0}\}$ rather
than no tuple at all when $\sigma_{\vec{A}=\vec{a}}(Q)$ is the empty relation) while
the SQL aggregate-group-by query
$\sigma_{\vec{A}=\vec{a}}$(select $\vec{A}$, sum$(B)$ from $Q$ group by $\vec{A}$)
gives no value on tuples $\vec{a}$ that do not exists in $\pi_{\vec{A}}(Q)$.

Thus, for our purposes, SQL group-by aggregates do not generalized non-grouped
SQL aggregates. We avoid this in our map algebra -- this allows for a clean
compositional compilation framework, and to focussing on the essential challenges
below. Still, the map algebra supports a wide range of practical queries, and we will
generalize it later to support even more once we have laid the necessary foundations.
\end{remark}


\begin{example}\em
The VWAP query from the introduction was, in algebra notation with $\distinct$
denoting
tuple elimination and $\routerjoin$ denoting right outer join,
\begin{multline*}
\algsumr_{P_2 * V_2}(\algsumr_{V_0 \rightarrow S_0}(\rho_{P_0, V_0}(B))
\; \bowtie_{k * S_0 > S_1} \\
\algsumr_{V_1 \rightarrow S_1 \;\mathrm{grpby}\; P_2}(
\rho_{P_1, V_1}(B) \; \routerjoin_{P_1 > P_2} \\
\distinct(\pi_{P_2}(\rho_{P_2, V_2'}(B)))) \bowtie \rho_{P_2, V_2}(B)).
\end{multline*}
This translates via 
\begin{multline*}
\algsumf_{P_2 * V_2}(
\pi_{m_0[]  \rightarrow S_0}(\{\tuple{}\})
\; \bowtie_{k * S_0 > S_1} \\
\pi_{P_2, m_1[P_2] \rightarrow S_1}
(\distinct(\pi_{P_2}(\rho_{P_2, V_2'}(B)))) \bowtie \rho_{P_2, V_2}(B))[]
\end{multline*}
%
where the maps $m_0$ and $m_1$ are
\begin{eqnarray*}
m_0[] &:=&
\algsumf_{V_0}(\rho_{P_0, V_0}(B))[]
\\
m_1[p_2] &:=&
\algsumf_{V_1}(\sigma_{P_1 > p_2}(\rho_{P_1, V_1}(B)))[p_2]
\end{eqnarray*}
to our map algebra:
\begin{multline*}
\algsumf_{P_2 * V_2}(
\sigma_{k * S_0 > S_1}( \\
\pi_{m_0[]  \rightarrow S_0, P_2, m_1[P_2] \rightarrow S_1}
(\distinct(\pi_{P_2}(\rho_{P_2, V_2'}(B))))) \bowtie \rho_{P_2, V_2}(B))[]
\end{multline*}
The query can be simplified using standard relational algebra equivalences
further to
\[
q[] = \algsumf_{P_2 * V_2}(
\sigma_{k * S_0 > S_1}(
\pi_{m_0[]  \rightarrow S_0, m_1[P_2] \rightarrow S_1, P_2, V_2}
(\rho_{P_2, V_2}(B))))[]
\]
and to
\begin{equation}
q[] = \algsumf_{P_2 * V_2}(
\sigma_{m[P_2] > 0}(\rho_{P_2, V_2}(B)))[]
\end{equation}
where
\[
m[p_2] = k * m_0[] - m_1[P_2].
\]
\punto
\end{example}



\subsection{Compiling Queries: Foundations}


The goal of this section is to provide an algorithm for compiling map algebra
expressions into efficient C code that incrementally maintains the
maps they define.
To be precise, we aim for the following notion of incremental maintenance.


\begin{definition}[YMCA maintenance scheme]\em
An incremental map maintenance algorithm has the YMCA
(Yanif Must Certainly Approve of)
property if on an insert or delete of a tuple, the delta on $q[\vec{a}]$, for
any $\vec{a}$, can be expressed as a fixed sum
$q_1[\vec{a}] + \dots + q_k[\vec{a}]$ such that each map $q_i[\cdot]$ has the YMCA
property and $q_i \prec q$.
\end{definition}


Here, $\prec$ denotes the following general-to-specific ordering on map expressions.


\begin{definition}\em
A singleton relation is a relation with one tuple, e.g.\ $\{\vec{a}\}$.
A map $q$ is called (strictly) {\em more specific than}\/ a map $q'$,
denoted $q \prec q'$, if $q$ can be obtained from $q'$ by replacing
one or more relation names occurring in $q$ by fixed singleton relations.
\end{definition}


Obviously, a YMCA compilation scheme yields effective incremental view maintenance:
The delta to any map can be computed by a fixed sum of simpler maps,
the deltas of which again can be computed by fixed sums of even simpler maps,
and this recursively until we reach maps in which all relations are constant and
the maps can be reformulated as a simple arithmetic expressions over their
arguments.



\begin{theorem}
There is a YMCA compilation scheme for map algebra.
\end{theorem}


Proof.
Let $q[\vec{x}]$ be of the form
$
\algsumf_f(Q)[\vec{x}]
$
where $Q$ is relational algebra parameterized by $\vec{x}$ and let $R$ be
a relation name occurring in $Q$ (in the relational algebra expression
rather than just in a nested map algebra expression).
Assume that there are $r$ occurrences of $R$ in $Q$. Then
the updated version of $q[\vec{x}]$ can be expressed by the sum of the $2^r$
maps obtainable by, for each occurrence of $R$ in $Q$, either replacing it
by $\{ \vec{x} \}$ or leaving it unchanged.

This follows immediately from the fact that the new version of $R$ on insertion of
tuple $\vec{x}$ is $R \cup \{ \vec{x} \}$ and, $\cup$ commutes with
the operations of positive relational algebra and thus can be pushed to the top
level of $Q$, and
\[
\algsumf_f(Q_1 \cup Q_2)[\vec{x}] =
\algsumf_f(Q_1)[\vec{x}] + \algsumf_f(Q_2)[\vec{x}].
\]
By pushing the unions obtained by rewriting $R$ to $R \cup \{\vec{x}\}$ to the
top level of $Q$ everywhere and then splitting the map into a sum of maps, we obtain
one map expression that is precisely $q[\cdot]$ (i.e., corresponds to the old
value of $q$).

The one additional case is relational algebra expressions of the form
\[
\algsumf_f(\sigma_{m[\vec{x}] + \Delta m[\vec{x}] > 0}(Q))[\cdot]
\]
which can be rephrased as
\begin{multline*}
\algsumf_f(\sigma_{m[\vec{x}] > 0}(Q))[\vec{x}]
\\
+ \;
\big( \mbox{if ($(m[\vec{x}] > 0) \neq (m[\vec{x}] + \Delta m[\vec{x}] > 0))$ then}
\\
      \mbox{$\mbox{sgn}(m[\vec{x}] + \Delta m[\vec{x}]) *
      \algsumf_f(Q)[\vec{x}]$ else 0} \big)
\end{multline*}
\punto



\begin{todo}
Make a clean induction proof.

Give an algorithm separately from the proof.
\end{todo}



\begin{example}\em
Let us now compute the trigger
\[
\mbox{on insert into B values ($p, v$)}
\]
for the VWAP query $q[]$.
If we replace $B$ by $B \cup \{\tuple{p, v}\}$ everywhere
%
%and use the equivalences
%$\pi_{\vec{A}}(R \cup S) = \pi_{\vec{A}}(R) \cup \pi_{\vec{A}}(S)$ and
%$\algsumf_f(R \cup S)[\vec{x}] =
%\algsumf_f(R)[\vec{x}] + \algsumf_f(S)[\vec{x}]$,
we obtain that $q[]$ should be incremented by
%
\begin{eqnarray*}
\Delta q[] &=&
\sum_{p_2}
\big( \mbox{if ($(m[p_2] > 0) \neq (m[p_2] + \Delta m[p_2] > 0))$ then}
\\
&& ~~~
      \mbox{$\mbox{sgn}(m[p_2] + \Delta m[p_2]) *
      \underbrace{\algsumf_{P_2 * V_2}(\sigma_{P_2=p_2}(\rho_{P_2,V_2}(B)))[p_2]}_{s[p_2]}$ else 0} \big)
\\
%&+& \algsumf_{p_2 * v_2}(\sigma_{m[p_2] + \Delta m[p_2] > 0}(
%\rho_{P_2, V_2}(\{\tuple{p_2,v_2}\})))[]
%\\
&+&
\big( \mbox{if $(m[p] + \Delta m[p] > 0)$ then $p * v$ else $0$} \big)
\end{eqnarray*}

The increments for $m[P_2]$ and $s[P_2]$
on insertion of tuple $\tuple{p,v}$ into $B$ are
analogously
\begin{eqnarray*}
\Delta m[p_2] &:=&
k * \algsumf_{V_0}(\rho_{P_0, V_0}(\{\tuple{p, v}\}))[] -
\algsumf_{V_1}(\sigma_{P_1 > p_2}(\rho_{P_1, V_1}\{\tuple{p, v}\})))[p_2]
\\
&=& k * v - (\mbox{if $(p > p_2)$ then $v$ else $0$)}
\\
&& (\mbox{for each $p_2$})
\\[1.5ex]
\Delta s[p_2] &:=& \mbox{if $(p = p_2)$ then v else 0}.
\end{eqnarray*}

Thus we generate the following code:
\begin{verbatim}
on insert into B values (p, v)
{
  if(! dom_m.member(p)) { dom_m.add(p); m[p] = 0; }

  delta q = (m[p] > 0) ? (p * v) : 0;

  foreach p_2 in dom_m do
  {
     delta m[p_2] = k * v - ((p > p_2) ? v : 0);
     delta s[p_2] = (p = p_2) ? v : 0;
     delta q += ((m[p_2] > 0) != (m[p_2] + delta m[p_2] > 0)) ?
        sgn(m[p_2] + delta m[p_2]) * (s[p_2] + delta s[p_2]) : 0;
  }

  increment the maps by their deltas;
}
\end{verbatim}


It makes sense to avoid naive looping over all values $p_2$ by maintaining
$m_1[p_2]$ as a range data structure (to be described).
\punto
\end{example}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Old Stuff}






\begin{figure*}
\begin{eqnarray}
\rho_{\vec{A}\vec{B}}(R) \bowtie \rho_{\vec{A}\vec{C}}(\{ \tuple{\vec{a}\vec{c}} \})
&\vdash&
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{B}}(R)) \times \rho_{\vec{C}}(\{ \vec{c} \})
\label{r1}
\\
\pi_{\vec{A}}(\rho_{\vec{A}}(R) \times \rho_{\vec{B}}(\{ \vec{b} \}))
&\vdash&
\rho_{\vec{A}}(R)
\label{r2}
\\
\rho_{\vec{A}}(\{\vec{a}\}) \times \rho_{\vec{B}}(R)
&\vdash&
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}}(\{\vec{a}\}) \times \rho_{\vec{B}}(R))
\label{r3}
\\
\algagg_{f(\vec{A},\vec{B})}(\sigma_{\vec{A}=\vec{a}}(R))
&\vdash&
\algagg_{f(\vec{a},\vec{B})}(\pi_{\vec{B}}(R))
\label{r4}
\\
\algagg_{f(\vec{A})}(\rho_{\vec{A}}(R) \times \rho_{\vec{B}}(\{\vec{b}\}))
&\vdash&
\algagg_{f(\vec{A})}(\rho_{\vec{A}}(R))
\label{r5}
\\
\algsum_{f(\vec{A}) * g(\vec{B})}(\rho_{\vec{A}}(R) \times \rho_{\vec{B}}(S))
&\vdash&
\algsum_{f(\vec{A})}(\rho_{\vec{A}}(R)) *
\algsum_{g(\vec{B})}(\rho_{\vec{B}}(S))
\label{r6}
\\
\algsum_{a *
f(\cdot)}(R) &\vdash& a * \algsum_{f(\cdot)}(R)
\label{r7}
\\
\algsum_{f(\cdot) + g(\cdot)}(R)
&\vdash&
\algsum_{f(\cdot)}(R) + \algsum_{g(\cdot)}(R)
\label{r8}
\\
\max_{a + f(\cdot)}(R)
&\vdash&
a + \max_{f(\cdot)}(R)
\label{r9}
\\
\max_{f(\vec{A}) + g(\vec{B})}(\rho_{\vec{A}}(R) \times \rho_{\vec{B}}(S))
&\vdash&
\max_{f(\vec{A})}(\rho_{\vec{A}}(R)) +
\max_{g(\vec{B})}(\rho_{\vec{B}}(S))
\label{r10}
\\
\max_{a * f(\vec{B})}(\rho_{\vec{B}}(R))
&\vdash&
\left\{
\begin{array}{lll}
a * \min_{f(\vec{B})}(\rho_{\vec{B}}(R)) & \dots & a < 0 \\
a * \max_{f(\vec{B})}(\rho_{\vec{B}}(R)) & \dots & a \geq 0
\end{array}
\right.
\label{r11}
\\
\max_{f(\vec{A}) * g(\vec{B})}(\rho_{\vec{A}}(R) \times \rho_{\vec{B}}(S))
&\vdash&
\max\Big\{
\max_{f(\vec{A})}(\sigma_{f(\vec{A}) \ge 0}(\rho_{\vec{A}}(R))) *
\max_{g(\vec{B})}(\rho_{\vec{B}}(S)),
\nonumber\\
&& \quad\quad\;\;\,
\max_{f(\vec{A})}(\underbrace{\sigma_{f(\vec{A}) < 0}}_{\mathrm{optional}}(\rho_{\vec{A}}(R))) *
\max_{g(\vec{B})}(\sigma_{f(\vec{B}) \ge 0}(\rho_{\vec{B}}(S))),
\nonumber\\
&& \quad\quad\;\;\,
\min_{f(\vec{A})}(\sigma_{f(\vec{A}) < 0}(\rho_{\vec{A}}(R))) *
\min_{g(\vec{B})}(\sigma_{f(\vec{B}) < 0}(\rho_{\vec{B}}(S)))
\Big\}
\label{r12}
\\
\max_a(R)
&\vdash&
\left\{
\begin{array}{lll}
a       & \dots & \algsum_1(R) > 0 \\
-\infty & \dots & \algsum_1(R) = 0 \\
\end{array}
\right.
\label{r13}
\end{eqnarray}

\caption{Rewrite rules. agg can be either sum, max, or min.
count is sum$_1$.}
\label{fig:rules}
\end{figure*}



\begin{figure*}
\begin{eqnarray}
\algsum_{f(\cdot)}(R - S)
& \vdash &
\algsum_{f(\cdot)}(R) -
\algsum_{f(\cdot)}(S) \quad \dots \quad S \subseteq R
\label{r20}
\\
\max_{f(\cdot)}(R - S)
& \vdash &
\left\{\begin{array}{lll}
\max_{f(\cdot)}(R) & \dots & (S \cap R = \emptyset) \vee \\
& &  (\max_{f(\cdot)}(R) \neq
\max_{f(\cdot)}(S \cap R)) \\
\max_{f(\cdot)}(R
- S) & \dots &  \max_{f(\cdot)}(R) = \max_{f(\cdot)}(S \cap R) \\
\end{array}\right.
\label{r21}
\\
\rho_{\vec{A}\vec{B}}(R) \bowtie \rho_{\vec{A}\vec{C}}(S)
& \vdash &
\bigcup_{\vec{a}}
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{B}}(R))
\times \sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{C}}(S))
\label{r23}
\\
\max_{f(\vec{A},\vec{B},\vec{C})} \Big\{
\bigcup_{\vec{a}}
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{B}}(R)) \times
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{C}}(S)) \Big\}
& \vdash &
\max_{f(\vec{A},\vec{B},\vec{C})}\Big\{
\bigcup_{\vec{a}} \max_{f(\vec{a},\vec{B},\vec{C})}
(\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{B}}(R)) \times
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{C}}(S))) 
\Big\}
\label{r24}
\end{eqnarray}
\caption{Rewrite rules for handling deletions. Note that deletion rewrites use
both this rule set and the rewrite rules above for insertions.}
\label{fig:deleterules}
\end{figure*}





\nop{
\begin{figure*}
\begin{eqnarray}
\mathop{\algtopk}_{a+f(\cdot)}(R)
&\vdash&
\pi_{a+f(\cdot)}(\{\tuple{a}\} \times
\mathop{\algtopk}_{f(\cdot)}(R))
\label{r14}
\\
\mathop{\algtopk}_{f(\vec{A}) + g(\vec{B})}(\rho_{\vec{A}}(R) \times
\rho_{\vec{B}}(S))
&\vdash&
\mathop{\algtopk}(\pi_{f(\vec{A}) + g(\vec{B})}(
\mathop{\algtopk}_{f(\vec{A})}(\rho_{\vec{A}}(R))
\times \mathop{\algtopk}_{g(\vec{B})}(\rho_{\vec{B}}(S))))
\label{r15}
\\
\mathop{\algtopk}_{a * f(\vec{B})}(\rho_{\vec{B}}(R))
&\vdash&
\left\{
\begin{array}{lll}
\pi_{-a*-f(\vec{B})}( \{\tuple{a}\} \times
\mathop{\algtopk}_{-f(\vec{B})}(\rho_{\vec{B}}(R))) &
\dots & a < 0 \\
\pi_{a*f(\vec{B})}( \{\tuple{a}\} \times 
\mathop{\algtopk}_{f(\vec{B})}(\rho_{\vec{B}}(R))) & \dots & a \geq 0
\end{array}
\right.
\label{r16}
\\
\mathop{\algtopk}_{f(\vec{A}) * g(\vec{B})}(\rho_{\vec{A}}(R)
\times \rho_{\vec{B}}(S))
&\vdash&
\mathop{\algtopk} \Big\{
\pi_{f(\vec{A}) * g(\vec{B})}(
\mathop{\algtopk}_{f(\vec{A})}(
\sigma_{f(\vec{A}) > 0}(\rho_{\vec{A}}(R))) \times
\mathop{\algtopk}_{g(\vec{B})}(\rho_{\vec{B}}(S))),
\nonumber\\
& &
\pi_{f(\vec{A}) * g(\vec{B})}(
\mathop{\algtopk}_{f(\vec{A})}
(\rho_{\vec{A}}(R)) \times
\mathop{\algtopk}_{g(\vec{B})}
(\sigma_{g(\vec{B}) > 0}(\rho_{\vec{B}}(S))))
\nonumber\\
& &
\pi_{-f(\vec{A}) * -g(\vec{B})}(
\mathop{\algtopk}_{-f(\vec{A})}
(\sigma_{f(\vec{A}) < 0}(\rho_{\vec{A}}(R))) \times
\mathop{\algtopk}_{-g(\vec{B})}
(\sigma_{g(\vec{B}) < 0}(\rho_{\vec{B}}(S))))
\Big\}
\label{r17}
\\
\mathop{\algtopk}_{a}(R)
&\vdash&
\left\{\begin{array}{lll}
\{\underbrace{\tuple{a}, \dots, \tuple{a}}_{k \; \mathrm{times}}\} & \dots & \algsum_{1}(R) > k\\
\{\underbrace{\tuple{a}, \dots, \tuple{a}}_{\algsum_{1}(R) \; \mathrm{times}}\}
\cup \{\tuple{-\infty}\}^{k-\algsum_{1}(R)}
& \dots & \algsum_{1}(R) < k
\end{array}\right.
\label{r18}
\\
\mathop{\algtopk}_{f(\cdot)}(\rho_{\vec{A}}(R) - \rho_{\vec{B}}(S))
& \vdash &
\left\{\begin{array}{lll}
\algtopk_{f(\cdot)}(R) &
\dots & (S \cap R = \emptyset) \vee\\
& & (\algtopk_{f(\cdot)}(R) \cap 
\algtopk_{f(\cdot)}(S \cap R) = \emptyset)\\
\algtopk_{f(\cdot)}(R - S)
& \dots &
\algtopk_{f(\cdot)}(R) \cap
\algtopk_{f(\cdot)}(S \cap R) \neq \emptyset
\end{array}\right.
\label{r22}
\end{eqnarray}
\begin{eqnarray}
\mathop{\algtopk}_{f(\vec{A},\vec{B},\vec{C})} \Big\{
\bigcup_{\vec{a}}
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{B}}(R)) \times
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{C}}(S)) \Big\}
& \vdash &
\mathop{\algtopk}_{f(\vec{A},\vec{B},\vec{C})}\Big\{
\bigcup_{\vec{a}} \mathop{\algtopk}_{f(\vec{a},\vec{B},\vec{C})}
(\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{B}}(R)) \times
\sigma_{\vec{A}=\vec{a}}(\rho_{\vec{A}\vec{C}}(S))) 
\Big\}
\label{r25}
\end{eqnarray}
\caption{Rewrite rules for top-k.}
\end{figure*}
} % end nop







In this section, an expression of the form
\[
\algagg_f(\sigma_{\vec{A}=\vec{a}}(Q))[\vec{a}]
\]
is a map for an aggregate-group by query
\[
\mbox{select $\vec{A}$, agg($f$)
from $Q$
group by $\vec{A}$}.
\]
Given a group $\vec{a}$, the map returns
the aggregate value
$\algagg_f(\sigma_{\vec{A}=\vec{a}}(Q))$ for it.
An aggregate $\algagg$ (either sum, max, or min) returns exactly
one value -- the aggregate value.

The main rewrite step is the following.
We exploit the fact that for our aggregate functions $\algagg$,
\begin{multline*}
\algagg_f(\sigma_{\vec{A}=\vec{a}}(Q \cup \Delta Q))[\vec{a}]
= \\
\algagg(\algagg_f(\sigma_{\vec{A}=\vec{a}}(Q))[\vec{a}],
\algagg_f(\sigma_{\vec{A}=\vec{a}}(\Delta Q))[\vec{a}]).
\end{multline*}


Consider an aggregate-group by query
\[
\algagg_{f(\vec{a}, \vec{B}, \vec{C}, \vec{D})}
(\sigma_{\vec{A}=\vec{a}}(R_1 \bowtie \dots \bowtie R_k))[\vec{a}]
\]
where the schema of $R_1 \bowtie \dots \bowtie R_{k-1}$ is
$\vec{A}\vec{B}\vec{C}$ and the schema of
$R_k$ is $\vec{C}\vec{D}$.

W.l.o.g., we consider the case of an insertion of tuple
$\tuple{\vec{c},\vec{d}}$ into relation $R_k$.

We rewrite
$
\algagg_f(\sigma_{\vec{A}=\vec{a}}(\Delta Q))[\vec{a}]
$, that is,
\[
\algagg_{f(\vec{a}, \vec{B}, \vec{C}, \vec{D})}
(\sigma_{\vec{A}=\vec{a}}(R_1 \bowtie \dots \bowtie R_{k-1} \bowtie \{\tuple{\vec{c}\vec{d}}\}))[\vec{a}]
\]
to
\begin{equation}
\algagg_{f(\vec{a}, \vec{B}, \vec{c}, \vec{d})}
(\sigma_{\vec{A}\vec{C}=\vec{a}\vec{c}}(R_1 \bowtie \dots \bowtie R_{k-1}))[\vec{a}\vec{c}\vec{d}].
\label{eq:1}
\end{equation}

Figure~\ref{fig:rules} provides a set of rewrite rules, of which rules
\ref{r1}, \ref{r2}, \ref{r3}, and \ref{r4} are sufficient to  perform this
rewriting.

Since we would like the maps that have to be maintained to be as simple as
possible, we will try to express Equation~\ref{eq:1} in terms of 
aggregates
\begin{equation}
\algagg_{f'(\vec{a}, \vec{B}, \vec{c})}
(\sigma_{\vec{A}\vec{C}=\vec{a}\vec{c}}(R_1 \bowtie \dots \bowtie R_{k-1}))[\vec{a}\vec{c}]
\label{eq:2}
\end{equation}
which do not use $\vec{d}$.

In most cases
this is possible using the rewrite rules of Figure~\ref{fig:rules}.
Assuming that $f$ is an arithmetic expression built using addition and multiplication (and constants which may be negative), we can turn $f$ into an equivalent
expression that is a sum of products (by exploiting distributivity).

Let the aggregate be sum. In that case the rewriting of Equation~\ref{eq:1}
so as to eliminate the constants $\vec{d}$
is always possible using the rules \ref{r7} and \ref{r8}.
In the case of max, the rewriting is usually possible. The simplest case
where it is not is $f = B_1 * d + B_2$.


\begin{proposition}
To do: Formalize this fact.
\end{proposition}


Note that our rewriting has removed relation $R_k$ from the query to be
incrementally maintained. Inductively, we can solve the incremental maintenance
problem by just maintaining the maps constructed using this rewriting.


\begin{example}\em
Given schema $R(A,B)$, $S(B,C)$, $T(C,D)$.
We incrementally maintain the aggregate query
\[
s := \algsum_{A*D}(R \bowtie S \bowtie T).
\]
\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T)
\\ &\stackrel{\ref{r1}}{=}&
\algsum_{A*D}(\{a\} \times \sigma_{B=b}(S) \bowtie T)
\\ &\stackrel{\ref{r3},\ref{r4},\ref{r2}}{=}&
\algsum_{a*D}(\sigma_{B=b}(S) \bowtie T)
\\ &\stackrel{\ref{r7}}{=}&
a * \underbrace{\algsum_{D}(\sigma_{B=b}(S) \bowtie T)}_{s_D[b]}
\end{eqnarray*}

\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie \{\tuple{b,c}\} \bowtie T)
\\ &\stackrel{\ref{r1}*}{=}&
\algsum_{A*D}(\sigma_{B=b}(R) \times \sigma_{C=c}(T))
\\ &\stackrel{\ref{r6}}{=}&
\underbrace{\algsum_{A}(\sigma_{B=b}(R))}_{s_A[b]} *
\underbrace{\algsum_{D}(\sigma_{C=c}(T))}_{s_D[c]}
\end{eqnarray*}

\item
Insert T(c,d): (analogous to insertion of R(a,b))
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie S \bowtie \{\tuple{c,d}\})
\\ &=&
\underbrace{\algsum_{A}(R \bowtie \sigma_{C=c}(S))}_{s_A[c]} * d
\end{eqnarray*}
\end{itemize}

We incrementally maintain $s_D[b]$, $s_A[b]$, $s_D[c]$, and
$s_A[c]$ as well.

\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s_A[b] &=& \algsum_{A}(\{\tuple{a,b}\}) = a
\\
\mbox{foreach $c$: }
\Delta s_A[c] &=& \algsum_{A}(\{\tuple{a,b}\} \bowtie \sigma_{C=c}(S))
\\ &\stackrel{\ref{r1},\ref{r3},\ref{r4},\ref{r2}}{=}&
\algsum_{a}(\sigma_{BC=bc}(S))
\\ &\stackrel{\ref{r7}}{=}&
a * \underbrace{\algsum_{1}(\sigma_{BC=bc}(S))}_{s_1[b,c]}
\end{eqnarray*}

(Analogously insert T(c,d) for maintaining $s_{D}[b], s_{D}[c]$.)

\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s_A[c] &=&
\algsum_{A}(R \bowtie \{\tuple{b,c}\})
\\ &\stackrel{\ref{r1}}{=}&
\algsum_{A}(\sigma_{B=b}(R) \times \{c\})
\\ &\stackrel{\ref{r5},\ref{r2}}{=}&
\algsum_{A}(\sigma_{B=b}(R))
\;=:\; s_A[b]
\\
\Delta s_D[b] &=&
\algsum_{D}(\{\tuple{b,c}\} \bowtie T)
\\ &\stackrel{\ref{r1}}{=}&
\algsum_{D}(\{b\} \times \sigma_{C=c}(T))
\\ &\stackrel{\ref{r5},\ref{r2}}{=}&
\algsum_{D}(\sigma_{C=c}(T))
\;=:\; s_D[c]
\end{eqnarray*}
\end{itemize}

Finally, we want to incrementally maintain $s_1[b,c]$:
\begin{itemize}
\item
Insert S(b,c):
\[
\Delta s_1[b,c] =
\algsum_{1}(\{\tuple{b,c}\}) = 1
\]
\end{itemize}

Thus the code is:
\begin{verbatim}
on insert into R values (a,b)
{
   s += a * s_D[b];
   s_A[b] += a;
   foreach c (in Cs[b]) do
      s_A[c] += a * s_1[b,c];
}

on insert into S values (b,c)
{
   s += s_A[b] * s_D[c];
   s_A[c] += s_A[b];
   s_D[b] += s_D[c];
   s_1[b,c] += 1;
}

on insert into T values (c,d)
{
   s += s_A[c] * d;
   s_D[c] += d;
   foreach b (in Bs[c]) do
      s_D[b] += s_1[b,c] * d;
}
\end{verbatim}
\punto

We can also consider deletions to base relations:

\begin{itemize}
\item
Delete R(a,b):
\begin{eqnarray*}
\algsum &=& \algsum_{A*D}((R-\{\tuple{a,b}\}) \bowtie S \bowtie T)\\
&=& \algsum_{A*D}((R \bowtie S \bowtie T) -
(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& \algsum_{A*D}(R \bowtie S \bowtie T) -\\
& & \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& \algsum' - \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
%\because
\Delta s &=&  - \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& -a*\algsum_{D}(\sigma_{B=b}(S) \bowtie T)
\end{eqnarray*} 
\end{itemize}

(Similarly for Delete S(b,c) and Delete T(c,d)).

Just as in the case for Inserts, we must also maintain an additional data
structures needed by each delta handler, for example $s_{A}[c], s_{A}[b]$ needed
to dealing with deletions to relations S and C. Note that given subtraction is an
inverse operation for addition (hence $\algsum$) and is anticommutative with the
previous result as seen above, the maintenance we perform is
structurally identical to the case for inserts. 

\begin{itemize}
\item
Delete R(a,b):
\begin{eqnarray*}
\Delta s_{A}[b] &=& - \algsum_{A}(\{\tuple{a,b}\}) = -a\\
\Delta s_{A}[c] &=& -a * \algsum_{1}(\sigma_{BC=bc}(S))
\end{eqnarray*}
\end{itemize}
\end{example}


\begin{example}\em
Consider the same query as above where sum is replaced by max,
\[
m := \max_{A*D}(R \bowtie S \bowtie T).
\]

On insert into R values $(a,b)$: $m := \max(m, m')$ where
\begin{eqnarray*}
m' &=&
\max_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T)
\\
&\stackrel{\ref{r1},\ref{r3},\ref{r4},\ref{r2}}{=}&
\max_{a*D}(\sigma_{B=b}(S) \bowtie T)
\\
&\stackrel{\ref{r10}}{=}&
\left\{
\begin{array}{lll}
a * \min_{D}(\sigma_{B=b}(S) \bowtie T) & \dots & a < 0 \\
a * \max_{D}(\sigma_{B=b}(S) \bowtie T) & \dots & a \ge 0
\end{array}
\right.
\end{eqnarray*}

For the incremental maintenance of $S$ and $T$, we have to maintain
$\min_A[b] = \min_A(\sigma_{B=b}(R))$,
$\max_A[b] = \max_A(\sigma_{B=b}(R))$,
$\min_A[c] = \min_A(R \bowtie \sigma_{C=c}(S))$ and
$\max_A[c] = \max_A(R \bowtie \sigma_{C=c}(S))$.
For instance,
$\max_A[c] := \max(\max_A[c], \max_A'[c])$
where
\begin{eqnarray*}
\max_A[c] &=&
\max(\max_A[c], \max_A(\{\tuple{a,b}\} \bowtie \sigma_{C=c}(S)))
\\
&\stackrel{\ref{r1},\ref{r3},\ref{r4},\ref{r2}}{=}&
\max(\max_A[c], \max_a(\sigma_{BC=bc}(S)))
\\
&\stackrel{\ref{r12}}{=}&
\left\{
\begin{array}{lll}
\max(\max_A[c], a) & \dots & s_1[b,c] > 0 \\
\max_A[c]          & \dots & s_1[b,c] = 0
\end{array}
\right.
\end{eqnarray*}
where we incrementally maintain
$s_1[b,c] = \algsum_1(\sigma_{BC=bc}(S))$.

Thus the code for maintaining the datastructures on an insert of $R(a,b)$ is
\begin{verbatim}
m = max(m, ((a<0) ? min_D[b] : max_D[b]));
max_A[b] = max(max_A[b], a);
min_A[b] = min(min_A[b], a);
if (s_1[b,c] > 0)
{
   max_A[c] =  max(max_A[c], a);
   min_A[c] =  min(min_A[c], a);
}
\end{verbatim}
\punto
\end{example}

\newcommand{\compile}{\ensuremath{\mbox{\sc Compile}}}
\newcommand{\generate}{\ensuremath{\mbox{\sc Generate}}}
\newcommand{\rewrite}{\ensuremath{\mbox{\sc Rewrite}}}
\newcommand{\substitute}{\ensuremath{\mbox{\sc Substitute}}}
\newcommand{\match}{\ensuremath{\mbox{\sc Match}}}


\def\RETURN{\STATE}


\begin{algorithm}
\caption{$\compile(Q)$}
\label{alg:compile}
\begin{codebox}
\zi \Comment{Inputs: a query $Q$}
\zi \Comment{Outputs: a toasted database $\lambda_{DB}$}
\zi \Comment{Definitions: }
\zi \>$\mathcal{B}$: input tables used by $Q$.
\zi \>$(Q)[]$: initial map (yields query result).
\end{codebox}
\begin{algorithmic}[1]
\STATE $Targets \leftarrow \{\tuple{(Q)[],\mathcal{B}}\}$
\STATE $Kernels \leftarrow \{\}$
\STATE $Maps \leftarrow \{\}$
\WHILE{ $|T| > 0$ }
	\STATE $\tuple{M,\mathcal{R}} \leftarrow next(T)$
	\IF {$|R| = 1$}
		\STATE $Kernel[R] \cup \generate(M,R)$
	\ELSE
		\FOR{$R \in \mathcal{R}$}
			\STATE $\tuple{\{M'\}, \lambda_R} \leftarrow \rewrite(M,R)$
			\STATE $Kernel[R] \leftarrow Kernel[R] \cup \lambda_R$
			\STATE $Targets \leftarrow Targets \cup \{\tuple{M',\mathcal{R}-R}\}$
		\ENDFOR
	\ENDIF
\ENDWHILE
\STATE $\lambda_{DB} \leftarrow \lambda(\Delta).$\\
$\qquad \mbox{\sc Declare}(Maps)\mbox{; \sc
DispatchLoop}(\Delta, Kernel)$
\RETURN $\lambda_{DB}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{$\rewrite(M,R)$}
\label{alg:rewrite}
\begin{codebox}
\zi \Comment{Inputs:}
\zi \> a map $M$, and a relation to consider for updates, $R$.
\zi \Comment{Outputs:}
\zi \> a new set of maps $\mathcal{M'}$, and a function $\lambda_R$ s.t.
\zi \>\> $\Delta M = \lambda_R(\Delta R,\mathcal{M'})$
\zi \Comment{Description:}
\zi	\> Performs bottom-up rewriting according to
Figures~\ref{fig:rules},\ref{fig:maprules}.
\end{codebox}
\begin{algorithmic}[1]
\REQUIRE{A map $M$, and a relation, $R$, to update the map.}
\smallskip
\STATE $M \leftarrow \substitute(M,R,\tuple{r_i})$
\STATE $S \leftarrow inputs(M)$
\STATE $parents \leftarrow plan(M)$
\STATE $maps \leftarrow \{\}$
\STATE $rewrite \leftarrow \{\}$
\WHILE{ $|S| > 0$ }
	\STATE $E_{c} \leftarrow pop(S)$
	\STATE $E \leftarrow parents[E_{c}]$
	\STATE $\tuple{matched,E',M'} \leftarrow \match(E,maps[children(E)])$
	\IF {$matched$}
		\STATE $S \leftarrow (S - descendants(E)) \cup parent[E]$
		\STATE $maps[E'] \leftarrow M'$
		\STATE $rewrite \leftarrow rewrite \cup (E',children(E',rewrite))$
	\ELSE
		\STATE $rewrite \leftarrow rewrite \cup (E',children(E,rewrite))$
	\ENDIF
\ENDWHILE
\STATE $root \leftarrow$ $\mbox{\sc Root}(rewrite)$
\STATE $\mathcal{M'} \leftarrow \mbox{\sc NearestMaps}(root)$
\STATE $\lambda_R \leftarrow \lambda(\Delta R).\mbox{\sc Apply}(root,\mathcal{M'})$
\RETURN $\tuple{\lambda_R,\mathcal{M'}}$
\end{algorithmic}
%%
%% Old version
\comment{
\begin{algorithmic}[1]
\REQUIRE{A map $M$, and a relation, $R$, to update the map.}
\smallskip
\STATE $M \leftarrow substitute(M,R,\tuple{r_i})$
\STATE $S \leftarrow \{M\}$
\STATE $parent \leftarrow \{\}$
\WHILE{ $!fixpoint(S)$ }
	\STATE $E \leftarrow pop(S)$
	\STATE $\tuple{matched,E'} \leftarrow match(E)$
	\IF {$matched \wedge parent[E]$}
		\STATE $S \leftarrow S \cup parent[E]$
		\STATE $parent \leftarrow parent - E$
		\STATE $S \leftarrow S \cup children(E')$
	\ELSE
		\STATE $parent[E] \leftarrow children(E)$
		\STATE $S \leftarrow S \cup children(E)$
	\ENDIF
\ENDWHILE
\end{algorithmic}
}
\end{algorithm}

\subsection{Structural Query Decomposition}


The examples of the previous section have demonstrated how the rewrite
rules of Figure~\ref{fig:rules} can be used to decompose a complex
aggregate into smaller parts. For example,
we were able to decompose
\[
\Delta s = \algsum_{A*D}(R \bowtie S \bowtie T)
\]
on the insertion of $S(b,c)$ into
\[
\algsum_{A}(\sigma_{B=b}(R)) * \algsum_D(\sigma_{C=c}(T)).
\]

This decomposition was easy to find because the query was
very simple. For complex queries, we need some way of understanding the
join structure of the query to find good decomposition. The natural tool
for this are hypertree decompositions.


\begin{example}\em
The schema is
$R_1\{A,B,C\}$, $R_2\{B,D,E\}$, $R_3\{C,F,G\}$, $R_4\{F,H\}$,  $R_5\{G,I,J\}$,
and $R_6\{I,J,K,L\}$ and
the query is
\[
s := \algsum_{A*L}(\sigma_{HK=hk}(R_1 \bowtie \dots \bowtie R_6))[h,k].
\]
This query maliciously asks for tuples to be grouped by columns $H$ and $K$,
which are quite distant in the query's hypergraph. 

Let us insert tuple $R_1(a,b,c)$.
This is an acyclic query. This is a hypertree decomposition with $R_1$ as
the root node:
\[
\psset{levelsep=12mm}
\pstree{\TR{\framebox{$R_1\{A,B,C\}$}}}
{
   \TR{\framebox{$R_2\{B,D,E\}$}}^B
   \pstree{\TR{\framebox{$R_3\{C,F,G\}$}}_{C; [H,K]}}
   {
      \TR{\framebox{$R_4\{F,H\}$}}^{F; [H]}
      \pstree{\TR{\framebox{$R_5\{G,I,J\}$}}_{G; [K]}}
      {
         \TR{\framebox{$R_6\{I,J,K,L\}$}}_{I,J; [K]}
      }
   }
}
\]


The edges are annotated with the columns that have to be passed between the nodes.
Now
\begin{eqnarray*}
\Delta s &=&
\algsum_{A*L}(\sigma_{HK=hk}(\{a,b,c\} \bowtie R_2 \bowtie \dots \bowtie R_6))[\cdot]
\\
&=&
a * \algsum_{L}(\sigma_{BCHK=bchk}(R_2 \bowtie \dots \bowtie R_6))[\cdot]
\\
&=&
a * \algsum_{L}(\sigma_{B=b}(R_2) \times \sigma_{CHK=chk}(R_3 \bowtie \dots \bowtie R_6))[\cdot]
\\
&=&
a * 
\algsum_1(\sigma_{B=b}(R_2))[b] \\
&*& 
\algsum_L(\sigma_{CHK=chk}(R_3 \bowtie R_4 \bowtie R_5 \bowtie R_6))[c,h,k].
\end{eqnarray*}

If we want to insert into $R_3$, we reroot the hypertree decomposition
\[
\psset{levelsep=12mm}
\pstree{\TR{\framebox{$R_3\{C,F,G\}$}}}
{
   \pstree{\TR{\framebox{$R_1\{A,B,C\}$}}^C}
   {
      \TR{\framebox{$R_2\{B,D,E\}$}}^B
   }
   \TR{\framebox{$R_4\{F,H\}$}}^{F; [H]}
   \pstree{\TR{\framebox{$R_5\{G,I,J\}$}}_{G; [K]}}
   {
      \TR{\framebox{$R_6\{I,J,K,L\}$}}_{I,J; [K]}
   }
}
\]

and rewrite as follows:
\begin{eqnarray*}
\Delta s &=&
\algsum_{A*L}(\sigma_{HK=hk}(R_1 \bowtie R_2 \bowtie \{c,f,g\}
\\
&& \quad \bowtie R_4 \bowtie R_5 \bowtie R_6))[\cdot]
\\
&=&
\algsum_{A*L}(\sigma_{C=c}(R_1 \bowtie R_2) \times \sigma_{FH=fh}(R_4)
\\
&& \quad
\times \sigma_{GK=gk}(R_5 \bowtie R_6))[\cdot]
\\
&=&
\algsum_{A}(\sigma_{C=c}(R_1 \bowtie R_2))[c]
\\
&*& \algsum_{1}(\sigma_{FH=fh}(R_4))[fh]
\\
&*& \algsum_L(\sigma_{GK=gk}(R_5 \bowtie R_6))[gk]
\end{eqnarray*}
\punto
\end{example}


\begin{example}\em
If the query is acyclic, nothing really changes.
Consider the previous query where the schema of $R_5$ is now
$\{E,G,I,J\}$ (thus the query becomes cyclic).

The following is a hypertree decomposition rooted at $R_3$:
\[
\psset{levelsep=12mm}
\pstree{\TR{\framebox{$R_3\{C,F,G\}$}}}
{
   \TR{\framebox{$R_4\{F,H\}$}}^{F; [H]}
   \pstree{\TR{\framebox{$R_1\{A,B,C\}, R_5\{E,G,I,J\}$}}_{C,G; [K]}}
   {
      \TR{\framebox{$R_2\{B,D,E\}$}}^{B,E}
      \TR{\framebox{$R_6\{I,J,K,L\}$}}_{I,J; [K]}
   }
}
\]

Thus $\Delta s$ for the insertion of $R_3(c,f,g)$ is
\begin{eqnarray*}
\Delta s &=&
\algsum_{A*L}(\sigma_{HK=hk}(R_1 \bowtie R_2 \bowtie \{c,f,g\}
\\
&& \quad \bowtie R_4 \bowtie R_5 \bowtie R_6))[\cdot]
\\
&=&
\algsum_{1}(\sigma_{FH=fh}(R_4))[fh]
\\
&*& 
\underbrace{\algsum_{A*L}(\sigma_{CGK=cgk}(R_1 \bowtie R_2 \bowtie R_5 \bowtie R_6))[cgk]}_{s_{A*L}[cgk]}
\end{eqnarray*}

On insertion of $R_5(e,g,i,j)$,
\begin{eqnarray*}
\Delta s_{A*L}[cgk]
&=&
\algsum_{A*L}(\sigma_{CGK=cgk}(R_1 \bowtie R_2 \\
&& \quad \bowtie \{\tuple{e,g,i,j}\} \bowtie R_6))[\cdot]
\\
&=&
\algsum_{A*L}(\sigma_{C=c}(R_1) \bowtie \sigma_{E=e}(R_2) \\
&& \quad \times \sigma_{IJK=ijk}(R_6))[\cdot]
\\
&=&
\algsum_{A}(\sigma_{C=c}(R_1) \bowtie \sigma_{E=e}(R_2))[ce] \\
&& \quad * \algsum_L(\sigma_{IJK=ijk}(R_6))[ijk]
\end{eqnarray*}
\punto
\end{example}



