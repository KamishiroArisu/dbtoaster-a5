\documentclass{article}

\usepackage{fullpage}

\usepackage{latexsym}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{verbatim}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{metatheorem}{Metatheorem}[section]
\newtheorem{example}[theorem]{Example}
%\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{property}[theorem]{Property}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{proviso}[theorem]{Proviso}
\newtheorem{todo}[theorem]{ToDo}

\newcommand{\tuple}[1]{{\langle#1\rangle}}

\begin{document}
\title{Revised DBToaster rules.}
\date{}
\maketitle

\def\algsum{\mathrm{sum}}
\def\algagg{\mathrm{agg}}
\def\algtop{\mathrm{top}}
\def\algtopk{\mathrm{topk}}

\def\algnew{\mathrm{new}}
\def\algmin{\mathrm{min}}
\def\algmax{\mathrm{max}}
\def\algincr{\mathrm{incr}}
\def\algincrdiff{\mathrm{incrdiff}}
\def\alginsert{\mathrm{insert}}
\def\algupdate{\mathrm{update}}
\def\algdelete{\mathrm{delete}}
\def\algfor{\mathrm{foreach}}

\def\algsumr{\mbox{sumr}}
\def\algsumf{\mbox{sumf}}
\def\algaggf{\mbox{aggf}}
\def\distinct{\mbox{distinct}}
\def\routerjoin{\bowtie\!=}

\begin{figure*}
\begin{eqnarray}
\label{eq:a1}
\Delta_{\pm R(\vec{r})} c       &:=& 0 \\
\label{eq:a2}
\Delta_{\pm R(\vec{r})} x       &:=& 0 \\
\label{eq:a3}
\Delta_{\pm R(\vec{r})} (f + g) &:=& (\Delta_{\pm R(\vec{r})} f) + (\Delta_{\pm R(\vec{r})} g) \\
\label{eq:a4}
\Delta_{\pm R(\vec{r})} (f * g) &:=&         f                * (\Delta_{\pm R(\vec{r})} g)
                              +   (\Delta_{\pm R(\vec{r})} f) * g                        
                              +   (\Delta_{\pm R(\vec{r})} f) * (\Delta_{\pm R(\vec{r})} g)
\\
\label{eq:a5}
\Delta_{\pm R(\vec{r})} \algsum_f(Q) &:=&
   \algsum_{\Delta_{\pm R(\vec{r})} f}(Q)
   + \algsum_f(\Delta_{\pm R(\vec{r})} Q)
   + \algsum_{\Delta_{\pm R(\vec{r})} f}(\Delta_{\pm R(\vec{r})} Q)
\\
\nonumber
&\dots& \mbox{$f = \algsum$}
\\
\label{eq:a6}
\Delta_{\pm R(\vec{r})} \algsum_f(Q) &:=&
   \algsum_f(\Delta_{\pm R(\vec{r})} Q)
\\
\nonumber
&\dots& \mbox{$\Delta_{\pm R(\vec{r})} f = 0$ (optimization of Eq.~\ref{eq:a5})}
%
%
\\[2ex]
\label{eq:b1}
\Delta_{\pm R(\vec{r})} \rho_{\vec{A}}(R) &:=& \pi_{\vec{r} \rightarrow \vec{A}}\{\tuple{}\}
\\
\label{eq:b2}
\Delta_{\pm R(\vec{r})} S &:=& \emptyset
\\
\label{eq:b3}
\Delta_{\pm R(\vec{r})} \{ \vec{a} \} &:=& \emptyset 
\\
\label{eq:b4}
\Delta_{\pm R(\vec{r})} (Q_1 \cup Q_2) &:=&
(\Delta_{\pm R(\vec{r})} Q_1) \cup (\Delta_{\pm R(\vec{r})} Q_2)
\\
\label{eq:b5}
\Delta_{\pm R(\vec{r})} (Q_1 \times Q_2) &:=&
((\Delta_{\pm R(\vec{r})} Q_1) \times Q_2) \cup
(Q_1 \times (\Delta_{\pm R(\vec{r})} Q_2)) \\
\nonumber
&\cup&
((\Delta_{\pm R(\vec{r})} Q_1) \times (\Delta_{\pm R(\vec{r})} Q_2))
\\
\label{eq:b6}
\Delta_{\pm R(\vec{r})} \sigma_{f \theta 0}(Q) &:=&
\sigma_{f \theta 0}(\Delta_{\pm R(\vec{r})} Q)
\\
\nonumber
&\dots& \Delta_{\pm R(\vec{r})} f[\vec{x}, \vec{A}] = 0 \mbox{ on all $\vec{A}$}, \theta \in \{=,<\}
\\
\nonumber
\Delta_{\pm R(\vec{r})} \pi_{\dots}(Q) &\dots& \mbox{no rule, simplify 
surrounding aggregate instead}
\\[2ex] \nonumber
%
%
\end{eqnarray}

\vspace{-4mm}

\caption{Recursive algorithm for compiling the
on insert into $R$ values $\vec{r}$ trigger.}
\label{fig:mainalg}
\end{figure*}

%
%
\begin{figure*}
\begin{eqnarray}
\mbox{Increment operator definitions:} && \nonumber\\
\label{eq:incr1}
\algincr_{\oplus_f, S} \Delta_{\pm R(\vec{r})} f &:=& S \leftarrow
\oplus_f(S, \Delta_{\pm R(\vec{r})} f); S
\\
\nonumber &\dots& \mbox{where $\oplus_f \in \{+,-,\min\}$}
\\
\label{eq:incr2}
\algincr_{\oplus_Q, S} \Delta_{\pm R(\vec{r})} Q &:=& S \leftarrow
\oplus_Q(S, \Delta_{\pm R(\vec{r})} Q); S
\\
\nonumber &\dots& \mbox{where $\oplus_Q \in \{\cup, -\}$}
\\
%
%
\label{eq:incr3}
\algincrdiff_{\oplus_f, S} \Delta_{\pm R(\vec{r})} f &:=&
S \leftarrow \oplus_f(S, \Delta_{\pm R(\vec{r})} f); \Delta_{\pm R(\vec{r})} f
\\
\nonumber &\dots& \mbox{where $\oplus_f \in \{+, -,\min\}$}
\\
\label{eq:incr4}
\algincrdiff_{\oplus_Q, S} \Delta_{\pm R(\vec{r})} Q &:=&
S \leftarrow \oplus_Q(S, \Delta_{\pm R(\vec{r})}); \Delta_{\pm R(\vec{r})} Q
\\
\nonumber &\dots& \mbox{where $\oplus_Q \in \{\cup, -\}$}
%
%
\\[2ex]
\mbox{State maintenance operator definitions:} && \nonumber
\\
\label{eq:sm1}
\alginsert_{+R(\vec{r}), S[A]} f
&:=&
\mbox{$R$.insert($\vec{r}$)};
\\
\nonumber
&&
\mbox{if ($A \notin keys(S)$) $S$.insert($A$,  $\algnew_{+R(\vec{r})} f$)};
\\
\nonumber
&&
S[A]
\\
\label{eq:sm2}
\algupdate_{\oplus, S[A]} \Delta_{\pm R(\vec{r})} f
&:=&
S[A] \leftarrow \oplus(S[A], \Delta_{\pm R(\vec{r})} f);
S[A]
\\
\label{eq:sm3}
\algdelete_{S[A]}
&:=&
S.erase[A]
\end{eqnarray}
\end{figure*}

%
%
\begin{figure*}
\begin{eqnarray}
\mbox{Frontier computation:} && \nonumber
\\
\nonumber\algnew_{\pm R(\vec{r})} f &:=& \mbox{new value of \emph{f} after insertion/deletion of } \vec{r} \\
\label{eq:new1}
\algnew_{\pm R(\vec{r})} c       &:=& \algincr_{c} \Delta_{\pm R(\vec{r})} c \\
\label{eq:new2}
\algnew_{\pm R(\vec{r})} x       &:=& \algincr_{x} \Delta_{\pm R(\vec{r})} x \\
\label{eq:new3}
\algnew_{\pm R(\vec{r})} (f \pm g) &:=&
(\algnew_{\pm R(\vec{r})} f) \pm (\algnew_{\pm R(\vec{r})} g) \\
\label{eq:new4}
\algnew_{\pm R(\vec{r})} (f * g) &:=&
(\algnew_{\pm R(\vec{r})} f) * (\algnew_{\pm R(\vec{r})} g)\\
%
%
\nonumber\\[2ex]
\label{eq:newr1}
\algnew_{\pm R(\vec{r})} \rho_{\vec{A}}(R) &:=&
   \algincr_{\rho_{\vec{A}}(R)} \Delta_{\pm R(\vec{r})} \rho_{\vec{A}}(R)
\\
\label{eq:newr2}
\algnew_{\pm R(\vec{r})} S &:=& \algincr_{S} \Delta_{\pm R(\vec{r})} S
\\
\label{eq:newr3}
\algnew_{\pm R(\vec{r})} \{ \vec{a} \} &:=&
\algincr_{\{ \vec{a} \}} \Delta_{\pm R(\vec{r})} \{ \vec{a} \}
\\
\label{eq:newr4}
\algnew_{\pm R(\vec{r})} (Q_1 \cup Q_2) &:=&
   (\algnew_{\pm R(\vec{r})} Q_1) \cup (\algnew_{\pm R(\vec{r})} Q_2)
\\
\label{eq:newr5}
\algnew_{\pm R(\vec{r})} (Q_1 \times Q_2) &:=&
   (\algnew_{\pm R(\vec{r})} Q_1) \times (\algnew_{\pm R(\vec{r})} Q_2)
%
%
\\[2ex]
\label{eq:newr6}
\algnew_{\pm R(\vec{r})} \sigma_{f \theta 0}(Q) &:=&
   \sigma_{(\algnew_{\pm R(\vec{r})} f) \theta 0}(\algnew_{\pm R(\vec{r})} Q)
%
%
\\[2ex]
\label{eq:newr7}
\algnew_{\pm R(\vec{r})} f[g] & := &
   (\algnew_{\pm R(\vec{r})} f)[\algnew_{\pm R(\vec{r})} g]
%
%
%
\\[2ex]
\mbox{Frontier simplification:} && \nonumber
\\
\label{eq:fs1}
\algincr_{S_f} \Delta_{\pm R(\vec{r})} f
    \pm \algincr_{S_g} \Delta_{\pm R(\vec{r})} g &:=&
\algincr_{S} \Delta_{\pm R(\vec{r})} (f \pm g)
\\
\label{eq:fs2}
\algincr_{S_f} \Delta_{\pm R(\vec{r})} f * \algincr_{S_g} \Delta_{\pm R(\vec{r})} g &:=&
\algincr_{S} \Delta_{\pm R(\vec{r})} (f * g)
\\
\label{eq:fs3}
\algincr_{S_{Q1}} \Delta_{\pm R(\vec{r})} Q1 \cup \algincr_{S_{Q2}} \Delta_{\pm R(\vec{r})} Q2
&:=&
\algincr_{Q} \Delta_{\pm R(\vec{r})} (Q1 \cup Q2)
\\
\label{eq:fs4}
\algincr_{S_{Q1}} \Delta_{\pm R(\vec{r})} Q1 \times \algincr_{S_{Q2}} \Delta_{\pm R(\vec{r})} Q2
&:=&
\algincr_{Q} \Delta_{\pm R(\vec{r})} (Q1 \times Q2)
%\\
%\label{eq:i5}
%\algsum_{\algincr_{S_f} \Delta_{\pm R(\vec{r})} f}
%    (\algincr_{S_Q} \Delta_{\pm R(\vec{r})} Q)
%&:=&
%    \algincr_{S_{sum}} \Delta_{\pm R(\vec{r})} \algsum_{f}(Q)
%\\
%\label{eq:i6}
%\algmin_{\algincr_{S_f} \Delta_{+R(\vec{r})} f} (\algincr_{S_Q} \Delta_{+R(\vec{r})} Q)
%&:=&
%\algincr_{S_{min}} \Delta_{+R(\vec{r})} \algmin_{f} (Q)
\end{eqnarray}
\end{figure*}

%
%
%
\begin{figure*}
\begin{eqnarray}
\mbox{Aggregate computation:} && \nonumber
\\
\label{eq:agg1}
\algnew_{\pm R(\vec{r})} \algaggf_f(Q) &:=&
   \algaggf_{\algnew_{\pm R(\vec{r})} f}(\algnew_{\pm R(\vec{r})} Q)
%
%
\\[2ex]
\label{eq:agg2}
\algnew_{\pm R(\vec{r})} \algsum_{f}(Q) &:=&
\algincr_{\pm, S} \Delta_{\pm R(\vec{r})} \algsum_{f}(Q)
\\
\nonumber &\dots&
\mbox{$f = \algsum$ or $\Delta_{+R(\vec{r})} f = 0$}
%
%
\\[2ex]
\label{eq:agg3}
\Delta_{\pm R(\vec{r})} \algmin_f(Q) &:=& 0
\\
\nonumber &\dots& R \notin \mbox{relations($Q$)}
%
%
\\
\label{eq:agg4}
\algincr_{\oplus, S} \delta_{\pm R(\vec{r})} f &:=&
S \leftarrow \oplus(S, \delta_{\pm R(\vec{r})} f); S
%
%
\\[2ex]
\label{eq:agg5}
\delta_{+R(\vec{r})} \algmin_f(Q) &:=& \algmin_{f} (
    \underbrace{\algincrdiff_{\cup, S_Q}}_{
        \mathrm{for} \; \algnew_{-R(\vec{r})} \algmin_f(Q),
        \mbox{ $S_Q$ is shared with $\delta_{-R(\vec{r})} \algmin_f(Q)$}}
    \Delta_{+R(\vec{r})} Q)
\\
\label{eq:agg6}
\algnew_{+R(\vec{r})} \algmin_{f}(Q) &:=&
\algincr_{\min,S} \delta_{+R(\vec{r})} \algmin_{f}(Q)
\\
\nonumber
&\dots& \Delta_{+R(\vec{r})} f = 0
\mbox{, for Eq.~\ref{eq:agg3}-~\ref{eq:agg5}.}
%
%
\\[2ex]
\label{eq:agg7}
\delta_{-R(\vec{r})} \algmin_{f}(Q) &:=& \algmin_{f}(\algincrdiff_{-,S_Q} \Delta_{-R(\vec{r})} Q)
\\
\nonumber &\dots& \mbox{where $S_Q$ is shared with $\delta_{+R(\vec{r})} \algmin_f(Q)$}
\\
\label{eq:agg8}
decrmin(f, S_Q, S_m, \Delta) &=&
\mbox{if ($\Delta$ = $S_m$ and $S_Q$.find($S_m$) = $S_Q$.end)}\\
\nonumber && \mbox{then} \; \; \algmin_{f}(S_Q) \; \; \mbox{else} \; \; S_m
\\
\label{eq:agg9}
\algnew_{-R(\vec{r})} \algmin_{f}(Q) &:=&
\algincr_{decrmin(f, S_Q, S, \Delta), S} \delta_{-R(\vec{r})} \algmin_{f}(Q)
\\
\nonumber &\dots& \Delta_{-R(\vec{r})} f = 0
\mbox{, for Eq.~\ref{eq:agg7}-\ref{eq:agg8}.}
\end{eqnarray}
\end{figure*}


% Aggregate simplifications
%
\begin{figure*}
\begin{eqnarray}
\nonumber
\mbox{Aggregate map simplifications:} &&
\\
\label{eq:ags1}
\algaggf_{f[\vec{A}, B_1, \dots, B_k]}
   (\pi_{\vec{A}, g_1 \rightarrow B_1, \dots, g_k \rightarrow B_k}(Q))
&:=&
\algaggf_{f[\vec{A}, g_1, \dots, g_k]}(Q)
\\
\label{eq:ags2}
\algaggf_f(\{\tuple{}\}) &:=& f
%\label{eq:c2}
%\algsumf_f(\sigma_{g \,\theta\, 0}(Q))
%&:=&
%\algsumf_{\mathrm{if} \, (g \,\theta\, 0) \, \mathrm{then}
%      \, f \, \mathrm{else} \, 0}(Q)
%\\
%
%
\\[2ex]
\mbox{Sum aggregate simplifications:} && \nonumber\\
\label{eq:sum1}
\algsum_f(\emptyset) &:=& 0
\\
\label{eq:sum2}
\algsum_{0}(Q) &:=& 0
\\
\label{eq:sum3}
\algsum_{f[\vec{x}]}(Q) &:=& f[\vec{x}] * \algsum_1(Q)
\\
\label{eq:sum4}
\algsum_{f[\vec{x}]*g}(Q) &:=& f[\vec{x}] * \algsum_{g}(Q)
\\
\label{eq:sum5}
\algsum_{f+g}(Q) &:=& \algsum_f(Q) + \algsum_g(Q)
\\
\label{eq:sum6}
\algsum_f(Q_1 \cup Q_2) &:=& \algsum_f(Q_1) + \algsum_f(Q_2)
\\
\label{eq:sum7}
\algsum_{f[\vec{A};\dots] * g[\vec{B};\dots]}(\rho_{\vec{A}}(Q_1) \times \rho_{\vec{B}}(Q_2)) \; &:=&
\algsum_{f[\vec{A};\dots]}(\rho_{\vec{A}}(Q_1))
    * \algsum_{f[\vec{B};\dots]}(\rho_{\vec{B}}(Q_2))
%
%
\\[2ex]
\mbox{Min aggregate simplifications:} && \nonumber\\
\label{eq:min1}
\algmin_{f}(\emptyset) &:=& \infty
\\
\label{eq:min2}
\algmin_{f[\vec{x}]}(Q) &:=& f[\vec{x}]
\\
\label{eq:min3}
\algmin_{f[\vec{x}]+g}(Q) &:=& f[\vec{x}] + \algmin_{g}(Q)
\\
\label{eq:min4}
\algmin_{f[\vec{x}]*g}(Q) &:=&
\left\{
\begin{array}{lll}
f[\vec{x}] * \algmin_{g}(Q) & \dots & f[\vec{x}] \geq 0 \\
f[\vec{x}] * \algmax_{g}(Q) & \dots & f[\vec{x}] < 0
\end{array}
\right.
\\
\label{eq:min5}
\algmin_{f}(Q_1 \cup Q_2) &:=& \min(\algmin_f (Q_1), \algmin_f (Q_2))
\\
\label{eq:min6}
\algmin_{f[\vec{A};\dots] + g[\vec{B};\dots]}(\rho_{\vec{A}}(Q_1) \times \rho_{\vec{B}}(Q_2)) \; &:=&
\algmin_{f[\vec{A};\dots]}(\rho_{\vec{A}}(Q_1))
    + \algmin_{g[\vec{B};\dots]}(\rho_{\vec{B}}(Q_2))
\\
\label{eq:min7}
\algmin_{f[\vec{A};\dots] * g[\vec{B};\dots]}(\rho_{\vec{A}}(Q_1) \times \rho_{\vec{B}}(Q_2)) \; &:=&
\min \Big\{\;
\algmin_{f[\vec{A};\dots]} (\sigma_{f[\vec{A}] \geq 0} (\rho_{\vec{A}}(Q_1)))
    * \algmin_{g[\vec{B};\dots]} (\rho_{\vec{B}}(Q_2)), \nonumber\\
&& \qquad \;
\algmin_{f[\vec{A};\dots]} (\rho_{\vec{A}} (Q_1))
    * \algmin_{g[\vec{B};\dots]} (\sigma_{g[\vec{B}] \geq 0} (\rho_{\vec{B}}(Q_2))), \nonumber\\
&& \qquad \;
\algmax_{f[\vec{A};\dots]} (\sigma_{f[\vec{A}] < 0} (\rho_{\vec{A}} (Q_1)))
    * \algmax_{g[\vec{B};\dots]} (\sigma_{g[\vec{B}] < 0} (\rho_{\vec{B}}(Q_2)))
\Big\}
\\ \nonumber
%
%
%
\\[2ex]
\mbox{Predicate simplifications:} && \nonumber\\
\label{eq:pred1}
\sigma_{f[A] \theta 0}(Q) &:=& \sigma_{A \ge A_{\min}[]}(Q)
\\
&\dots& \mbox{$f$ is monotonically increasing in its argument and}
\nonumber
\\
&& A_{\min}[] = \min \{ A' \mid f[A'] \theta 0 \} 
\nonumber
\\[2ex]
\label{eq:pred2}
\sigma_{f[A] \theta 0}(Q) &:=& \sigma_{A \le A_{\max}[]}(Q)
\\
&\dots& \mbox{$f$ is monotonically decreasing in its argument and}
\nonumber
\\
&& A_{\max}[] = \max \{ A' \mid f[A'] \theta 0 \} 
\nonumber
\\
\label{eq:pred3}
\sigma_{f[A] \theta g[\vec{x}]}(Q) &:=& \sigma_{f[A] \theta c}(Q)[c=g[\vec{x}]]
\\
\label{eq:pred4}
\sigma_{g_1=B} (\rho_{\vec{A}}(Q)) &:=&
\pi_{g_1\rightarrow B}(bind_{g_1\rightarrow B}(\rho_{\vec{A}}(Q)))
\\
\label{eq:pred5}
\sigma_{g_1=B \wedge f[\vec{A}, g_1 \dots g_k] \theta 0}(\rho_{\vec{A}}(Q)) &:=&
\sigma_{f[\vec{A}, g_1 \dots g_k] \theta 0}(\pi_{g_1 \rightarrow B}(
bind_{g_1 \rightarrow B}(\rho_{\vec{A}}(Q))))
\\
\nonumber &\dots& \mbox{$bind_{g_1 \rightarrow B}(Q)$ replaces occurrences of column $B$ in $Q$ with $g_1$}
%
%
\\[2ex]
\mbox{Relational algebra simplifications:} &&
\nonumber\\
\label{eq:rs1}
\sigma_{f[\vec{A}, B_1, \dots, B_k] \,\theta\, 0}
   (\pi_{\vec{A}, g_1 \rightarrow B_1, \dots, g_k \rightarrow B_k}(Q))
&:=&
\pi_{\vec{A}, g_1 \rightarrow B_1, \dots, g_k \rightarrow B_k}(
\sigma_{f[\vec{A}, g_1, \dots, g_k] \,\theta\, 0}(Q))
\\
\label{eq:rs2}
\sigma_{(f_1 \theta_1 f_2)[\vec{A}] \wedge (g_1 \theta_2 g_2)[\vec{B}]}
(\rho_{\vec{A}}(Q_1) \times \rho_{\vec{B}}(Q_2))
&:=&
\sigma_{(f_1 \theta_1 f_2)[\vec{A}]}(\rho_{\vec{A}}(Q_1)) \times
\sigma_{(g_1 \theta_2 g_2)[\vec{B}]}(\rho_{\vec{B}}(Q_2))
\end{eqnarray}
\end{figure*}

% Map domain maintenance
%
\begin{figure*}
\begin{eqnarray}
\mbox{Map domain maintenance rules:} && \nonumber\\
\label{eq:md1}
\sigma_{(\algincr_{\oplus, S_f} \Delta_{+R(\vec{r})} f)[A] \theta 0} (\algincr_{\cup, S_Q}
\Delta_{+R(\vec{r})} Q)
&:=&
\sigma_{(\algupdate_{\oplus, S_{f}[A]} \Delta_{+R(\vec{r})} f) \theta 0} (S_Q)
\\
\nonumber && 
\cup\; 
\sigma_{(\alginsert_{+R(\vec{r}), S_{f}[A]} f) \theta 0}
(\algincrdiff_{\cup, S_Q} \Delta_{+R(\vec{r})} Q)
\\
\label{eq:md2}
\sigma_{(\algincr_{\oplus, S_f} \Delta_{-R(\vec{r})} f)[A] \theta 0}
(\algincr_{-,S_Q} \Delta_{-R(\vec{r})}Q) &:=&
\algdelete_{S_f[A]}(\Delta_{-R(\vec{r})} Q);
\\
\nonumber &&
\sigma_{\algupdate_{\oplus, S_f[A]} \Delta_{-R(\vec{r})}f}
(\algincr_{-,S_Q} \Delta_{-R(\vec{r})} Q)
\\
\label{eq:md3}
\sigma_{(\algnew_{+R(\vec{r})} f) \theta 0} (\algincr_{\cup, S_Q}
\Delta_{+R(\vec{r})} Q)
&:=&
\sigma_{(\algnew_{+R(\vec{r})} f) \theta 0} (S_Q)
\cup
\sigma_{(\algnew_{+R(\vec{r})} f) \theta 0}
(\algincrdiff_{\cup, S_Q} \Delta_{+R(\vec{r})} Q)
\\
\label{eq:md4}
(\algincr_{\oplus, S_f} \Delta_{+R(\vec{r})} f)[c=\algnew_{+R(\vec{r})} g]
&:=&
\algfor(\mbox{$c$}) \; \{ \; \mathrm{ignore}((\algupdate_{\oplus, S_{f}[c]} \Delta_{+R(\vec{r})} f)[c]) \; \};
\\
\nonumber && rc = \algnew_{+R(\vec{r})} g;
\\
\nonumber
&&
(\alginsert_{+R(\vec{r}), S_{f}[rc]} f)[rc]
\\
\label{eq:md5}
(\algincr_{\oplus_1, S_f} \Delta_{+R(\vec{r})} f)
[c=\algincr_{\oplus_2, S_g} \Delta_{+R(\vec{r})} g]
&:=&
\algfor(c) \; \{ \; \mathrm{ignore}((\algupdate_{\oplus_1, S_{f}[c]} \Delta_{+R(\vec{r})} f)[c]) \; \} ;
\\
\nonumber && rc = \algincr_{\oplus_2, S_g} \Delta_{+R(\vec{r})} g;
\\
\nonumber
&& (\alginsert_{+R(\vec{r}), S_{f}[rc]} f)[rc]
\\
\label{eq:md6}
(\algincr_{\oplus, S_f}\Delta_{-R(\vec{r})} f)[c = \algnew_{-R(\vec{r})} g]
&:=&
rc = \algnew_{-R(\vec{r})} g;
\\
\nonumber &&
\mbox{if ($(\algupdate_{\oplus, S_f[rc]} \Delta_{-R(\vec{r})} f)[rc] = f(R = \emptyset)[rc]$)}
\; \{ \; \algdelete_{S_f[rc]} \; \};
\\
\nonumber &&
\algfor(c) \; \{ \; \mathrm{ignore}((\algupdate_{\oplus, S_f[c]}\Delta_{-R(\vec{r})} f)[c]) \; \};
\\
\nonumber && S_f[rc]
\\
\label{eq:md7}
(\algincr_{\oplus_1, S_f} \Delta_{-R(\vec{r})} f)[c = \algincr_{\oplus_2,S_g} \Delta_{-R(\vec{r})} g]
&:=&
rc = \algincr_{\oplus_2, S_g} \Delta_{-R(\vec{r})} g;
\\
\nonumber &&
\mbox{if ($(\algupdate_{\oplus_1, S_f[rc]} \Delta_{-R(\vec{r})} f)[rc] = f(R = \emptyset)[rc]$)}
\; \{ \; \algdelete_{S_f[rc]} \; \};
\\
\nonumber &&
\algfor(c) \; \{ \; \mathrm{ignore}((\algupdate_{\oplus_1, S_f[c]}\Delta_{-R(\vec{r})} f)[c]) \; \};
\\
\nonumber && S_f[rc] \\
\nonumber &\dots& \mbox{ignore(f): evaluate f with no return value for Eq.~\ref{eq:md4}-\ref{eq:md7}}
\end{eqnarray}
\end{figure*}


% Nested aggregate simplification
%
\begin{figure*}
\begin{eqnarray}
\mbox{Nested aggregate computation:} && \nonumber
\\
\label{eq:na1}
\algsum_{(\algincr_{min, S_1} \delta_{+R(\vec{r})} \algmin_{f}(Q_1))[A]}
(\algincr_{\cup,S_2} \Delta_{+R(\vec{r})} Q_2)
&:=&
\algsum_{\algupdate_{\min, S_{1}[A]} \delta_{+R(\vec{r})} \algmin_{f}(Q_1)}(S_2)
\\
\nonumber &&
+ \; \algsum_{\alginsert_{+R(\vec{r}), S_{1}[A]} \algmin_{f}(Q_1)}
    (\algincrdiff_{\cup, S_2} \Delta_{+R(\vec{r})} Q_2)
\\
\label{eq:na2}
\algsum_{\algnew_{\pm R(\vec{r})} f} (\algincr_{\cup,S} \Delta_{\pm R(\vec{r})} Q)
&:=&
\algsum_{\algnew_{\pm R(\vec{r})} f}(S) 
    \pm \algsum_{\algnew_{\pm R(\vec{r})} f}
        (\algincrdiff_{\cup, S} \Delta_{\pm R(\vec{r})} Q)
%
%
\\[2ex]
\label{eq:na3}
\algmin_{(\algincr_{\oplus, S_1} \Phi_{+ R(\vec{r})} f)[A]}
(\algincr_{\cup, S_2} \Delta_{+R(\vec{r})} Q_2)
&:=&
\min \Big\{
\algmin_{\algupdate_{\oplus, S_1[A]} \Phi_{+R(\vec{r})} f} (S_2),
\\
\nonumber &&
\qquad \; \algmin_{\alginsert_{+R(\vec{r}), S_1[A]} f}
(\algincrdiff_{\cup, S_2} \Delta_{+R(\vec{r})} Q_2)
\Big\}
\\
\nonumber &\dots& \mbox{where $\Phi \in \{\Delta, \delta\}$}
\\
%
%
\label{eq:na4}
\algmin_{\algnew_{+R(\vec{r})} f} (\algincr_{\cup, S} \Delta_{+R(\vec{r})} Q)
&:=&
\min \Big\{
\algmin_{\algnew_{+R(\vec{r})} f} (S), 
\algmin_{\algnew_{+R(\vec{r})} f} (\algincrdiff_{\cup, S} \Delta_{+R(\vec{r})} Q)
\Big\}
%
%
%
\\[2ex]
\label{eq:na5}
\algaggf_{(\algincr_{\oplus, S_1} \delta_{-R(\vec{r})} \algmin_{f}(Q_1))[A]}
(\algincr_{-,S_2} \Delta_{-R(\vec{r})} Q_2)
&:=&
\algdelete_{S_{1}[A]}(\Delta_{-R(\vec{r})} Q_2);
\\
\nonumber &&
\algaggf_{\algupdate_{\oplus, S_{1}[A]}  \delta_{-R(\vec{r})} \algmin_{f}(Q_1)}
(\algincr_{-,S_2} \Delta_{-R(\vec{r})} Q_2)
\\
\nonumber &\dots& \mbox{where $\oplus = decrmin(f, S_{\Delta \algmin})$}
\end{eqnarray}
\end{figure*}



\begin{comment}



% code_expression
\end{comment}

\pagebreak
\section{Compilation examples}
\begin{example}\em
Let us now compute the trigger
\[
\mbox{on insert into B values ($p, v$)}
\]
for the summation part of the VWAP query (from Example~\ref{ex:compiler1})
\[
q[] = \algsumf_{P_2 * V_2}(\sigma_{m(P_2) > 0} (\rho_{P_2, V_2}(B)))
\]
where
\begin{eqnarray*}
m(P_2) &=&
k*\algsumf_{V_0}(\rho_{V_0}(B)) -
\algsumf_{V_1}(\sigma_{P_1 - P_2 > 0}(\rho_{P_1,V_1}(B)))
\\
\end{eqnarray*}

\noindent~Note $m(P_2)$ is not defined as a map above, but as a nested map
expression for ease of presentation.\\

Then
\begin{eqnarray*}
q[] &:=&
\algsumf_{P_2 * V_2}(\sigma_{m(P_2) > 0} (\rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:pred1})}{=}&
\algsumf_{P_2 * V_2}(\sigma_{P_2 > P_{min}[]} (\rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:pred3})}{=}&
\algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2, V_2}(B)))[c=P_{min}[]]
\\
\algnew_{+B(p,v)} q[]
&\stackrel{(\ref{eq:newr7})}{:=}&
(\algnew_{+B(p,v)}
\algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2, V_2}(B))))
[c=\algnew_{+B(p,v)} P_{min}[]]
\\
&\stackrel{(\ref{eq:agg2})}{=}&
(\algincr_{q'} \Delta_{+B(p,v)} q')
[c=\algnew_{+B(p,v)} P_{min}[]]
\end{eqnarray*}

\noindent~where
\[q'[c]:=\algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2, V_2}(B)))\]
and
\[
\Delta_{+B(p,v)} q'[c] =
   \mbox{if $(p \ge c)$ then $p * v$ else $0$}
\]

Next,

\begin{eqnarray*}
\algnew_{+B(p,v)} P_{min}[]
&:=&
\algmin_{P_2}(\sigma_{m(P_2) > 0} (\rho_{P_2}(B)))
\\ 
&\stackrel{(\ref{eq:agg1})}{=}&
\algmin_{P_2}(\algnew_{+B(p,v)} \sigma_{m(P_2) > 0} (\rho_{P_2}(B)))
\\
&\stackrel{(\ref{eq:newr6})}{=}&
\algmin_{P_2}(\sigma_{\algnew_{+B(p,v)} m(P_2) > 0} (
\algnew_{+B(p,v)} \rho_{P_2}(B)))
\\
&\stackrel{(\ref{eq:newr1})}{=}&
\algmin_{P_2}(
\sigma_{\algnew_{+B(p,v)} m(P_2) > 0} 
(\algincr_{\cup, \rho_{P_2}(B)} \Delta_{+B(p,v)} \rho_{P_2}(B)))
%
%
%
\\[3ex]
\algnew_{+B(p,v)} m(P_2)
&:=&
\algnew_{+B(p,v)} k* \algsumf_{V_0}(\rho_{V_0}(B))
-
\algnew_{+B(p,v)} \algsumf_{V_1}(\sigma_{P_1 - P_2 > 0}(\rho_{P_1,V_1}(B)))
\\
&\stackrel{(\ref{eq:new3})}{=}&
\algincr_{\dots} \Delta_{+B(p,v)} k* \algsumf_{V_0}(\rho_{V_0}(B))
-
\algincr_{\dots} \Delta_{+B(p,v)}
\algsumf_{V_1}(\sigma_{P_1 - P_2 > 0}(\rho_{P_1,V_1}(B)))
\\
&\stackrel{(\ref{eq:fs1})}{:=}&
\underbrace{\algincr_{m(P_2)}}_{m[p_2]}
\underbrace{\Delta_{+B(p,v)} m(P_2)}_{\Delta m[p_2]}
\\[3ex]
%
%
%
\algnew_{+B(p,v)} P_{min}[]
&=&
\algmin_{P_2}
(\sigma_{(\algincr_{+, m[p_2]} \Delta_{+B(p,v)} m)[p_2] > 0}
(\algincr_{\cup, \rho_{P_2}(B)} \Delta_{+B(p,v)} \rho_{P_2}(B))
\\
&\stackrel{(\ref{eq:md1})}{=}&
\algmin_{P_2}
(\sigma_{(\algupdate_{+, m[p_2]} \Delta_{+B(p,v)} m)[p_2] \theta 0}(\rho_{P_2} (B))
\nonumber \\
&& \cup \;
\sigma_{(\alginsert_{+B(p,v), m[p_2]} m)[p_2] \theta 0}
(\algincrdiff_{\cup, \rho_{P_2}(B)} \Delta_{+B(p,v)} \rho_{P_2}(B)))
\end{eqnarray*}


%
%
%
%
%
%
We also have,
\begin{eqnarray*}
\Delta_{+B(p,v)} m[p_2] &=& k * 
(\Delta_{+B(p,v)} s_0[]) - (\Delta_{+B(p,v)} s_1[p_2]) 
\\
\Delta_{+B(p,v)} s_0[] &:=&
   \Delta_{+B(p,v)} \algsumf_{V_0}(\rho_{P_0, V_0}(B))
\\
&\stackrel{(\ref{eq:a6})}{=}& 
   \algsumf_{V_0}(\Delta_{+B(p,v)} \rho_{P_0, V_0}(B))
\\
&& \quad (\Delta_{+B(p,v)} V_0 = 0)
\\
&\stackrel{(\ref{eq:b1})}{=}&
\algsumf_{V_0}(\pi_{p \rightarrow P_0, v \rightarrow V_0}(\{\tuple{}\}))
\\
&\stackrel{(\ref{eq:ags1})}{=}& \algsumf_v(\{\tuple{}\})
\stackrel{(\ref{eq:ags2})}{=}
v
\\
\Delta_{+B(p,v)} s_1[p_2] &:=&
   \Delta_{+B(p,v)} \algsumf_{V_1}(\sigma_{P_1 - p_2 > 0}(\rho_{P_1, V_1}(B)))
\\
&\stackrel{(\ref{eq:a6}), (\ref{eq:b6})}{=}&
\algsumf_{V_1}(\sigma_{P_1 - p_2 > 0}(\Delta_{+B(p,v)} \rho_{P_1, V_1}(B)))
\\
&\stackrel{(\ref{eq:b1})}{=}&
\algsumf_{V_1}(\sigma_{P_1 - p_2 > 0}(\pi_{p \rightarrow P_1, v \rightarrow V_1}(\{\tuple{}\})))
\\
&\stackrel{(\ref{eq:rs1})}{=}&
\algsumf_{V_1}(\pi_{p \rightarrow P_1, v \rightarrow V_1}(\sigma_{p - p_2 > 0}(\{\tuple{}\})))
\\
&\stackrel{(\ref{eq:ags1})}{=}&
\algsumf_{v}(\sigma_{p - p_2 > 0}(\{\tuple{}\}))
\\
&=& \mathrm{if}\, (p - p_2 > 0) \, \mathrm{then}\, v \, \mathrm{else} \, 0
\end{eqnarray*}


Thus we generate the following code:
\begin{verbatim}
on insert into B values (p, v)
{
  foreach p' in dom_p do
  {
     m[p'] += k*v - ((p > p') ? v : 0);
     q[p'] += (p >= p') ? (p * v) : 0;
  }

  B += {(p,v)};

  if (p not in dom_p) then
  {
     m[p] = k * sum_v(B)
          - sum_v(select_{p > p2}(
                      rho_{p2,v2}(B)));
     q'[p] = sum_{p2 * v2}(select_{p2 >= p}(
                      rho_{p2,v2}(B)));
     dom_p += {p}
  }

  /* maintain index on m[.] by p2 for finding
     this minimum efficiently */
  pmin = min(select_{m[p2] > 0}(project_{p2}(
               rho_{p2,v2}(B))));
  q[] = q'[pmin];
}
\end{verbatim}
%
%It makes sense to avoid naive looping over all values $p_2$ by maintaining
%$m_1[p_2]$ as a range data structure (to be described).
%\punto
\end{example}


\begin{example}\em
Given schema $R(A,B)$, $S(B,C)$, $T(C,D)$.
We incrementally maintain the aggregate query
\[
s := \algsum_{A*D}(R \bowtie S \bowtie T).
\]

Compared to the map compilation algorithm of Figure~\ref{fig':mainalg}, we take a
few shortcuts for better readability (and extend the algebra by natural joins);
nevertheless following our algorithm yields equivalent maps. 
\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T)
\\ &=&
\algsum_{A*D}(\{a\} \times \sigma_{B=b}(S) \bowtie T)
\\ &=&
\algsum_{a*D}(\sigma_{B=b}(S) \bowtie T)	
\\ &=&
a * \underbrace{\algsum_{D}(\sigma_{B=b}(S) \bowtie T)}_{s_D[b]}
\end{eqnarray*}

Derivation by current rules:
\begin{eqnarray*}
s &=& \algnew_{+R(a,b)} \algsum_{A*D}(R \bowtie S \bowtie T)
\\
&=& \algnew_{+R(a,b)}
 \algsum_{A*D}(\sigma_{R.B=S.B \wedge S.C=T.C}(R \times S \times T))
\\
&\stackrel{(\ref{eq:agg2}), (\ref{eq:a5}), (\ref{eq:b6}), (\ref{eq:b5})}{=}&
\algincr_{+,S_{sum}} \algsum_{A*D}
(\sigma_{R.B=S.B \wedge S.C=T.C}((\Delta_{+R(a,b)} R) \times S \times T))
\\
&\stackrel{(\ref{eq:b1})}{=}&
\algincr_{+,S_{sum}} \algsum_{A*D}
(\sigma_{R.B=S.B \wedge S.C=T.C}(
\pi_{a\rightarrow A, b\rightarrow B} \{\tuple{}\} \times S \times T))
\\
&\stackrel{(\ref{eq:rs1})}{=}& \algincr_{+,S_{sum}} \algsum_{A*D}
(\pi_{a \rightarrow A}\{\tuple{}\}(\sigma_{b=S.B \wedge S.C=T.C}(S \times T)))
\\
&\stackrel{(\ref{eq:ags1})}{=}&
\algincr_{+,S_{sum}} \algsum_{a*D}
(\sigma_{b=S.B \wedge S.C=T.C}(S \times T))
\\
&\stackrel{(\ref{eq:sum4})}{=}&
\algincr_{+,S_{sum}} a*
\underbrace{\algsum_{D}(\sigma_{b=S.B \wedge S.C=T.C}(S \times T))}_{s_D[b]}
\end{eqnarray*}

\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie \{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{A*D}(\sigma_{B=b}(R) \times \sigma_{C=c}(T))
\\ &=&
\underbrace{\algsum_{A}(\sigma_{B=b}(R))}_{s_A[b]} *
\underbrace{\algsum_{D}(\sigma_{C=c}(T))}_{s_D[c]}
\end{eqnarray*}

Derivation by current rules:
\begin{eqnarray*}
s &=&  \algnew_{+S(b,c)}
 \algsum_{A*D}(\sigma_{R.B=S.B \wedge S.C=T.C}(R \times S \times T))
\\
&\stackrel{(\ref{eq:agg2}), (\ref{eq:a5}), (\ref{eq:b6}), (\ref{eq:b5})}{=}&
\algincr_{+,S_{sum}} \algsum_{A*D}
(\sigma_{R.B=S.B \wedge S.C=T.C}(R \times (\Delta_{+S(b,c)} S) \times T))
\\
&\stackrel{(\ref{eq:b1})}{=}&
\algincr_{+,S_{sum}} \algsum_{A*D}
(\sigma_{R.B=S.B \wedge S.C=T.C}(R \times \{b,c\} \times T))
\\
&=& \algincr_{+,S_{sum}} \algsum_{A*D}
(\sigma_{R.B=b \wedge c=T.C}(R \times \{\} \times T))
\\
&=& \algincr_{+,S_{sum}} \algsum_{A*D}
(\sigma_{B=b}(R) \times \sigma_{C=c}(T))
\\
&\stackrel{(\ref{eq:sum7})}{=}& \algincr_{+,S_{sum}}
\underbrace{\algsum_{A} (\sigma_{B=b}(R))}_{s_A[b]} *
\underbrace{\algsum_{D}(\sigma_{C=c}(T))}_{s_D[c]}
\end{eqnarray*}
%
Note how the algebra expression here decomposes into smaller parts.

\item
Insert T(c,d): (analogous to insertion of R(a,b))
\begin{eqnarray*}
\Delta s &=& \algsum_{A*D}(R \bowtie S \bowtie \{\tuple{c,d}\})
\\ &=&
\underbrace{\algsum_{A}(R \bowtie \sigma_{C=c}(S))}_{s_A[c]} * d
\end{eqnarray*}

\begin{eqnarray*}
s = \algincr_{+,S_{sum}} d*
\underbrace{\algsum_{A} (\sigma_{R.B=S.B \wedge S.C=c}(R \times S))}_{s_A[c]}
\end{eqnarray*}
\end{itemize}

We incrementally maintain $s_D[b]$, $s_A[b]$, $s_D[c]$, and
$s_A[c]$ as well.

\begin{itemize}
\item
Insert R(a,b):
\begin{eqnarray*}
\Delta s_A[b] &=& \algsum_{A}(\{\tuple{a,b}\}) = a
\\
\mbox{foreach $c$: }
\Delta s_A[c] &=& \algsum_{A}(\{\tuple{a,b}\} \bowtie \sigma_{C=c}(S))
\\ &=&
\algsum_{a}(\sigma_{BC=bc}(S))
\\ &=&
a * \underbrace{\algsum_{1}(\sigma_{BC=bc}(S))}_{s_1[b,c]}
\end{eqnarray*}

Derivation with current rules:
\begin{eqnarray*}
\algnew_{+R(a,b)} s_A[\rho_{B}(R)] &=&
(\algnew_{+R(a,b)} \algsum_{A}(\sigma_{R.B=x}(R)))[x=\algnew_{+R(a,b)} \rho_{B}(R)]
\\
&\stackrel{(\ref{eq:agg2}), (\ref{eq:a5}), (\ref{eq:b6}), (\ref{eq:b1})}{=}& 
(\algincr_{+, s_A[x]}  \algsum_{A}
(\sigma_{R.B=x}(\pi_{a \rightarrow R.A, b \rightarrow R.B}\{<>\})))
[x = \algnew_{+R(a,b)} \rho_{B}(R)]
\\
&\stackrel{(\ref{eq:md4}), (\ref{eq:fs2}), (\ref{eq:ags1})^*, (\ref{eq:ags2})^*}{=}&
\algfor(x \in B) \; \{ \; \mathrm{ignore}((\algupdate_{+, s_{A}[x]}
\algsum_{A}
(\sigma_{R.B=x}(\pi_{a \rightarrow R.A, b \rightarrow R.B}\{<>\})))[x]) \; \};
\\
&& rc = b;
\\
&& (\alginsert_{s_{A}[rc]} a)[rc]
\\
&=&
\mbox{if ($s_A$.find($b$) != $s_A$.end)} \; \{ \; \algupdate_{+,s_A[b]} a \; \}
\\
&& \mbox{else } \; \{ \; \alginsert_{s_A[b]} a \; \}
\\
&\dots& \mbox{Note the for loop is only valid when $x = b$}
%
%
\\[2ex]
\algnew_{+R(a,b)} s_A[\rho_{C}(S)] &=&
(\algnew_{+R(a,b)} \algsum_A (R \times \sigma_{S.C=x}(S)))[x = \algnew_{+R(a,b)} \rho_{C}(S)]
\\
&\stackrel{(\ref{eq:md4}), (\ref{eq:agg2}), (\ref{eq:a5}), (\ref{eq:b6}), (\ref{eq:b1})}
{\stackrel{(\ref{eq:ags1}), (\ref{eq:ags2}), (\ref{eq:sum3})}{=}}&
\algfor(x \in C) \; \\
&& \qquad \mathrm{ignore}((\algupdate_{+, s_{A}[x]}
a * \algsum_{1}
(\sigma_{S.C=x}(S)))[x]);\\
&\dots& \mbox{Note $rc = null$, thus no return value.}
\end{eqnarray*}

(Analogously insert T(c,d) for maintaining $s_{D}[b], s_{D}[c]$.)

\item
Insert S(b,c):
\begin{eqnarray*}
\Delta s_A[c] &=&
\algsum_{A}(R \bowtie \{\tuple{b,c}\})
\\ &=&
\algsum_{A}(\sigma_{B=b}(R) \times \{c\})
\\ &=&
\algsum_{A}(\sigma_{B=b}(R))
\;=:\; s_A[b]
\\
\Delta s_D[b] &=&
\algsum_{D}(\{\tuple{b,c}\} \bowtie T)
\\ &=&
\algsum_{D}(\{b\} \times \sigma_{C=c}(T))
\\ &=&
\algsum_{D}(\sigma_{C=c}(T))
\;=:\; s_D[c]
\end{eqnarray*}
\end{itemize}

Note the derivation with current rules is analagous to a simpler form of the derivation of $s_D[b]$ here.
\\

Finally, we want to incrementally maintain $s_1[b,c]$:
\begin{itemize}
\item
Insert S(b,c):
$
\Delta s_1[b,c] =
\algsum_{1}(\{\tuple{b,c}\}) = 1
$
\end{itemize}

Thus the code is:
\begin{verbatim}
on insert into R values (a,b) {
   s += a * s_D[b];   s_A[b] += a;
   foreach c (in Cs[b]) do
      s_A[c] += a * s_1[b,c];
}

on insert into S values (b,c) {
   s += s_A[b] * s_D[c];   s_A[c] += s_A[b];
   s_D[b] += s_D[c];       s_1[b,c] += 1;
}

on insert into T values (c,d) {
   s += s_A[c] * d;   s_D[c] += d;
   foreach b (in Bs[c]) do
      s_D[b] += s_1[b,c] * d;
}
\end{verbatim}
%\punto

We can also consider deletions from base relations:
\begin{itemize}
\item
Delete R(a,b):
\begin{eqnarray*}
\algsum &=& \algsum_{A*D}((R-\{\tuple{a,b}\}) \bowtie S \bowtie T)\\
&=& \algsum_{A*D}((R \bowtie S \bowtie T) -
(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& \algsum_{A*D}(R \bowtie S \bowtie T) -\\
& & \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& \algsum' - \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
%\because
\Delta s &=&  - \algsum_{A*D}(\{\tuple{a,b}\} \bowtie S \bowtie T))\\
&=& -a*\algsum_{D}(\sigma_{B=b}(S) \bowtie T)
\end{eqnarray*} 
\end{itemize}

(Similarly for Delete S(b,c) and Delete T(c,d)).

Just as in the case for Inserts, we must also maintain additional data
structures needed by each delta handler, for example $s_{A}[c], s_{A}[b]$ needed
to dealing with deletions to relations S and C. Note that given subtraction is an
inverse operation for addition (hence $\algsum$) and is anticommutative with the
previous result as seen above, the maintenance we perform is
structurally identical to the case for inserts. 

\begin{itemize}
\item
Delete R(a,b):
\begin{eqnarray*}
\Delta s_{A}[b] &=& - \algsum_{A}(\{\tuple{a,b}\}) = -a\\
\Delta s_{A}[c] &=& -a * \algsum_{1}(\sigma_{BC=bc}(S))
\end{eqnarray*}
\end{itemize}
\end{example}
\def\algmon{\mathrm{mon}}


\section{Monotonicity analysis}
\begin{figure}
\begin{eqnarray*}
\uparrow +/* \uparrow &=& \uparrow
\\
\uparrow +/* 0 &=& \uparrow
\\
0 +/* 0 &=& 0
\\
0 +/* \perp &=& \perp
\\
\uparrow +/* \perp &=& \perp
\\
\perp +/* \perp &=& \perp
%
%
%
\\[3ex]
\algsumf_{\uparrow}(\vec{0}) &=& \uparrow
\\
\algsumf_{0}(\Uparrow) &=& \uparrow
\\
\algsumf_{\uparrow}(\Uparrow) &=& \uparrow
\\
\algsumf_{0}(\vec{0}) &=& 0
\\
\algsumf_{\perp}(\vec{0}) &=& \perp
\\
\algsumf_{0}(\Perp) &=& \perp
\\
\algsumf_{\perp}(\Uparrow) &=& \perp
\\
\algsumf_{\uparrow}(\Perp) &=& \perp
\\
\algsumf_{\perp}(\Perp) &=& \perp
%
%
\\[3ex]
\Uparrow \cup \Uparrow &=& \Uparrow
\\
\Uparrow \cup \vec{0} &=& \Uparrow^{\ast}
\\
\vec{0} \cup \vec{0} &=& \vec{0}
\\
\Uparrow \cup \Perp &=& \Perp
\\
\vec{0} \cup \Perp &=& \Perp
\\
\Perp \cup \Perp &=& \Perp
\\
\Uparrow \times \Uparrow &=& \Uparrow
\\
\Uparrow \times \vec{0} &=& \Uparrow
\\
\vec{0} \times \vec{0} &=& \vec{0}
\\
\Uparrow \times \Perp &=& \Perp
\\
\vec{0} \times \Perp &=& \Perp
\\
\Perp \times \Perp &=& \Perp
%
%
\\[2ex]
\sigma_{\uparrow}(\Uparrow) &=& \Uparrow
\\
\sigma_{\uparrow}(0) &=& \Uparrow
\\
\sigma_{0}(\Uparrow) &=& \vec{0}^{\ast}
\\
\sigma_{0}(\vec{0}) &=& \vec{0}
\\
\sigma_{\perp}(\Uparrow) &=& \Perp
\\
\sigma_{\uparrow}(\Perp) &=& \Perp
\\
\sigma_{\perp}(\vec{0}) &=& \Perp
\\
\sigma_{0}(\Perp) &=& \Perp
%
%
\\[3ex]
& & \mbox{$\ast$: semantics differs for $\vec{\uparrow}$ vs $\Uparrow$}
\end{eqnarray*}
\caption{Basic monotonicity rules.}
\end{figure}

\begin{figure}
\begin{eqnarray*}
\algmon_{\uparrow A} c &=& 0
\\
\algmon_{\uparrow A} x &=& 0
\\
\algmon_{\uparrow A} A &=& \uparrow
\\
\algmon_{\uparrow A} (f + g) &=&
(\algmon_{\uparrow A} f) + (\algmon_{\uparrow A} g)
\\
\algmon_{\uparrow A} (f * g) &=&
(\algmon_{\uparrow A} f) * (\algmon_{\uparrow A} g)
\\
\algmon_{\uparrow A} \algsumf_{f}(Q) &=&
\algsumf_{\algmon_{\uparrow A} f}(\algmon_{\uparrow A} Q)
%
%
%
\\[2ex]
\algmon_{\uparrow A} \rho_{A}(R) &=& \uparrow
\\
\algmon_{\uparrow A} S &=& 0
\\
\algmon_{\uparrow A} \{ \vec{b} \} &=& 0
\\
\algmon_{\uparrow A} (Q_1 \cup Q_2) &=&
(\algmon_{\uparrow A} Q_1) \cup (\algmon_{\uparrow A} Q_2)
\\
\algmon_{\uparrow A} (Q_1 \times Q_2) &=&
(\algmon_{\uparrow A} Q_1) \times (\algmon_{\uparrow A} Q_2)
%
%
\\[2ex]
\algmon_{\uparrow A} \sigma_{f} (Q) &=&
\sigma_{\algmon_{\uparrow A} f} (\algmon_{\uparrow A} Q)
\\
\algmon_{\uparrow A} f[g] &=&
(\algmon_{\uparrow A, \uparrow g} f)[\algmon_{\uparrow A} g]
\\
\algmon_{\uparrow A, \uparrow g} f &=& 
(\algmon_{\uparrow A} f) * (\algmon_{\uparrow g} f)
%
%
%
\\[3ex]
(\uparrow)[\uparrow] &=& \uparrow ?
\\
(\uparrow)[0] &=& \uparrow
\\
(0)[\uparrow] &=& 0^{\dagger} ?
\\
(0)[0] &=& 0^{\dagger}
\\
(\perp)[\uparrow] &=& \perp
\\
(\perp)[0] &=& \perp
\\
(0)[\perp] &=& 0^{\dagger}
\\
(\uparrow)[\perp] &=& \perp
\\
(\perp)[\perp] &=& \perp
%
%
\\[3ex]
& & \mbox{$\dagger$: independent map expression?}
\end{eqnarray*}
\caption{Database monotonicity analysis rules.}
\end{figure}

\pagebreak
\section{Type Specification}
\begin{tabular}[ht] {rcl}
identifier & = & \emph{string}\\
\\
column\_name &=& \`{}Qualified ( identifier, identifier )\\
&$\lvert$ & \`{}Unqualified ( identifier ) \\
\\
attribute\_identifier &=& column\_name\\
variable\_identifier &=& identifier\\
function\_identifier &=& identifier\\
type\_identifier &=& identifier\\
field\_identifier &=& identifier\\
relation\_identifier &=& identifier\\
state\_identifier &=& identifier\\
\\
field &=& ( field\_identifier, type\_identifier ) \\
\\
delta &=& \`{} Insert (relation\_identifier, [field]) \\
& $\lvert$ &  \`{} Delete (relation\_identifier, [field]) \\
\\
eterm &=& \`{}Int ( \emph{int} )\\
&$\lvert$ & \`{}Float ( \emph{float} )\\
&$\lvert$ & \`{}String ( \emph{string} )\\
&$\lvert$ & \`{}Long ( \emph{int64} )\\
&$\lvert$ & \`{}Attribute ( attribute\_identifier )\\
&$\lvert$ & \`{}Variable ( variable\_identifier )\\
\\
expression & =& \`{}ETerm ( eterm )\\
&$\lvert$ & \`{}UnaryMinus ( expression )\\
&$\lvert$ & \`{}Sum ( expression, expression )\\
&$\lvert$ & \`{}Product ( expression, expression )\\
&$\lvert$ & \`{}Minus ( expression, expression )\\
&$\lvert$ & \`{}Divide ( expression, expression ) \\
&$\lvert$ & \`{}Function ( function\_identifier, [expression] )\\
\\
meterm &=& \`{}Int ( \emph{int} )\\
&$\lvert$ & \`{}Float ( \emph{float} )\\
&$\lvert$ & \`{}String ( \emph{string} )\\
&$\lvert$ & \`{}Long ( \emph{int64} )\\
&$\lvert$ & \`{}Attribute ( attribute\_identifier )\\
&$\lvert$ & \`{}Variable ( variable\_identifier )\\
\\
aggregate\_function &=& \`{}Sum\\
&$\lvert$ & \`{}Min \\
&$\lvert$ & \`{}Max \\
\\
oplus &=& \`{}Plus \\
&$\lvert$ & \`{}Minus \\
&$\lvert$ & \`{}Min\\
&$\lvert$ & \`{}Max\\
&$\lvert$ & \`{}Decrmin (map\_expression)\\
\\
poplus &=& \`{}Union\\
&$\lvert$ & \`{}Diff\\
\\
\end{tabular}
\pagebreak

\begin{tabular}[ht] {rcl}
map\_expression &=& \`{}METerm ( meterm ) \\
&$\lvert$ & \`{}Sum ( map\_expression , map\_expression )\\
&$\lvert$ & \`{}Minus ( map\_expression,  map\_expression )\\
&$\lvert$ & \`{}Product ( map\_expression, map\_expression )\\
&$\lvert$ & \`{}Min ( map\_expression, map\_expression )\\
&$\lvert$ & \`{}Max ( map\_expression, map\_expression )\\
&$\lvert$ & \`{}MapAggregate ( aggregate\_function, map\_expression, plan )\\
&$\lvert$ & \`{}Delta ( delta,  map\_expression )\\
&$\lvert$ & \`{}New ( delta, map\_expression )\\
&$\lvert$ & \`{}Incr ( state\_identifier, oplus, map\_expression )\\
&$\lvert$ & \`{}Incrdiff ( state\_identifier, oplus, map\_expression )\\
&$\lvert$ & \`{}Init ( state\_identifier, oplus, map\_expression )\\
&$\lvert$ & \`{}Insert ( state\_identifier, meterm, map\_expression )\\
&$\lvert$ & \`{}Update ( state\_identifier, oplus, meterm, map\_expression )\\
&$\lvert$ & \`{}Delete ( state\_identifier, meterm )\\
&$\lvert$ & \`{}IfThenElse ( bterm, map\_expression, map\_expression ) \\
\\
bterm &=& \`{}True \\
&$\lvert$ & \`{}False \\
&$\lvert$ & \`{}LT ( expression,  expression )\\
&$\lvert$ & \`{}LE ( expression, expression )\\
&$\lvert$ & \`{}GT ( expression, expression )\\
&$\lvert$ & \`{}GE ( expression, expression )\\
&$\lvert$ & \`{}EQ ( expression, expression )\\
&$\lvert$ & \`{}NE ( expression, expression )\\
&$\lvert$ & \`{}MEQ ( map\_expression )\\
&$\lvert$ & \`{}MLT ( map\_expression )\\
\\
boolean\_expression &=& \`{}BTerm ( bterm )\\
&$\lvert$ & \`{}Not ( boolean\_expression )\\
&$\lvert$ & \`{}And ( boolean\_expression,  boolean\_expression )\\
&$\lvert$ & \`{}Or ( boolean\_expression,  boolean\_expression )\\
\\
plan &=& \`{}TrueRelation\\
&$\lvert$ & \`{}FalseRelation\\
&$\lvert$ & \`{}Relation ( relation\_identifier, [field] )\\
%&$\lvert$ & \`{}Rename ( [(attribute\_identifier, attribute\_identifier)], plan ) \\
&$\lvert$ & \`{}Select ( boolean\_expression, plan )\\
&$\lvert$ & \`{}Project ( [(attribute\_identifier, expression)], plan )\\
&$\lvert$ & \`{}Union ( [plan] )\\
&$\lvert$ & \`{}Cross ( plan , plan )\\
&$\lvert$ & \`{}NaturalJoin ( plan,  plan )\\
&$\lvert$ & \`{}Join ( boolean\_expression,  plan,  plan )\\
&$\lvert$ & \`{}DeltaPlan ( delta, plan )\\
&$\lvert$ & \`{}NewPlan ( delta, plan )\\
&$\lvert$ & \`{}IncrPlan ( state\_identifier, poplus, plan ) \\
&$\lvert$ & \`{}IncrDiffPlan ( state\_identifier, poplus, plan ) \\
\\
binding &=& \`{}BindExpr ( variable\_identifier,  expression )\\
&$\lvert$ & \`{}BindBoolExpr ( variable\_identifier,  boolean\_expression )\\
&$\lvert$ & \`{}BindMapExpr ( variable\_identifier, map\_expression ) \\
\\
\end{tabular}
\pagebreak

\begin{tabular}[ht] {rcl}
map\_identifier &=& identifier\\
code\_variable &=& variable\_identifier\\
\\
datastructure &=& \`{}Map ( map\_identifier, [field], type\_identifier )\\
&$\lvert$ & \`{}List ( relation\_identifier, [field] )\\
\\
map\_key &=& map\_identifier, [code\_variable] \\
map\_iterator &=& \`{}Begin (map\_identifier)\\
&$\lvert$ & \`{}End (map\_identifier)\\
\\
declaration &=& \`{}Variable ( code\_variable, type\_identifier )\\
&$\lvert$ & \`{}Relation ( relation\_identifier, [field] )\\ 
&$\lvert$ & \`{}Map ( map\_identifier, [field], type\_identifier )\\
\\
code\_terminal &=& \`{}Int ( \emph{int} )\\
&$\lvert$ & \`{}Float ( \emph{float} )\\
&$\lvert$ & \`{}String ( \emph{string} )\\
&$\lvert$ & \`{}Long ( \emph{int64} )\\
&$\lvert$ & \`{}Variable ( code\_variable )\\
&$\lvert$ & \`{}MapAccess ( map\_key )\\
&$\lvert$ & \`{}MapContains ( map\_key )\\
&$\lvert$ & \`{}MapIterator ( map\_iterator )\\
\\
arith\_code\_expression &=& \`{}CTerm ( code\_terminal )\\
&$\lvert$ & \`{}Sum ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}Minus ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}Product ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}Min ( arith\_code\_expression, arith\_code\_expression ) \\
&$\lvert$ & \`{}Max ( arith\_code\_expression, arith\_code\_expression ) \\
\\
bool\_code\_term &=& \`{}True \\
&$\lvert$ & \`{}False \\
&$\lvert$ & \`{}LT ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}LE ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}GT ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}GE ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}EQ ( arith\_code\_expression, arith\_code\_expression )\\
&$\lvert$ & \`{}NE ( arith\_code\_expression, arith\_code\_expression )\\
\\
bool\_code\_expression &=& \`{}BCTerm ( bool\_code\_term )\\
&$\lvert$ & \`{}Not ( bool\_code\_expression )\\
&$\lvert$ & \`{}And ( bool\_code\_expression, bool\_code\_expression )\\
&$\lvert$ & \`{}Or ( bool\_code\_expression, bool\_code\_expression )\\
\\
code\_expression &=& \`{}IfNoElse ( bool\_code\_expression, code\_expression )\\
&$\lvert$ & \`{}IfElse ( bool\_code\_expression, code\_expression, code\_expression )\\
&$\lvert$ & \`{}ForEach ( datastructure, code\_expression )\\
&$\lvert$ & \`{}Declare ( declaration )\\
&$\lvert$ & \`{}Assign ( code\_variable, arith\_code\_expression )\\
&$\lvert$ & \`{}AssignMap ( map\_key, arith\_code\_expression )\\
&$\lvert$ & \`{}EraseMap ( map\_key, code\_terminal )\\
&$\lvert$ & \`{}Eval ( arith\_code\_expression )\\
&$\lvert$ & \`{}Block ( [code\_expression] )\\
&$\lvert$ & \`{}Return ( arith\_code\_expression )\\
&$\lvert$ & \`{}Handler ( function\_identifier, [field], type\_identifier, [code\_expression] )\\
\end{tabular}
\pagebreak

\begin{tabular} {|c|c|c|}
\hline rule \# & status & location  \\
\hline \ref{eq:a1}$\sim$\ref{eq:a5} & complete & push\_delta \\
\hline \ref{eq:a6} & complete & checked implicitly in various locations of code, \\
&&need to explicitly check the condition to apply rule \ref{eq:a5}$\sim$ \ref{eq:a6}\\%
\hline \ref{eq:b1}$\sim$\ref{eq:b6} & complete & push\_delta\_plan\\
\hline \ref{eq:incr1} & incomplete & generate\_code/gc\_aux, matching for Sum only\\
\hline \ref{eq:incr2}$\sim$\ref{eq:incr4} & missing & (generate\_code)\\
\hline \ref{eq:sm1}$\sim$\ref{eq:sm2} & incomplete & translated to code\_expression directly at gc\_aux\\
\hline \ref{eq:sm3} & missing & (after adding `Delete, straight forward)\\
\hline \ref{eq:new1}$\sim$\ref{eq:new2} & complete & apply\_recompute\_rules\\
\hline \ref{eq:new3}$\sim$\ref{eq:new4} & complete & apply\_delta\_rules, apply\_recompute\_rules\\
\hline \ref{eq:newr1}$\sim$\ref{eq:newr3} & complete & apply\_recompute\_plan\_rules\\
\hline \ref{eq:newr4}$\sim$\ref{eq:newr6} & complete & apply\_delta\_plan\_rules, apply\_recompute\_plan\_rules\\
\hline \ref{eq:newr7} & complete & compile\_target\\
\hline \ref{eq:fs1}$\sim$\ref{eq:fs2} & complete & apply\_recompute\_rules\\
\hline \ref{eq:fs3}$\sim$\ref{eq:fs4} & complete & apply\_recompute\_plan\_rules\\
\hline \ref{eq:agg1} & complete & apply\_delta\_rules, apply\_recompute\_rules\\
\hline \ref{eq:agg2} & complete & apply\_recompute\_rules\\
\hline \ref{eq:agg3}$\sim$\ref{eq:agg9} & complete & apply\_recompute\_rules (needs testing for delete) \\
\hline \ref{eq:ags1}$\sim$\ref{eq:ags2} & complete & simplify \\
\hline \ref{eq:sum1}$\sim$\ref{eq:sum2} & complete & simplify\_map\_expr\_constants \\
\hline \ref{eq:sum3} & complete & simplify \\
\hline \ref{eq:sum4} & complete & simplify \\
\hline \ref{eq:sum5}$\sim$\ref{eq:sum7} & complete & simplify \\
\hline \ref{eq:min1} & missing & (possibly implement in compute\_initial\_values, implement for max)\\
\hline \ref{eq:min2} & complete & simplify \\
\hline \ref{eq:min3} & complete & simplify \\
\hline \ref{eq:min4} & partial & simplify, implement for max, and with all map bool expressions\\
\hline \ref{eq:min5} & partial & simplify, implement for max \\
\hline \ref{eq:min6} & missing & (simplify, similar to rule \ref{eq:sum4}, implement for min/max) \\
\hline \ref{eq:min7} & missing & (simplify, implement for min/max) \\
\hline \ref{eq:pred1} & complete & extract\_plan\_bindings (extend for multivariate monotonicity)\\
\hline \ref{eq:pred2} & incomplete & add support for `MGE, and extend is\_monotonic, extract\_plan\_bindings\\
\hline \ref{eq:pred3} & complete & extract\_expr\_bindings, extract\_map\_expr\_bindings\\
\hline \ref{eq:pred4} & complete & simplify \\
\hline \ref{eq:pred5} & complete & simplify \\
\hline \ref{eq:rs1} & complete & simplify \\
\hline \ref{eq:rs2} & complete & simplify \\
\hline \ref{eq:md1} & partial & maintain\_plan\_domains, extend to use `Insert, `Update\\
\hline \ref{eq:md2}$\sim$\ref{eq:md3} & partial & maintain\_plan\_domains, needs testing, and extend to use `Delete\\
\hline \ref{eq:md4}$\sim$\ref{eq:md5} & complete & generate\_code\\
\hline \ref{eq:md6}$\sim$\ref{eq:md7} & incomplete & generate\_code, if statement is missing \\
\hline \ref{eq:na1}$\sim$\ref{eq:na5} & missing & (not now, maintain\_plan\_domains) \\
\hline

\end{tabular}
\pagebreak

\section{Functions signatures}
\begin{enumerate}
  \item \emph{compile\_code m\_expr file\_name} : top level function to compile m\_expr with all possible events(insert/delete) and generate "$<$filename$>$.cc" file. This will call compile\_target\_all to apply all rules to m\_expr and call generate\_code to translate applied m\_expr to IR. Then lastly call translate to print out output to "$<$filename$>$.cc" using IR.
(val compile\_code :  map\_expression $\rightarrow$ string $\rightarrow$ unit )
    \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] map\_expression to compile 
          \item[file\_name] output file name 
        \end{description}
      \item[Returns] : ()
    \end{description}
    
  \item \emph{compile\_target\_all m\_expr} : First, this will call generate\_all\_events to find out all events related to m\_expr. Then recursively call compile\_target to compile m\_expr with individual event(insert, delete). This will return list of compiled m\_expr with bindings list, and list of state id and type.\\
(val compile\_target\_all : map\_expression $\rightarrow$ (delta * map\_expression * binding list) list * (string * string) list )
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] map\_expression to compile 
        \end{description}
      \item[Returns] : [ (delta, map\_expression, [binding list])], [(string, string)]
    \end{description}
    
  \item \emph{generate\_code [(delta, m\_expr, binding)] [(sid, stype)]} : translate map expression into IR\\
  (val generate\_code : (delta * map\_expression * binding list) list $\rightarrow$ (string * string) list $\rightarrow$ code\_expression list * code\_expression)
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[delta] event
          \item[m\_expr] map expression
          \item[binding] list of bindings
          \item[sid] state id
          \item[stype] type of state
        \end{description}
      \item[Returns] : ([code\_expression], [code\_expression]) list of declarations and handler codes
    \end{description}
    
  \item \emph{translate global\_decls handler file\_name} : print out generated C code to $<$file\_name.cc$>$\\
  (val translate : code\_expression list $\rightarrow$ code\_expression list $\rightarrow$ string $\rightarrow$ () \;)
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[global\_decls] : global declarations generated during compilation. usually maps and lists
          \item[handler] : code expression of generated handlers
          \item[file\_name] : file to write 
        \end{description}
      \item[Returns] : ()
    \end{description}
    
  \item \emph{compile\_target m\_expr event states} : compile m\_expr on single ``event''.  Extract bindings first using rule \ref{eq:pred1}-\ref{eq:pred2}. Then apply ``new'' to m\_expr and 
 apply delta rules. Then simplify the result. 	\\
  (val compile\_target : map\_expression $\rightarrow$ delta $\rightarrow$ %check later
  (string * m\_expr) list $\rightarrow$ map\_expression * binding list * (string * map\_expression) list
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] map\_expression to compile
          \item[event] Insert/delete
          \item[states] list of (string, m\_expr). currently existing maps 
        \end{description}
      \item[Returns] : (map\_expression, [binding], [(string, map\_expression)] compiled map\_expression with bindings and maps
    \end{description}
    
  \item \emph{extract\_map\_expr\_bindings m\_expr} : extracts bindings from m\_expr using rule \ref{eq:pred1}-\ref{eq:pred2} and returns extracted m\_expr and list of bindings\\
  (val extract\_map\_expr\_bindings : map\_expression $\rightarrow$ map\_expression * (binding list)
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] : map expression to extract bindings 
        \end{description}
      \item[Returns] : map\_expression * (binding list)
    \end{description}
    
  \item \emph{apply\_recompute\_rules m\_expr event} : apply ``new'' to m\_expr with event(insert/delete)\\
  (val apply\_recompute\_rules : map\_expression $\rightarrow$ delta $\rightarrow$ map\_expression)
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] : map expression to apply ``new''
          \item[event] : event. either insert or delete
        \end{description}
      \item[Returns] : map\_expression  
    \end{description}

  \item \emph{apply\_delta\_rules m\_expr rcs} : apply delta rules to m\_expr\\
  (val apply\_delta\_rules : test option $\rightarrow$ map\_expression $\rightarrow$ map\_expression)
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] : map expressino to apply delta rules
          \item[rcs] : test option 
        \end{description}
      \item[Returns] : map\_expression
    \end{description}

  \item \emph{simplify m\_expr rewrites} : bottom up map expression rewriting\\
  (val simplify : map\_expression $\rightarrow$ accessor\_element list $\rightarrow$ map\_expression)
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[m\_expr] map expression to simplify 
          \item[rewrites] list of rewrites 
        \end{description}
      \item[Returns] : map\_expression
    \end{description}

  \item \emph{function signature} : 
      \begin{description}
      \item[Parameters] :
        \begin{description}
          \item[param] 
        \end{description}
      \item[Returns] : 
    \end{description}

\end{enumerate}



\pagebreak
\section{Vwap, Linearroad}
\begin{eqnarray*}
q[] &:=&
\algsumf_{P_2 * V_2}(\sigma_{m(P_2) > 0} (\rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:pred1})}{=}&
\algsumf_{P_2 * V_2}(\sigma_{P_2 > P_{min}[]} (\rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:pred3})}{=}&
\algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2, V_2}(B)))[c=P_{min}[]]
\\
\algnew_{+B(p,v)} q[]
&\stackrel{(\ref{eq:newr7})}{:=}&
(\algnew_{+B(p,v)}
\algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2, V_2}(B))))
[c=\algnew_{+B(p,v)} P_{min}[]]
\\
&\stackrel{(\ref{eq:agg2})}{=}&
(\algincr_{q'} \Delta_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B))))
[c=\algnew_{+B(p,v)} P_{min}[]]
\\
&\stackrel{(\ref{eq:md4})}{=}&\algfor(\mbox{$c$}) \; \{ \\
&&\quad \mathrm{ignore}((\algupdate_{+, q'[c]} \Delta_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B))))[c]) \; \};
\\
&& rc = \algnew_{+B(p,v)} P_{min}[];
\\
&& \mbox{if ($q'$.find($rc$) = $q'$.end)}
\; \{\\
&&\quad \mathrm{ignore}((\alginsert_{q'[rc]} \algnew_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B))))[rc]) \; \};
\\
&& q'[rc]
\\
\end{eqnarray*}
%update...
\begin{eqnarray*}
\algupdate_{+, q'[c]} \Delta_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B)))
&\stackrel{(\ref{eq:a6})}{=}&
\algupdate_{+, q'[c]} \algsumf_{P_2 * V_2}(\Delta_{+B(p,v)} \sigma_{P_2 > c} (\rho_{P_2, V_2} (B)))
\\
&\stackrel{(\ref{eq:b6})}{=}&
\algupdate_{+, q'[c]} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\Delta_{+B(p,v)} \rho_{P_2, V_2} (B)))
\\
&\stackrel{(\ref{eq:b1})}{=}&
\algupdate_{+, q'[c]} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\pi_{p\rightarrow P_2, v\rightarrow V_2}\{\tuple{}\}))
\\
&\stackrel{(\ref{eq:rs1})}{=}&
\algupdate_{+, q'[c]} \algsumf_{P_2 * V_2}(\pi_{p\rightarrow P_2, v\rightarrow V_2} (\sigma_{p > c} \{\tuple{}\}))
\\
&\stackrel{(\ref{eq:ags1})}{=}&
\algupdate_{+, q'[c]} \algsumf_{p * v} (\sigma_{p > c} \{\tuple{}\})
\\
&\stackrel{(\ref{eq:sm2})}{=}&
q'[c] \leftarrow q'[c] + \algsumf_{p * v} (\sigma_{p > c} \{\tuple{}\});\; q'[c]
\\
\end{eqnarray*}
%new P_min...
\begin{eqnarray*}
\algnew_{+B(p,v)} P_{min}[] &:=&
\algnew_{+B(p,v)} \algmin_{P_2}(\sigma_{m(P_2) > 0} (\rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:agg6})}{=}&
\algincr_{\min, P_{min}[]} \delta_{+B(p,v)} \algmin_{P_2}(\sigma_{m(P_2) >0} (\rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:agg5})}{=}&
\algincr_{\min, P_{min}[]} \algmin_{P2} (\algincr_{\cup, S_Q} \Delta_{+B(p,v)} \sigma_{m(P_2) >0} (\rho_{P_2, V_2}(B)))\;)
\\
&\stackrel{(\ref{eq:b6})}{=}&
\algincr_{\min, P_{min}[]} \algmin_{P2} (\algincr_{\cup, S_Q} \sigma_{m(P_2) >0} (\Delta_{+B(p,v)} \rho_{P_2, V_2}(B)))
\\
&\stackrel{(\ref{eq:b1})}{=}&
\algincr_{\min, P_{min}[]} \algmin_{P2} (\algincr_{\cup, S_Q} \sigma_{m(P_2) >0} (\pi_{p \rightarrow P_2, v \rightarrow V_2} \{\tuple{}\}))
\\
&\stackrel{(\ref{eq:rs1})}{=}&
\algincr_{\min, P_{min}[]} \algmin_{P2} (\algincr_{\cup, S_Q} \pi_{p \rightarrow P_2, v \rightarrow V_2} (\sigma_{m(p) >0} \{\tuple{}\}))
\\
&\stackrel{(\ref{eq:incr2})}{=}&
\algincr_{\min, P_{min}[]} \algmin_{P2} ( (S_Q \leftarrow S_Q \cup \pi_{p \rightarrow P_2, v \rightarrow V_2} (\sigma_{m(p) >0} \{\tuple{}\});\;S_Q))
\\
&\stackrel{(\ref{eq:agg4})}{=}&
P_{min}[] \leftarrow \algmin(P_{min}[], \algmin_{P2} ( (S_Q \leftarrow S_Q \cup \pi_{p \rightarrow P_2, v \rightarrow V_2} (\sigma_{m(p) >0} \{\tuple{}\});\;S_Q))\;);\;P_{min}[]
\\
\end{eqnarray*}
%insert
\begin{eqnarray*}
\alginsert_{q'[rc]} \algnew_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B))
&\stackrel{(\ref{eq:agg2})}{=}&
\alginsert_{q'[rc]} \algincr_{+, S} \Delta_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B)))
\\
&\stackrel{(\ref{eq:a6})}{=}&
\alginsert_{q'[rc]} \algincr_{+, S} \algsumf_{P_2 * V_2}(\Delta_{+B(p,v)} \sigma_{P_2 > c} (\rho_{P_2 , V_2}(B)))
\\
&\stackrel{(\ref{eq:b6})}{=}&
\alginsert_{q'[rc]} \algincr_{+, S} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\Delta_{+B(p,v)} \rho_{P_2 , V_2}(B)))
\\
&\stackrel{(\ref{eq:b1})}{=}&
\alginsert_{q'[rc]} \algincr_{+, S} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\pi_{p \rightarrow P_2, v \rightarrow V_2} \{\tuple{}\} ))
\\
&\stackrel{(\ref{eq:rs1})}{=}&
\alginsert_{q'[rc]} \algincr_{+, S} \algsumf_{P_2 * V_2}(\pi_{p \rightarrow P_2, v \rightarrow V_2} (\sigma_{p > c} \{\tuple{}\} ))
\\
&\stackrel{(\ref{eq:ags1})}{=}&
\alginsert_{q'[rc]} \algincr_{+, S} \algsumf_{p * v}(\sigma_{p > c} \{\tuple{}\} )
\\
&\stackrel{(\ref{eq:incr1})}{=}&
\alginsert_{q'[rc]} (S \leftarrow S + \algsumf_{p * v}(\sigma_{p > c} \{\tuple{}\} );\;S)
\\
&\stackrel{(\ref{eq:sm1})}{=}&
\mbox{if ($rc \notin keys(q')$)} \\
&&\quad
\mbox{$q'$.insert($rc$, $(S \leftarrow S + \algsumf_{p * v}(\sigma_{p > c} \{\tuple{}\} );\;S))$}
\\&&q'[rc] 
\\
%here i am
\end{eqnarray*}
Finally,
%final...
\begin{eqnarray*}
\algnew_{+B(p,v)} q[]
&=&\algfor(\mbox{$c$}) \; \{ \\
&&\quad \mathrm{ignore}((\algupdate_{+, q'[c]} \Delta_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B))))[c]) \; \};
\\
&& rc = \algnew_{+B(p,v)} P_{min}[];
\\
&& \mbox{if ($q'$.find($rc$) = $q'$.end)}
\; \{\\
&&\quad \mathrm{ignore}((\alginsert_{q'[rc]} \algnew_{+B(p,v)} \algsumf_{P_2 * V_2}(\sigma_{P_2 > c} (\rho_{P_2 , V_2}(B))))[rc]) \; \};
\\
&& q'[rc]
\\
&=&\algfor(\mbox{$c$}) \; \{ \\
&&\quad \mathrm{ignore}((q'[c] \leftarrow q'[c] + \algsumf_{p * v} (\sigma_{p > c} \{\tuple{}\});\; q'[c])) \; \};
\\
&& rc = ( P_{min}[] \leftarrow \algmin(P_{min}[], \algmin_{P2} (S_Q \leftarrow S_Q \cup \pi_{p \rightarrow P_2, v \rightarrow V_2} (\sigma_{m(p) >0} (\{\tuple{}\});S_Q);\;P_{min}[])
\\
&& \mbox{if ($q'$.find($rc$) = $q'$.end)}
\; \{\\
&&\quad \mathrm{ignore}((\mbox{if ($rc \notin keys(q')$)}  
\mbox{ $q'$.insert($rc$, ($S \leftarrow S + \algsumf_{p * v}(\sigma_{p > c} (\{\tuple{}\} ));\;S)\;);$}\;q'[rc])) \; \};
\\
&& q'[rc]
\\
\end{eqnarray*}

\pagebreak
Linearroad example.
\begin{eqnarray*}
q &:=& \algmin_{ID} (\sigma_{\substack{ID2 <> ID \;\wedge\; LANE2 = LANE \;\wedge\;\\ TIME2 >= TIME \;\wedge\; TIME2 <= TIME + 30 \;\wedge\; \\ID11 = ID \;\wedge\; LANE11 = LANE \;\wedge\; \\TIME11 = TIME + 120 \;\wedge\; ID22 = ID2 \;\wedge\;\\ LANE22 = LANE2 \;\wedge\; TIME22 = TIME2 + 110}} \left(\begin{array}{cc}A \times \rho_{ID2, LANE2, TIME2}(A) \times\\ \rho_{ID11, LANE11, TIME11}(A) \times \rho_{ID22, LANE22, TIME22}(A)\end{array}\right)
\\
\algnew_{+A(id, lane, time)}q &:=&
\algnew_{+A(id, lane, time)} \algmin_{ID} (\sigma_{\dots} \left(\begin{array}{cc}A \times \rho_{ID2, LANE2, TIME2}(A) \times\\ \rho_{ID11, LANE11, TIME11}(A) \times \rho_{ID22, LANE22, TIME22}(A)\end{array}\right)
\\
&\stackrel{(\ref{eq:agg6})}{=}&
\algincr_{min, S} \delta_{+A(id, lane, time)} \algmin_{ID} (\sigma_{\dots} \left(\begin{array}{cc}A \times \rho_{ID2, LANE2, TIME2}(A) \times\\ \rho_{ID11, LANE11, TIME11}(A) \times \rho_{ID22, LANE22, TIME22}(A)\end{array}\right)
\\
&\stackrel{(\ref{eq:agg5})}{=}&
\algincr_{min, S} \algmin_{ID} (\algincr_{\cup, S_Q} \Delta_{+A(id, lane, time)} (\sigma_{\dots} (A \times \rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A))))
\\
&\stackrel{(\ref{eq:b6})}{=}&
\algincr_{min, S} \algmin_{ID} (\algincr_{\cup, S_Q} \sigma_{\dots} (\Delta_{+A(id, lane, time)} (A \times \rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A))))
\\
&\stackrel{(\ref{eq:b5})}{=}&
\algincr_{min, S} \algmin_{ID} (\algincr_{\cup, S_Q} \sigma_{\dots} (
(\Delta_{+A(id, lane, time)} A \times \rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad
( A \times \Delta_{+A(id, lane, time)}\rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad
( A \times \rho_{2}(A) \times \Delta_{+A(id, lane, time)} \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad
( A \times \rho_{2}(A) \times \rho_{11}(A) \times \Delta_{+A(id, lane, time)}\rho_{22}(A))
))
\\
%
&\stackrel{(\ref{eq:b1})}{=}&
\algincr_{min, S} \algmin_{ID} (\algincr_{\cup, S_Q} \sigma_{\dots} (
(\pi_{id \rightarrow ID, lane \rightarrow LANE, time \rightarrow TIME}\{\tuple{}\} \times \rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad 
( A \times \pi_{id \rightarrow ID2, lane \rightarrow LANE2, time \rightarrow TIME2}\{\tuple{}\} \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad
( A \times \rho_{2}(A) \times \pi_{id \rightarrow ID11, lane \rightarrow LANE11, time \rightarrow TIME11}\{\tuple{}\} \times \rho_{22}(A))\cup
\\&&\quad
( A \times \rho_{2}(A) \times \rho_{11}(A) \times \pi_{id \rightarrow ID22, lane \rightarrow LANE22, time \rightarrow TIME22}\{\tuple{}\})
))
\\
%
&=&
\algincr_{min, S} \algmin_{ID} (\algincr_{\cup, S_Q} \sigma_{\dots}
(\pi_{id \rightarrow ID, lane \rightarrow LANE, time \rightarrow TIME}\{\tuple{}\} \times \rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad 
\sigma_{\dots}( A \times \pi_{id \rightarrow ID2, lane \rightarrow LANE2, time \rightarrow TIME2}\{\tuple{}\} \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad
\sigma_{\dots}( A \times \rho_{2}(A) \times \pi_{id \rightarrow ID11, lane \rightarrow LANE11, time \rightarrow TIME11}\{\tuple{}\} \times \rho_{22}(A))\cup
\\&&\quad
\sigma_{\dots}( A \times \rho_{2}(A) \times \rho_{11}(A) \times \pi_{id \rightarrow ID22, lane \rightarrow LANE22, time \rightarrow TIME22}\{\tuple{}\})
))
\\
%
&\stackrel{(\ref{eq:rs1})}{=}&
\algincr_{min, S} \algmin_{ID} (\algincr_{\cup, S_Q} 
\\&&\quad
(\pi_{id \rightarrow ID, lane \rightarrow LANE, time \rightarrow TIME} 
(\sigma_{\substack{ID2 <> id \;\wedge\; LANE2 = lane \;\wedge\;\\ TIME2 >= time \;\wedge\; TIME2 <= time + 30 \;\wedge\; \\ID11 = id \;\wedge\; LANE11 = lane \;\wedge\; \\TIME11 time + 120 \;\wedge\; ID22 = ID2 \;\wedge\;\\ LANE22 = LANE2 \;\wedge\; TIME22 = TIME2 + 110}} 
(\{\tuple{}\}\times \rho_{2}(A) \times \rho_{11}(A) \times \rho_{22}(A)))\cup
\\&&\quad 
(\pi_{id \rightarrow ID2, lane \rightarrow LANE2, time \rightarrow TIME2}
(\sigma_{\substack{id <> ID \;\wedge\; lane = LANE \;\wedge\;\\ time >= TIME \;\wedge\; time <= TIME + 30 \;\wedge\; \\ID11 = ID \;\wedge\; LANE11 = LANE \;\wedge\; \\TIME11 = TIME + 120 \;\wedge\; ID22 = id \;\wedge\;\\ LANE22 = lane \;\wedge\; TIME22 = time + 110}}
( A \times \{\tuple{}\} \times \rho_{11}(A) \times \rho_{22}(A))\cup
\\&&\quad
(\pi_{id \rightarrow ID11, lane \rightarrow LANE11, time \rightarrow TIME11}
(\sigma_{\substack{ID2 <> ID \;\wedge\; LANE2 = LANE \;\wedge\;\\ TIME2 >= TIME \;\wedge\; TIME2 <= TIME + 30 \;\wedge\; \\id = ID \;\wedge\; lane = LANE \;\wedge\; \\time = TIME + 120 \;\wedge\; ID22 = ID2 \;\wedge\;\\ LANE22 = LANE2 \;\wedge\; TIME22 = TIME2 + 110}}
( A \times \rho_{2}(A) \times \{\tuple{}\} \times \rho_{22}(A))\cup
\\&&\quad
(\pi_{id \rightarrow ID22, lane \rightarrow LANE22, time \rightarrow TIME22}
(\sigma_{\substack{ID2 <> ID \;\wedge\; LANE2 = LANE \;\wedge\;\\ TIME2 >= TIME \;\wedge\; TIME2 <= TIME + 30 \;\wedge\; \\ID11 = ID \;\wedge\; LANE11 = LANE \;\wedge\; \\TIME11 = TIME + 120 \;\wedge\; id = ID2 \;\wedge\;\\ lane = LANE2 \;\wedge\; time = TIME2 + 110}}
( A \times \rho_{2}(A) \times \rho_{11}(A) \times \{\tuple{}\})
)
)
\\
\end{eqnarray*}
\end{document}
