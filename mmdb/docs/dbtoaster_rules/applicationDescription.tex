%\documentclass{acm_proc_article-sp} 
\documentclass[11pt]{article} 
\usepackage{amssymb,amsmath} 
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}


\floatstyle{ruled}
\newfloat{code}{thp}{lop}
\floatname{code}{Code}

%\DeclareGraphicsExtensions{.eps}

\begin{document}
	
\title{DBToaster Runtime: System for Streaming Data Processing.}
\author{}
\maketitle

\section{Introduction}

DBToaster application involves three major components. Data Sources components are a source of the incoming data. The end user applications need these data to be processed by running various queries over it. In this particular example we will be using an Exchange Simulation Server application as a data source. Next component is the Algorithms Simulation Engine. This component is the end user program of interest. It is responsible for the decision making and outside influences (i.e. what ever user needs to be done with the help of the queries over the data streams). In out example it is a Trading Runtime Platform. The last component is DBToaster Runtime. The component is responsible for collecting the data from various data sources specified by the users, running appropriate queries over the data and conveying the query results to Algorithms Simulation Engine. 

The the flow of information between the three components is as follows. Once started data generation component generates data, these data comes from a variety of sources stock exchange, sensor network, remote applications etc. The data comes as a continuous stream of information, this information is presented in a well known format. In many of the cases it is possible that the end user does not have much control over the data stream but the ability to listen to the incoming data. These data is sent to DBToaster runtime. The runtime is responsible for collecting data from those data sources and running a dynamic set of user defined queries over these data. The queries are dynamically loaded, compiled and if needed removed during the execution of a runtime. The results of the queries are forwarded to Algorithms Simulation Engine (a.k.a the end user). The Engine's job is to get the data from the runtime. Based on the results of the queries Algorithm Engine performs tasks needed by the users. In our example, based on the information received Algorithm Engine buys and sell stocks on a NASDAQ exchange simulator. 

The particular application we have chosen to demonstrate the capabilities and performance of our system is a NASDAQ trading simulation. In this simulation there is a set of servers; each server arranges stock exchanges between different trading parties. The results of those exchanges as well as information about interest in stock sells and purchases is transmitted to all parties interested in such information. Based on these information different trading algorithms decide to buy and sell stocks. The arrangement of all the components in the Trading system can be seen in figure \ref{TheBigPicture}. 

\begin{figure}
  \includegraphics[width=4.50in]{finapp.pdf}
  \caption{Application Overview.}
  \label{TheBigPicture}
\end{figure}

%description of particularities of the system


\section{DBToaster Runtime}

DBToaster Runtime consists of three major components: Compiler, Query Processing and Data Sources Processing. Each of these components interuct with each other and has external interaction. The complete representation of the DBToaster Runtime can be found if figure \ref{DBToasterPic}. Compiler and Query Processing use a server connection for clients to send them relevant data. Data Source Processing creates user specified clients to receive the data from various data sources. Compiler receives requests from the client to instantiate a Data Source reader to receive data for some query. The the created reader is passed to the Data Source Processing

\begin{figure}
  \includegraphics[width=4.50in]{DBToasterRuntime.pdf}
  \caption{DBToaster Structure.}
  \label{DBToasterPic}
\end{figure}

\subsection{Compiler}

Compiler consists of several components. Its structure can be seen in figure \ref{CompilerPicture}. The major two components are SQL query pre-compiler and C++ code compiler. 

Compiler is a starting point for all user interactions in the DBToaster Runtime. Once Runtime is up and running the user initiates the contact by specifying that it needs to execute a query on some specific set of data sources. The query, types and parameters of data sources are sent to User Input Handler. It collects the information in a structured format and passes it to the Compiler Admin. Compiler Admin converts an SQL query to C++ code and C++ code to binary format. The query is then passed to the Query Processing Admin to be added to the list of active queries. If the user asks to add a Data Source Reader. The Reader of a specified type is created and passed to the Data Source Admin to be added to the list of active Readers. 

\begin{figure}
  \includegraphics[width=4.50in]{compiler.pdf}
  \caption{Compiler Structure.}
  \label{CompilerPicture}
\end{figure}

\subsubsection{User Input Handler}
The server is implemented as a part of the handler. Once client is connected to the Input Handler server it sends a type of request and attributes of the request.
\\
\\
\begin{tabular}{|l|l|}
  \hline
  Type & Information \\ \hline
  Query & Query Source \\ \hline
  Connection & Connection Type, Connection Information \\ \hline
\end{tabular}
\\

The type of request is either to add a query to be run on a set of data sources or a data reader to be added list of active Data Readers.
\\*
The query addition request will look as follows:

\begin{code}
  \begin{verbatim}
AddRequest(type=query, Source=SQLSourceFile,
     DataReaders=listOfDataReaders for Query);
  \end{verbatim}
  \caption{User Add Query request to Input Handler.}
\end{code}

The source addition request:

\begin{code}
  \begin{verbatim}
AddRequest(type=dataSource, sourceType=socket/file,
     specification=IP_port/file_name);
  \end{verbatim}
  \caption{User Add Data Source request to Input Handler.}
\end{code}


\subsubsection{Compiler Admin}

Once the user request is receives the Compiler admin takes over. It the request is to add a SQL query to the list then Admin takes user request and asks SQL Compiler to produce a C++ code out of it. Once the code is produced the Admin asks C++ compiler to make a binary code out of it. Then admin loads the code to memory and send a new query together with a list of Data Readers to Query Processing Admin and Data Sources Processing Admin respectively.

\subsubsection{SQL Compiler}

SQL complier takes an SQL query from a file and creates an optimized a C++ coded to be added to the runtime. The file name containing the code is returned to the Admin.

\subsubsection{C++ Compiler}

C++ compiler takes C++ code of an SQL query. The code is in a .cpp file and is given by the Admin to the compiler. The C++ compiler creates a binary code version of the code and returns it to Admin. \emph{not sure about the return form}

\subsection{Data Source Processing}

Data Source Processing is done in series of steps. Once Data Sources Admin receives a function handle from Compiler Admin. The handle is inserted into a Collection of Data Readers. Each reader gets the data stream from outside. The Data Readers Thread Pool is a collection of threads where each thread picks a Data Reader and executes a read at a time for one of them at a time. Once read is done the results of the read are forwarded to a Data Structure Dispatch. The Dispatch in turn forwards the data to Query Processing, in particular to the Ready Data Queue. The more pictorial description can be found in figure \ref{DataSourcePic}.

% processing consists of the list of list of stream points. Each point is given by the user and signifies a way for a DBToaster to connect with the input stream of some process which dispatches data to the DBToaster. Each Stream Point is written by the user and user can fully specify how the data should be received and processed. Stream point is responsible for sending data to the Data Dispatch unite in a pre-specified format. The structure for data source processing can be found in figure 

\begin{figure}
  \includegraphics[width=5.00in]{DataSources.pdf}
  \caption{Data Sources Management.}
  \label{DataSourcePic}
\end{figure}

\subsubsection{Data Sources Admin}

Data Sources Admin receives a function handle to a data reader from a Compiler. Admin locks the Collection and a handle is inserted into a Collection of Data Readers. Collection of Data Readers is a queue of function handles. Each handle implements a method \emph{readNext()} for reading data from some data source (typically a socket or a file).  \emph{TODO: I think we need a way for users to specify a method for converting read data to a predefined structure.}

\subsubsection{Data Readers Thread Pool}

Data Readers Thread Pool is a collection of identical threads. Each thread is responsible for getting a reader from the queue of Collection of Data Readers, executing a \emph{readNext()} message, collecting the message and putting it into Data Structures Dispatch. \emph{TODO talk more about exact message sent to a Dispatch i.e how is the data structure is handled.}

\subsubsection{Data Structures Dispatch}

Data Structures Dispatch receives an ID identifying each Data Reader and a message read by the reader. Based on the ID of the reader the message is then sent to an appropriate set of queues in the Data Queue for Processing. 



\subsection{Query Processing}

Query Processing is done with a set of Query Threads each thread picks a query-datum pair from a pool of available pairs and processes it. As data comes in after been processed it is sent to the appropriate query. As soon as the query receives a datum it becomes available for execution. The structure for query processing can be found in figure \ref{QueryProcessingPic}.

\begin{figure}
  \includegraphics[width=5.00in]{QueryProcessing.pdf}
  \caption{Query Processing Management.}
  \label{QueryProcessingPic}
\end{figure}

\subsubsection{Query Admin}

Query Admin receives a function handle to query as well as the identify as to where the query output has to be sent to. Once the handle is received Admin locks Query Register and inserts the query there, then Query Results pool is lock and updated to have an output queues for just inserted query. Finally Admin locks Data Queue for Processing and inserts and additional queue for data associated with the query. 

Query Register is a map with the query ID and a handler for that query. 

\subsubsection{Data Queue for Processing}

This is a collection of queues. Each queue in the collection corresponds to the query that can run data items in the queue. When Data Queue for Processing receives a new item, from Data Structures Dispatch, together with the ID for which query this item belongs. It adds it to the appropriate queue for that query. If the query queue is empty then the Query-Datum Available queue is checked to see if the query is currently running. If the query is running the item is inserted into queue. If it is not running then the method for putting datum and a query handle is invoked and a pair is put on the queue of queries awaiting the execution.

\subsubsection{Query Processing Thread Pool}

Query Processing Thread Pool is a set of identical threads. Each thread is responsible for picking up and item from Query-Datum Available Queue. Then thread runs a query on a given datum. The results are put into a Query Results pool into a set of queues for the users which are interested in the results of this query. 

\subsubsection{Query Results Pool}

Query Results Pool implements a server, where each client upon connection indicates a set of queries they are interested in. The server creates a map of query IDs and query result queues for each client. When a query produces an output, it is sent to the Results Pool. In the Result Pool the query results are dispatched to the appropriate queues. When a client needs a new piece of information it sends a request to the server with the ID of a query it is interested in and the number of tuples it needs. Server returns the results of the query indicated by the ID and the tuples it produced. 

\section{Data Generation}

Data can come in a variety of forms. For our particular application we have developed an Exchange Simulation Server. The server is responsible for processing and broadcast of all stock exchanges to the clients that are connected to it. Server can also is capable to augment data flow by adding data from files containing historical traces of real stock exchanges. At the moment the Exchange Server designed to simulate trade exchanges for one stock.   

\subsection{Exchange Server Simulator}
ExchangeServer creates server port and handles all incoming client connections. Each connected client is given it's own thread (ExchangeThread). ExchangeServer also creates a DataThread, which is responsible for reading historic trace data. The server also creates structure for datastorage which is shared by all of the clients.

\begin{code}
  \begin{verbatim}
Server_socket;
SynchronizedBooks DataBook;
Data_socket(inputDataFile.cvs);

while (Server_socket.listen)
{
	get(client);
	run(client, DataBook);
}
  \end{verbatim}
  \caption{ExchangeServer: inputDataFile.cvs}
\end{code}



\subsection{Exchange Thread}
On a client connection Server creates an ExchangesThread to deal with client needs. All ExchangesThreads share data storage structure DataBook as well as a list of all currently active clients. On a start up thread expects to receive a message from a client indicating the type of a client.
\\
\\
\begin{tabular}{|l|l|}
  \hline
  \multicolumn{2}{|c|}{Client type} \\
  \hline
  0 & Interactive\\ \hline
  1 & Passive Listener \\
  \hline
\end{tabular}
\\
\\*
\emph{Interactive} clients send data and are only interested in receiving messages in response to their transactions. \emph{Passive Listener} clients are interested in all of the transactions but tend not to send the messages themselves.

The messages from clients are coming in the pre-specified format. Depending on the client's request several actions occur:
\\
\\
\begin{tabular}{|l|l|}
  \hline
  Request & Action \\ \hline
  'B' & buy request, check ask book for match if no add to bid book \\ \hline
  'S' & see request, check bid book for match if no add to ask book \\ \hline
  'D' & delete request from appropriate book if one exists \\ \hline
  'X' & cancel order remove trade request from appropriate book\\
  \hline
\end{tabular}
\\
\\
Each transaction is announced to all Passive Listeners as well as to Interactive client which intiated the transaction. 

% the first  message showing an interest in exchange ExchangesThread checks if there is an appropriate match in the data structures (i.e. if some one wants to sell some amount of stocks the thread will look if someone wants to buy stocks at the given price), if so the match is executed if not the request is stored in the data structures. The results and the transaction are announced to all the connected clients. 

\subsection{Data Storage}
SynchronizedBooks is a shared data structure. It is shared between all of the clients. Each client can modify it by adding/removing buy/sell requests. The data structure consists of two SortedBooks. Each SortedBook is a structure that has properties of a sorted set and a hashtable. 

When an addition of a sell/buy request is invoked data structure tries to find a matching buy/sell request and if found the update message is sent to the clients additionally to the original sell/buy request. The update message contains information about the fact that one or both of the orders are partially/fully satisfied. The exchange message is of the form:
\\
\\
\begin{tabular}{|l|l|}
  \hline
  Request & Action \\ \hline
  'E' & order number, update amount \\ \hline
  'F' & order was executed in full \\

  \hline
\end{tabular}
\\

\subsection{Data Generation}

ExchangeServer is capable of augmenting the data flow between clients with the additional data from historical data files. To accomplish this goal server has a DataThread. It can be initiated at any point by a server (for example, once there is a client connected to the server). DataThread reads a historical trace file in a .cvs format and transmits each message to the server as if it was a real request.


\section{Algorithms Engine}

Algorithm Engine code developed by the end users. The code makes use of DBToaster Runtime to query the continuous data from input streams specified by the users. The query results are then processed by user defined algorithms to achieve their goals. 

In our example Algorithmic Engine creates and runs a set of monitoring queries for the stock trading depending on the results of the queries and the internal mechanics - algorithms decide to buy or sell stocks on a NASDAQ Trading Exchange Simulator.

\subsection{Data Sources}

Algorithmic Engine interacts with environment in three different ways. First of all the Engine needs to receive  the information from from DBToaster runtime. This interaction is unavoidable since the Engine needs the results of the queries. Another interaction which needs to be added is the way to specify the information stream received by a DBToaster runtime. This information needs to be passed the the Runtime in the form of c++ code for the Runtime to compile. Another optional source of interaction is infulencing the enviroment. In our example is the Engine's capability to add/remove stock requests from the Exchange Server. 

\subsubsection{Data Stream}

There are two interactions with outside systems needed to be implemented by the user. The first interaction is with DBToaster. A system needs to pull information from the DBToaster runtime. \emph{TODO description of the the pulling mechanism}.

Another interaction, which needs to be passed to the DBToaster Runtime, is a way for Runtime to access the data streams relevant to the Engine and over which the queries needed to be post. This information is specified as a C++ code which is sent for the compilation to the Runtime to be added to the system.

\subsubsection{External Influence}

If the Engine implements interactive process, which needs to access outside processes or interact (influence) them then this is interactivity needs also to be added. In our example Algorithmic Engine can buy and sell stock on our Exchange Simulation Server. Thus acting like one of the clients of the server. \emph{TODO describe the system in more details}

\subsection{Algorithm}

This is the part which is the most relevant to the user and will vary from system to system. In out example we encoded the learning and trading strategies for NASDAQ stock exchange. \emph{TODO describe the system in more details}

\subsection{Query creator (or something like that)}

Queries posed to the DBRuntime can come from various sources they can either be predefined by the user system or written and modified dynamically. In order to be active they need to be passed to the Runtime where they are compiled and added to stream observations. \emph{TODO describe the process more}



\end{document}





