\section{Map Calculus}
\def\Dom{\mathrm{Dom}}
\def\algsum{\mathrm{sum}}
\def\algif{\mathrm{if}}
\def\algthen{\mathrm{then}}
\def\algelse{\mathrm{else}}
\def\algforeach{\mathrm{foreach}}

\newcommand\caret{\mathbin{\char`\^}}
\renewcommand{\algorithmiccomment}[1]{// #1}

\comment{
\feature{Query Compilation and Processing Overview}
\compiler\ focuses on applications issuing standing queries on a database which
subsequently process continuously changing, large volumes of input tuples.  Our
data model differs from existing stream processors, namely we consider a
database as a set of relations, each subject to an arbitrary sequence of
inserts, updates and deletes. In contrast, stream processors assume a rigid
insertion and deletion semantics, through constructs such as windows, or
punctuations and heartbeats. In \compiler, each tuple has an arbitrary
lifetime. Indeed, many stream applications, such as order book trading and
moving object applications, are self-managing -- the application logic and event
sources ensure that state does not grow unboundedly in practice.  \compiler\
produces imperative procedures to process queries given data manipulation
events. In this section we describe the compilation algorithm to transform
declarative queries into event handlers.
}

\compiler's recursive compilation algorithm performs its work on queries
represented in a \textit{map} calculus. We start this section with a description
of the map calculus, and subsequently describe the various stages of compilation
as transformations of terms in the calculus, identifying key properties of terms
that hold following each compilation stage.


\feature{Map terms}
The map calculus consists of the following types of terms:

\[
c 
\quad\;\;
x
\quad\;\;
f+g
\quad\;\;
f*g
\quad\;\;
\algsum_f(Q)
\]

Above $c,x$ denote numerical constants and variables respectively, $f,g$ are map
calculus terms (or simply \textit{maps}) and $\algsum_f(Q)$ denotes a sum
aggregation consisting of a relational calculus formula $Q$.

Variables in maps are either {\em free} or {\em bound}.
Given a map $f$ with free variables $\vec{x}$ (referred to in the order in which
they first appear in $f$), $f[\vec{a}]$, where $\vec{a}$ is a tuple of variables
and constants of the same arity as $\vec{x}$, denotes the substitution of each
$x_i$ in $f$, by $a_i$. The variables $\vec{x}$ in $f[\vec{a}]$ are then called
bound.  For example, the free variables of $5 * x + y$ are $x,y$ and $(5 * x +
y)[z, 2]$ is $5 * z + 2$ with free variable $z$.  The number of free variables
in a map is also called the map's arity.  We occasionally use $f[]$ to indicate
a map term $f$ with all variables bound.
We also define one particular kind of aggregate term, namely a
\textit{constraint-only} aggregate, where the relational part of the aggregation
contains only constraints, and each constraint includes at least one scalar
subaggregate query. Constraint-only aggregates are equivalent to conditionals,
that is:
\begin{align*}
\algsum_{1}(\phi( & <,100,\algsum_{A}(R(A,B)))) =\\
& \algif \; \phi(<,100,\algsum_{A}(R(A,B))) \; \algthen \; 1 \; \algelse \; 0
\end{align*}

\feature{Relational calculus formulae}
Next, we present our relational calculus formulae, which is a simplification of
the domain relational calculus:

\[
R(A,B)
\quad
\{\tuple{a,b}\}
\quad
\phi(\theta,f,g)
\quad
R \wedge S
\quad
R \vee S
\quad
\emptyset
\quad
\{\tuple{}\}
\]

\noindent respectively denoting relations (where attributes are pairs of
variables and domains, denoted $A, \Dom(A)$), tuples, constraints, conjunctions,
disjunctions, the empty set and a constant nullary relation. Here a constraint
is a triple of a comparison operator $\theta \in \{<=,<,=,!=,>,>=\}$, and two
map terms enabling nested queries, denoted $\phi(\theta, f, g)$.  A conjunction
of two relations, $R \wedge S$, corresponds to a natural join between the two
relations, while a disjunction $R \vee S$, represents a union with an implicit
projection (a projection to common variables of $R$ and $S$).
We can express selection operator ($\sigma$) from relational algebra as a
conjunction of a relation and a binary constraint, i.e.  $\sigma_{a<5}(R(A,B))
= R(A,B) \wedge \phi(<,A,5)$.  W.l.o.g, we will use renaming only directly above
the leaves of a calculus formula syntax tree.  We use a multiset semantics for
relations as in SQL; none of the operations of relational calculus eliminate
duplicates.
\todo{We return to the difference operation later.}
\todo{Example SQL query and our representation here?}
\todo{Safe and unsafe variables, and their relationship to bound variables, or
  do we describe this during aggregate simplification?}

\feature{Group-by aggregations}
Our aggregation terms with all variables bound, i.e. $\algsum_{f}(Q)[]$,
correspond to non-grouped aggregation in SQL (with the exception of syntax since
$g[]$ is a scalar value, while SQL aggregates yield a singleton relation).  We
represent SQL group-by aggregates as map terms with free variables corresponding
to group-by attributes. However a map term $g[\vec{a}]$
differs from a SQL group-by aggregate since the function $g$ is defined everywhere.
That is, suppose $g[a] = \algsum_{B}(R(A,B) \wedge \phi(\theta,A,0))[a]$. Here $g[a]$
produces $\{\tuple{0}\}$ rather than $\emptyset$ when
$R(a,B) \wedge \phi(\theta,a,0))$ is the empty relation and
$\algsum_{B}(\emptyset) = 0$, while the SQL aggregate-group-by query
$\sigma_{A=a}$(\texttt{select $A$, sum$(B)$ from $Q$ group by $A$})
gives no value on tuples $\{\tuple{a}\}$ that do not exist in $\Dom(A)$.


\feature{Monomials, polynomials and semirings}
We adopt a canonical representation for map terms and relational calculus
formulae, based on distributivity properties of their operations. We define
basic map terms as constants, variables, and aggregate operations, and the basic
calculus formulae as relations, constraints, an empty and a constant
nullary relation. These are the only elements that can appear as leaves in our
parse trees. Next we observe that conjunctions and disjunctions in our relational
calculus exhibit the same associativity and distributivity properties as the
addition and multiplication operators for map terms. That is:

\[
f*(g+h) = (f*g) + (f*h)
\quad
R \wedge(S \vee T) = (R \wedge S) \vee (S \wedge T)
\]


We refer to conjunctions and multiplications as products for the calculus and
maps respectively, and disjunction and addition as sums.  We can then define a
\textit{monomial} as a product of basic map terms or calculus, and a
\textit{polynomial} as a sum of monomials. We use polynomials of map terms and
calculus formulae for simplicity of compilation -- polynomials provide
separation between the occurrence of sums and products in the parse tree (that
is no product expression can contain a sum operator).  We provide examples of
monomials and polynomials of both map and relational calculus formulae below:

\begin{align*}
\mbox{Map monomial: } &
5*x*sum_{f}(Q)\\
\mbox{Map polynomial: } &
(5*x*sum_{f}(Q_1)) + sum_g(Q_1)\\
\mbox{Relational monomial: } &
R(A,B) \wedge S(C,D) \wedge \phi(=,B,C)\\
\mbox{Relational polynomial: } &
(R(A,B) \wedge S(C,D) \wedge \phi(=,B,C)) \\
& \cup (T(A,D) \wedge U(B,C,D))
\end{align*}


\comment{
\begin{figure}[htbp]
\begin{tabular}{l|c}
Terminology & Notation, example \\
\hline
Map monomial                 & \\
Safe variables               & \\
Unsafe variables             & \\
Delta                        & \\
Basic term                   & \\
Basic calculus element       & \\
Map polynomial               & \\
Relational monomial          & \\
Relational polynomial        & \\
Semiring operations          & \\
Map semiring elements        & \\
Relational semiring elements & \\
Constraint-only aggregate    & \\
\end{tabular}
\end{figure}
}

\comment{
\begin{figure*}[htbp]
\begin{center}
\begin{tabular}{c|c|c}
           & Map term & Relational calculus formula\\
\hline
Monomial   & $5*x*sum_{f}(Q)$
           & $R(A,B) \wedge S(C,D) \wedge \phi(=,B,C)$\\
Polynomial & $(5*x*sum_{f}(Q_1)) + sum_g(Q_1) $
           & $(R(A,B) \wedge S(C,D) \wedge \phi(=,B,C)) \cup (T(A,D) \wedge U(B,C,D))$
\end{tabular}
\label{tbl:monpolyex}
\caption{Map term and relational calculus, monomial and polynomial examples.}
\end{center}
\end{figure*}
}

With our polynomial representation of map and relational formulae, we can
encapsulate distributivity properties of products over sums using semirings
of map terms, and calculus formulae. A semiring is a set of elements, over which
both a sum ($+$) and a product ($\times$) operator can be defined, along with
two specific identity elements: a zero and a one element. For map terms, the
zero and one elements correspond to the constants 0 and 1, while for the
calculus, these are the empty set ($\emptyset$) and the constant nullary
relation ($\{\tuple{}\}$). The semiring defines simplifications between zero
elements and sums and products, as well as between one elements and products.
Since we consider semirings of both map terms and relational calculus formulae,
we use the symbols $\oplus$ and $\otimes$ to denote sum and product
respectively. It should be clear from the context whether we are referring
to the map or relational semiring.

\feature{Polynomial construction}
\compiler\ transforms queries into polynomial form by performing one key
simplification, namely factorization of aggregate argument terms over their
corresponding calculus formulae, in addition to recursively transforming
nested map terms in constraints. We now describe this in more detail.

Consider an aggregate term $q[] = \algsum_{f}(Q)$. Following recursively
constructing polynomials of $f$ and $Q$, we can consider $f$ a polynomial map
term with monomials $M_f$, and $Q$ a polynomial relational calculus formula
with monomials $M_Q$. Factorizing involves separating uncorrelated basic
elements of monomials, that is for some term and relational monomial $m_f
\in M_f, m_Q \in M_Q$, we may be able to partition monomial elements (recall
monomials are products of basic elements) into term-relational pairs for simpler
aggregation. The desired term-relational pairs are:

\[\{(l_{fi},l_{Qi}) | l_{fi} \subseteq m_f, l_{Qi} \subseteq m_Q,
vars(l_{fi}) \cap vars(l_{Qi}) \neq \emptyset\}\]

\noindent where $vars(l_{fi}), vars(l_{Qi})$ denotes variables used by sets of basic
map terms and calculus formulae respectively, and $l_{fi} and l_{Qi}$ are minimal
subsets where the property holds. This property states that for any resulting
pair $(l_{fi}, l_{Qi})$, the map term $l_{fi}$ uses variables defined in $l_{Qi}$. We can
then write the resulting factorized term as:
$\algsum_{l_{f1}}(l_{Q1}) + \ldots + \algsum_{l_{fn}}(l_{Qn})$.
We give a simple example of factorization below:

\begin{align*}
\algsum_{A*B*D*E}( & R(A,B,C) \wedge S(D,E,F) =\\
& \algsum_{A*B}(R(A,B,C)) * \algsum_{D*E}(S(D,E,F))
\end{align*}

Here a term and relational monomial pair $(A*B*D*E, R \wedge S)$ is factorized
into a set of term-relational monomials $\{(A*B,R), (D*E,S)\}$. Due to space
constraints, we omit the full details of an algorithm for computing such a
factorization, and simply sketch an outline. Our approach constructs a graph for
each term-relational monomial pair with nodes as variables from each monomial,
and edges fully connecting those variables used in each basic map term or
relational expression. In our example above, we create the following edgelist:
$\{(A,B), (B,C), (C,A), (D,E), (D,F), (E,F)\}$ as defined by the variables from
relations $R,S$. Note that the map term monomial $A*B*D*E$ does not induce edges
since each basic map term is a single variable. Factorization then involves
determining connected components on such a graph.

\feature{Summary}
In general, the construction of polynomials may lead to an exponential number of
basic terms in our maps, however this is often acceptable in practice since
queries tend to be small. This exponential query representation is exhibited in
many other contexts, including in the conversion between disjunctive and
conjunctive normal forms in first-order logic. In summary, our polynomials have
a well-defined structure. The top-level of a parse tree is a map polynomial,
which may include aggregate terms. These aggregate terms include a polynomial
calculus formulae, in addition to a potentially nested aggregate argument map
polynomial. Relational calculus polynomials themselves may include nested map
polynomials, in our constraints.  \todo{This nested polynomial structure is
illustrated in Figure [XXX].}


