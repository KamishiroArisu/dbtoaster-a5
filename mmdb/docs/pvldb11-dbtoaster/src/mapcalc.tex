\section{Incremental Queries}

\subsection{Map Calculus}

\def\calcsum{\mbox{Sum}}
\def\calceq{\mbox{{\tt =}}}
\def\calcgt{\mbox{{\tt >}}}
\def\calcgte{\mbox{{\tt >=}}}
\def\calclte{\mbox{{\tt <=}}}

\def \q{q}
\def \qq{Q}
\def \qqa{Q_1}
\def \qqb{Q_2}
\def \v#1{\mbox{#1}}
\def \vv#1{\mbox{{\tiny #1}}}

\begin{itemize}
  \item Overview of query language presentation: simple language exposing
  variables, that allows us to briefly present core transformations performed
  during compilation, followed by an extension to a more complex language that
  captures aspects of information flow and query evaluation.
\end{itemize}

\noindent Query language:

\begin{align*} 
\q \; \mbox{::-} &
  \;    c \;|\; Var(x)
  \;|\; R(\vec{x}) \;|\; m(\vec{x}) \;|\; f(\vec{x})
\\
\comment{
& \;|\; \theta(x,y)   \;|\; \theta_c(x)
  \;|\; \calceq(\q,y) \;|\; \calceq(x,y)
\\
}
\qq \; \mbox{::-} & \; \q \;|\; \calcsum(\vec{x}, \qq(\vec{x}\vec{y}))
    \;|\; \qqa(\vec{x}) + \qqb(\vec{y}) \;|\; \qqa(\vec{x}) * \qqb({\vec{y}}) \\
&   \;|\; -\qq(\vec{x}) \;|\; \theta(\qq) \;|\; \calceq(x,\qq)
\end{align*}

\begin{itemize}
  \item Basic terms ($q$) in language: constants, variables (i.e. variable
  usage), relations which define vars, maps which are keyed by vars, and
  functions which take vars as arguments.
  \item Higher-order terms ($Q$): sum aggregates with group-by vars
  listed (for presentation we drop this first arg if there are no group-bys), s
  sum and product operations of basic terms and higher-order terms. The
  variables listed for the subqueries are variables that are free in the
  subquery. \note{We return to free and bound variables in describing semantics
  below}. A sum operation corresponds to schema-less union, and a product to
  natural join. Note in the case of no variables from either $\qqa$ or $\qqb$
  these operations correspond to arithmetic sum and product. We also have
  additive inverse and nested queries, and a variable binding which associates
  (the value of) a variable to a subquery.
  \item Variable bindings are only introduced as part of our transformations,
  that is they are not needed to express SQL queries.
\end{itemize}

\noindent Language semantics:

\begin{align*}
c                   := & \; \tuple{} \mapsto c\\
Var(x)              := & \; \tuple{} \mapsto \Gamma(x)\\
R                   := & \; \vec{x} \mapsto R(\vec{x})\\
m                   := & \; \vec{x} \mapsto m(\vec{x}) \\
\comment{
\theta(x,y)         := & \; \tuple{x,y} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; y \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\theta_c(x)         := & \; \tuple{x} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; c \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\calceq(\q,y)       := & \; \tuple{y} \mapsto \q(\tuple{}) \\
\calceq(x,y)        := & \; \tuple{y} \mapsto \Gamma(x) \\
}
f                   := & \; \vec{x} \mapsto f(\vec{x}) \\
\end{align*}

\begin{align*}
\calcsum(\vec{x}, \qq(\vec{x}\vec{y})) := & \;
\vec{x} \mapsto \ \sum_{\vec{y}} \qq(\vec{x}\vec{y})
\\
\qqa(\vec{y}) + \qqb(\vec{z}) := & \;
\vec{x} \mapsto 
\sum_{\{\vec{x}\} = ext_{\vec{z}}(\vec{y}) \cup ext_{\vec{y}}(\vec{z})}
\qqa(\vec{x}) + \qqb(\vec{x})
\\
\qqa(\vec{y}) * \qqb(\vec{z}) := & \;
\vec{x} \mapsto \sum_{ \{\vec{x}\} = \{\vec{y}\} \Join \{\vec{z}\} }
\qqa(\vec{y}) * \qqb(\vec{z})
\\
-\qq(\vec{x}) := & \; \vec{x} \mapsto -\qq(\vec{x})
\\
\theta(\qq) := & \; \tuple{} \mapsto
                    \begin{cases}
                    1 \ldots \qq(\vec{x}) \theta 0\\
                    0 \ldots \mbox{otherwise.}
                    \end{cases}
\\
\calceq(x,\qq) := & \; \Gamma := \Gamma \cup \{x \mapsto \qq\};
                  \tuple{} \mapsto 1
\end{align*}

\begin{itemize}
  \item Based on generalized multiset relations (gmrs) of PODS paper, each
  expression in our language represents a finite function (ffn), whose
  arguments correspond to \textit{free} variables in the subquery. The domain
  of this finite function is the universe of named and typed tuples, the range
  the set of natural numbers, i.e. $f : \mbox{Tup} \mapsto \mathbb{N}$. Each
  finite function is non-zero for only a small subset of tuples.
  \item Semantics of basic terms:
  \begin{itemize}
    \item constants and variables are singleton functions, yielding the
    constant or variable value. Variables are bound in an environment,
    $\Gamma$, and for readability, we defer the full description of the bound
    and free variables in an expression to both later in this paper, and more
    formally in the PODS paper, especially with the definitions of safety in
    PODS Sec. 4, Fig. 1.
    \item Relations are ffns yielding cardinalities of tuples (i.e. multiset
    semantics), maps and functions yield values associated with keys (i.e.
    tuples), and arguments respectively.
  \end{itemize} 
  
  \item Semantics of higher-order terms:
  \begin{itemize}
    \item Sum aggregate is summation of (the values yielded by) an expression
    over non-group-by variables.
    \item Sum op is schema-less union, that is (the sum of counts of) all tuples
    from $\qqa$ and $\qqb$ extended to the combined schema of $\vec{y} \cup
    \vec{z}$. The $ext$ function performs this schema extension by ``adding''
    missing values. Note the semantics of missing values are not the same as
    nulls. In particular, our ffns are simply functions whose arguments must be
    \textit{consistent} with the values provided, that is variables whose
    values are missing can be ignored.
    \item Product op is (the product of counts of) tuples from $\qqa$ and
    $\qqb$ according to a natural join of said tuples.
    \item Additive inverse simply negates (the count of tuples in) a gmr.
    \item Nested aggregates are a singleton tuple (with count) based on a
    comparison of a subquery with no free variables (and thus a single-row
    subquery) to 0.
    \item Variable bindings add a mapping from the variable name $x$ to the
    ffn $\qq$ in the environment $\Gamma$, and yields an identity gmr. Note the
    ffn $\qq$ has no free variables.
  \end{itemize} 
  
\end{itemize}

\tinysection{Example queries}

\noindent VWAP:
\begin{verbatim}
select sum(price * vol)
from bids b0
where 0.25 * (select sum(b1.vol) from bids b1) >
     (select sum(b2.vol) from bids b2
      where b2.price > b0.price)
\end{verbatim}

\begin{align*}
\calcsum(\tuple{},
& B(\v{P0,V0}) * \v{P0} * \v{V0} *\\
& \calcgt(0.25 * \calcsum(B(\v{P1,V1}) * \v{V1}) \\
& \qquad \; \; - \calcsum(B(\v{P2,V2}) * \v{V2} * \calcgt(\v{P2-P0})))
\end{align*}

\comment{
\begin{align*}
\calcsum(\tuple{},
& B(P0,V0) * P0 * V0 *\\
& \calceq(\calcsum(B(P1,V1) * V1), X) * \\
& \calceq(\calcsum(B(P2,V2) * V2 * \calcgt(P2-P0)), Y) * \\
& \calcgt(0, 0.25 * X + Y)
\end{align*}
}

\noindent TPCH Q18:
\begin{verbatim}
select c.custkey, sum(l1.quantity)
from customer c, orders o, lineitem l1
where 1 <=
    (select sum(1) from lineitem l2
     where l1.orderkey = l2.orderkey
     and 100 < (select sum(l3.quantity)
                from lineitem l3
                where l2.orderkey = l3.orderkey))
and c.custkey = o.custkey
and o.orderkey = l1.orderkey
group by c.custkey;
\end{verbatim}

\begin{align*}
\calcsum(& \tuple{\v{CK}},
  \; C(\v{CK}) * O(\v{OK,OCK}) * L1(\v{OK1,Q1}) * \v{Q} * \\
& \; \calcgte(\calcsum(\tuple{}, L2(\v{OK2}) * 1 *
     \calceq(\v{OK1}+(-\v{OK2})) * \\
& \qquad \quad
    \calcgt(\calcsum(\tuple{}, L3(\v{OK3,Q3}) * \v{Q3} *
    \calceq(\v{OK2} - \v{OK3}))
\\ & \qquad \qquad + (-100)) + (-1)) * \\
& \; \calceq(\v{CK} - \v{OCK}) * \calceq(\v{OK} - \v{OK1})
\end{align*}

\subsection{Query Transformations}

\noindent This subsection presents core query transformations used for query
compilation, including:
\begin{itemize}
  \item Delta computation, the core query transformation needed for incremental
  processing. Compilation is essentialy computing higher-order deltas, i.e.
  recursively applying delta transformations, in conjunction with the other
  transformations below.
  \item Preaggregation, a transformation used to alter the structure of
  subqueries in expressions containing nested queries, to facilitate deltas of
  nested queries.
  \item Normalization and simplification, transformations used to bring a query
  to a canonical form, and reduce the query in terms of variables present.
\end{itemize}

\tinysection{Delta computation}
We define a function $\Delta$ that accepts a query, and a relation (and its
variables), for which to compute a delta query. This delta is identical to that
of the PODS paper (with the addition of a variable binding clause):
\begin{align*}
\Delta_{+R(\vec{x} \mapsto \vec{t})} c := & \; 0
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} Var(y) := & \; 0
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} R(\vec{x}) := & \;
\prod_i^{sch(\vec{x})} \calceq(t_i,x_i)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} S(\vec{y}) := & \; 0
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})}
\calcsum(\vec{x},\qq) := & \; \calcsum(\vec{x},\Delta\qq)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} (\qqa + \qqb) := & \;
(\Delta\qqa + \Delta\qqb)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} (\qqa * \qqb) := & \;
(\Delta \qqa * \qqb) +
(\qqa * \Delta \qqb) +
(\Delta \qqa * \Delta \qqb)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} \theta(\qq) := & \;
(\theta(\qq + \Delta \qq) * \overline{\theta}(\qq)) \; -
\\
& \; (\overline{\theta}(\qq+\Delta \qq) * \theta(\qq))
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} \calceq(x,\qq) := & \;
    \calceq(x,\Delta \qq)
\end{align*}

\begin{itemize}
  \item Note every delta form, except deltas of nested queries, results in a
  simpler query in terms of the \textit{degree} of a query. Loosely speaking,
  a query's degree is a measure of the number of relations (and thus
  free variables) present in a query, and formally defined in PODS Sec. 5, Def.
  5.4.
  \item The delta for a nested query is not simpler, since we have both
  $\theta(\qq)$ and $\theta(\qq + \Delta \qq)$ present after applying the
  transformation. Given our query compilation algorithm is recursive in
  nature, query compilation has to intelligently determine how to compute
  higher-order deltas of nested queries to ensure termination.
\end{itemize}

\tinysection{Preaggregation}
Preaggregation is a transformation focusing on the complexity of queries
containing nested terms that essentially introduces additional aggregation
operations based on nesting structure and the correlated variables connecting
outer queries and nested queries.

\comment{
\begin{align*}
\calcsum(\phi[][\vec{x}] *
(\calcsum(\ldots)[\vec{x}][] * \calceq_\phi[y][] * (\psi[y][]))) \\
\end{align*}
}


\noindent The general form of a nested query is:
\begin{align*}
\calcsum(\vec{x}, \qqa * \theta(\qqb))
\end{align*}

\noindent where query $\qqb$ contains correlated variables, which are
free variables in $\qqa$. Preaggregation transforms query $\qqa$ to a group-by
aggregate, with the correlated variables in $\qqb$ as grouping variables.

\def \pa#1#2{\llbracket #1 \rrbracket_{PA}(#2)}

\noindent Preaggregation (note assumes left-associativity for product):

\begin{align*}
\pa{c}{\vec{x}} & := c
\\
\pa{Var(x)}{\vec{y}} & := Var(x)
\\
\pa{R(\vec{x})}{\vec{y}} & := \calcsum(\vec{x} \cap \vec{y}, R(\vec{x}))
\\
\pa{m(\vec{x})}{\vec{y}} & := \calcsum(\vec{x} \cap \vec{y}, m(\vec{x}))
\\
\pa{f(\vec{x})}{\vec{y}} & := \calcsum(\vec{x} \cap \vec{y}, f(\vec{x}))
\\
\pa{\calcsum(\vec{x}, \qq(\vec{x}\vec{y}))}{\vec{x}} & :=
    \calcsum(\vec{x}, \pa{\qq(\vec{x}\vec{y})}{\vec{x}})
\\
\pa{\qqa(\vec{y}) + \qqb(\vec{z})}{\vec{x}} & :=
    \pa{\qqa}{\vec{x}} + \pa{\qqb}{\vec{x}}
\\
\pa{\qqa(\vec{y}) * \qqb(\vec{z})}{\vec{x}} & :=
    \begin{cases}
    \calcsum(\vec{x}\vec{v}, 
        \pa{\qqa}{\vec{x}\vec{v}}) * \pa{\qqb}{\vec{x}} \\
    \; \; \ldots
        \mbox{ if $\vec{v} \neq \emptyset$},\vec{v} = \vec{y} \cap vars(\qqb)\\
    \pa{\qqa}{\vec{x}} * \pa{\qqb}{\vec{x}} \\
    \; \; \ldots \mbox{ otherwise}
    \end{cases}
\\
\pa{-\qq(\vec{y})}{\vec{x}} & := -\pa{\qq(\vec{y})}{\vec{x}}
\\
\pa{\theta(\qq)}{\vec{x}} & := \theta(\pa{\qq}{\tuple{})})
\\
\pa{\calceq(x,\qq)}{\vec{y}} & := \calceq(x, \pa{\qq}{\tuple{}})
\end{align*}

\noindent where $vars$ yields all variables used (that is $Var$ expressions)
in a query.

\noindent Preaggregation example:
\begin{align*}
\pa{\calcsum(\tuple{},
& B(\v{P0,V0}) * \v{P0} * \v{V0} *\\
& \calcgt(0.25 * \calcsum(B(\v{P1,V1}) * \v{V1}) \\
& \qquad \; \; - \calcsum(B(\v{P2,V2}) * \v{V2} * \calcgt(\v{P2-P0})))}
{\tuple{}} :=
\\[1ex]
\calcsum(\tuple{},
& \calcsum(\tuple{\v{P0}}, B(\v{P0,V0}) * \v{P0} * \v{V0}) *\\
& \calcgt(0.25 * \calcsum(B(\v{P1,V1}) * \v{V1}) \\
& \qquad \; \; - \calcsum(B(\v{P2,V2}) * \v{V2} * \calcgt(\v{P2-P0})))
\end{align*}

\begin{itemize}
  \item Apply preaggregation step. This ensures strictness of subqueries for
  correlated variables. Note preaggregation can be useful beyond nested
  queries, it essentially preaggregates relations to only those variables that
  are needed in the rest of the query. We return to this when describing our
  annotated calculus in the next section.
  \item Preaggregation results in a simpler substructure to the query (i.e.
  variables that are aggregated, are eliminated from the outer query).
  \todo{This definition of simpler is different than the concept of degree.
  Perhaps we can define this as the \textit{width} of a query, i.e. the number
  of outvars it has. Thus bigsum rewriting does not simplify in terms of
  degree, but does in term of width. With preaggregation, we are creating
  queries of minimal width w.r.t propagation.}
\end{itemize}

\tinysection{Query normalization and simplification}

\begin{itemize}
  \item Mostly refer to PODS paper.
\end{itemize}

\begin{itemize}
  \item Recursively monomial form
  \item Factorization
  \item Unifying loop variables
\end{itemize}



\subsection{Query Evaluation Annotations}

\begin{itemize}
  \item Input/output variables, cf. binding patterns, datalog.
  \item Provides a compact representation of the core data flow occuring during
        query evaluation, enabling a principled framework to perform all kinds
        of interesting optimizations.
  \item Annotated grammar, see below. Explain constraints on io-vars for
        base elements, e.g. relmaps. 
  \item Top down propagation, left to right propagation.
  \item Propagation diagram generic + for one of the annotated calculus
        examples.
  \item Determining input/output variables. Should occur as part of the
       compilation algorithm. \todo{Presentation: algorithm described before
       this, need to punt explanation of annotation to here.}
  \item \todo{Annotation rules for annotation algorithm?} 
\end{itemize}

\begin{align*} 
\q \; \mbox{::-} & \; R[][\vec{x}] \;|\; c[][] \;|\; Var[x][] \;|\;
m[\vec{x}][\vec{y}]\;|\; f[\vec{x}][]
\\
\comment{
& \;|\; \theta[x,y][] \;|\; \theta_c[x][] \;|\;
\calceq_\q[][y] \;|\; \calceq[x][y]
\\
}
\qq \; \mbox{::-} & \; \q[\vec{x}][\vec{y}] \;|\;
\calcsum(\q[\vec{x}][\vec{y}\vec{z}])[\vec{x}][\vec{z}] \\ & \;|\;
(\qqa[\vec{u}][\vec{v}] + \qqb[\vec{w}][\vec{x}])[\vec{y}][\vec{z}]
\\
& \;|\;
(\qqa[\vec{u}][\vec{vv'}] * \qqb[\vec{v'w}][\vec{x}])[\vec{y}][\vec{z}]
\\
& \;|\; \theta(\qq[\vec{x}][])[\vec{x}][]
\\
& \todo{\;|\; \calceq(\qq[\vec{x}][\vec{y}])}
\end{align*}

\begin{itemize}
\item Comment on lack of output vars in $\theta$, use of $y$ to
represent free var of bf-equality, which was previously an argument to
bf-equality

\item Propagation diagram:
    \begin{itemize}
      \item VWAP AST
      \item Transitive/multistep LR propagation
      \item Top-down bound var propagation, delta essentially binds a relation's
      variables from the very top
      \item No outvars on inequality constraints and nested queries, outvars only
      on bf-equalities
      \item Sum projection as explicit outvar restriction
    \end{itemize}

\end{itemize}

\noindent\todo{Punt annotated semantics to appendix/omit entirely. Should
explain two-level maps though.}

\begin{align*}
R[][\vec{x}]          := & \; \tuple{} \mapsto \vec{x} \mapsto R(\vec{x})\\
c[][]                 := & \; \tuple{} \mapsto \tuple{} \mapsto c\\
Var[x][]              := & \; \tuple{x} \mapsto \tuple{} \mapsto x\\
m[\vec{x}][\vec{y}]   := & \; \vec{x} \mapsto \vec{y} \mapsto
m(\vec{x})(\vec{y})
\\
\theta[x,y][]         := & \; \tuple{x,y} \mapsto \tuple{} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; y \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\theta_c[x][]         := & \; \tuple{x} \mapsto \tuple{} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; c \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\calceq_\q[][y]       := & \; \tuple{} \mapsto \tuple{y} \mapsto
                              \q(\tuple{})(\tuple{})
\\
\calceq[x][y]         := & \; \tuple{x} \mapsto \tuple{y} \mapsto x
\\
f[\vec{x}][\vec{y}]   := & \; \vec{x} \mapsto \vec{y} \mapsto f(\vec{x})
\\ 
\\
\calcsum(\q[\vec{x}] & [\vec{y}\vec{z}])[\vec{x}][\vec{y}] := \;
\vec{x} \mapsto \vec{y} \mapsto \ \sum_{\vec{z}} \q(\vec{x})(\vec{y}\vec{z})
\\
(\qqa[\vec{u}][\vec{v}] & + \qqb[\vec{w}][\vec{x}])[\vec{y}][\vec{z}] :=  \\
& \vec{y} \mapsto \sum_{ \{\vec{y}\} = \{\vec{u}\} \Join \{\vec{w}\} }
\vec{z} \mapsto  \sum_{ \{\vec{z}\} = \{\vec{v}\} \Join \{\vec{x}\} }
\qqa(\vec{u})(\vec{v}) + \qqb(\vec{w})(\vec{x})
\\
\\
(\qqa[\vec{u}][\vec{v_1}\vec{v_2}] & * \qqb[\vec{v_2}\vec{w}][\vec{x}])
[\vec{y}][\vec{z}] :=  \\
& \vec{y} \mapsto \sum_{ \{\vec{y}\} = \{\vec{u}\} \Join \{\vec{w}\} }
\vec{z} \mapsto \\
& \qquad \;\;\;
\sum_{ \{\vec{z}\} = \{\vec{v_1}\vec{v_2}\} \Join \{\vec{x}\} }
\qqa(\vec{u})(\vec{v_1}\vec{v_2}) * \qqb(\vec{v_2}\vec{w})(\vec{x}) 
\end{align*}


\tinysection{Annotated calculus examples}

\begin{itemize}
  \item TODO: what about io-vars inside new $\theta$ expression? Since
  $\theta$ inner expression must have no out-vars, how does the var propagation
  work for the inner expression?
\end{itemize}


%% VWAP with base io-vars
\begin{align*}
\calcsum( & B(\v{P0,V0})_{[][\vv{P0,V0}]} * \v{P0} * \v{V0} \; *
\\
& \calcgt(\calcsum(B(\v{P1,V1})_{[][\vv{P1,V1}]} * \v{V1})_{[][]} \; +
\\
& \quad \;\; \calcsum(B(\v{P2,V2})_{[][\vv{P2,V2}]} * \v{V2} *
                 \calcgt(\v{P2}-\v{P0})_{[\vv{P2,P0}][]})_{[\vv{P0}][]}
\\
& \quad )_{[\vv{P0}][]}
\\
& )_{[][]}
\end{align*}

%% VWAP with intermediate io-vars
\begin{align*}
\calcsum( & \tuple{},
    ((B(\v{P0,V0})_{[][\vv{P0,V0}]}
      * \v{P0})_{[][\vv{P0,V0}]}
      * \v{V0})_{[][\vv{P0,V0}]} *
\\
& \calcgt(\calcsum(\tuple{},
    (B(\v{P1,V1})_{[][\vv{P1,V1}]}
     * \v{V1})_{[][\vv{P1,V1}]})_{[][]} +
\\
& \quad \;\; \calcsum(\tuple{},
    ((B(\v{P2,V2})_{[][\vv{P2,V2}]} * \v{V2})_{[][\vv{P2,V2}]} *
\\
& \qquad \qquad
    \calcgt(\v{P2}-\v{P0})_{[\vv{P2,P0}][]})_{[][\vv{P2,V2}]})_{[\vv{P0}][]}
\\
& \quad )_{[\vv{P0}][]}
\\
& )_{[][]}
\end{align*}

%% Old example annotations, with bf-equalities
\comment{
\begin{align*}
\calcsum(((B[][P0,V0] * P0)[][] * V0)[][])
\end{align*}

\begin{align*}
\calcsum((B[][P0] * V0)[V0][])[V0][]
\end{align*}

\begin{align*}
\calcsum( & B[][P0,V0] * P0 * V0 *\\
& (\calcsum(B[][P1,V1] * V1)[][]) * \calceq[][X] * \\
& (\calcsum(B[][P2,V2] * V2 * >[P2,P0][])[P0][] * \calceq[][Y]) * \\
& ((((0.25 * X)[][] + Y)[][] * \calceq[][Z]) * 0[][] * >[Z][]))
\end{align*}


\begin{figure*}[htbp]
\begin{align*}
\calcsum( & ((B[][P0,V0] * P0)[][] * V0)[][] *\\
& ((\calcsum(B[][P1,V1] * V1)[][]) * \calceq[][X] * \\
& (\calcsum(B[][P2,V2] * Var[V2][] * >[P2,P0][])[P0][] * \calceq[][Y]))[][X,Y] *
\\ & ((((0.25 * X)[][] + Y)[][] * \calceq[][Z]) * >0[Z][])[][])[][]
\end{align*}
\end{figure*}
}

\noindent\todo{Punt/omit delta rules for annotated grammar}
%% Delta rules for annotated grammar
%%
\begin{align*}
\Delta_{+R(\vec{x} \mapsto \vec{t})} c[][] := & \; 0[][]
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} Var[y][] := & \; 0[][]
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} R[][\vec{x}] := & \;
\prod_i \calceq[t_i][x_i]
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} S[][\vec{y}] := & \; 0[][]
\\
\end{align*}

%% Old delta rules for agg,sum,prod w/ io-vars.
%% -- does not represent io-var changes to inner terms, making it useless
%%    for explaining changes to outer terms
\comment{
\begin{align*}
\Delta_{+R(\vec{t})}
\calcsum(\phi[\vec{w}][\vec{x}\vec{y}\vec{z}])[\vec{w}][\vec{x}\vec{y}]
:= & \;
\calcsum(\Delta\phi[\vec{w}][\vec{x}\vec{y}\vec{z}])
[\vec{t}\vec{w}][\vec{y}]
\\
\Delta_{+R(\vec{t})}
(\Phi[\vec{x}][\vec{y}] + \Psi[\vec{z}][\vec{w}])[\vec{u}][\vec{v}]
:= &
((\Delta\Phi[\vec{x}][\vec{y}]) + \Delta\Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots]
\\
\Delta_{+R(\vec{t})}
(\Phi[\vec{x}][\vec{y}] * \Psi[\vec{z}][\vec{w}])[\vec{u}][\vec{v}]
:= &
(((\Delta \Phi[\vec{x}][\vec{y}]) * \Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots] +
\\
& (\Phi[\vec{x}][\vec{y}] * \Delta \Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots] +
\\
& ((\Delta \Phi[\vec{x}][\vec{y}]) * \Delta \Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots])\\
& \; [\vec{t}\vec{u}][\vec{v}]
\\
\end{align*}
}

\noindent\todo{Rewrite as }

\[
\trfrac{
\Delta_{+R(\vec{x} \mapsto \vec{t})} \phi[\vec{uw}][\vec{xyz}] := 
\phi'[\vec{tw}][\vec{yz}]}
{
\begin{tralign}
\Delta_{+R(\vec{x} \mapsto \vec{t})}
\calcsum(\phi[\vec{uw}][\vec{xyz}])[\vec{uw}][\vec{xy}] & :=
     \calcsum(\Delta \phi[\vec{uw}][\vec{xyz}])[\ldots][\ldots] \\
& := \calcsum(\phi'[\vec{tw}][\vec{yz}])[\vec{tw}][\vec{yz}]
\end{tralign}
}
\]

\[
\trfrac{
\Delta(\Phi[\vec{ab}][\vec{cd}]) := \Phi'[\vec{ta}][\vec{c}] \qquad
\Delta(\Psi[\vec{wx}][\vec{yz}]) := \Psi'[\vec{tw}][\vec{y}]}
{
\begin{tralign}
\Delta((\Phi[\vec{ab}][\vec{cd}] + \Psi[\vec{wx}][\vec{yz}]) &
[\vec{abwx}][\vec{cdyz}]) := \\
& (\Phi'[\vec{ta}][\vec{c}] +
   \Psi'[\vec{tw}][\vec{y}])
  [\vec{taw}][\vec{cy}]
\end{tralign}
}
\]

\[
\trfrac{
\Delta(\Phi[\vec{ab}][\vec{cd}]) := \Phi'[\vec{ta}][\vec{c}] \quad
\Delta(\Psi[\vec{wx}][\vec{yz}]) := \Psi'[\vec{tw}][\vec{y}] \quad
\vec{cd} \cap \vec{wx} = \emptyset}
{
\begin{tralign}
\Delta((\Phi[\vec{ab}][\vec{cd}] * & \Psi[\vec{wx}][\vec{yz}])[abwx][cdyz])
:= \\
&    ((\Phi'[\vec{ta}][\vec{c}] *
       \Psi[\vec{wx}][\vec{yz}])[\vec{tawx}][\vec{cyz}] + \\
& \; (\Phi[\vec{ab}][\vec{cd}] *
       \Psi'[\vec{tw}][\vec{y}])[\vec{tabw}][\vec{cdy}] + \\
& \; (\Phi'[\vec{ta}][\vec{c}] *
      \Psi'[\vec{tw}][\vec{y}])[\vec{taw}][\vec{cy}])[\vec{tabwx}][\vec{cdyz}]
\end{tralign}
}
\]

\noindent\todo{Finish below -- add intermediate io-vars to product case.}

\noindent\todo{Is this case correct? Why should we care about propagated
variables w.r.t to deltas? Can a delta violate propagation and safety?}
\[
\trfrac{
\Delta(\Phi[\vec{ab}][\vec{cdm}]) := \Phi'[\vec{ta}][\vec{c}] \qquad
\Delta(\Psi[\vec{mwx}][\vec{yz}]) := \Psi'[\vec{tw}][\vec{y}]}
{
\begin{tralign}
\Delta((\Phi[\vec{ab}][\vec{cdm}] * \Psi[\vec{mwx}][\vec{yz}])[][])
:= & \;
     ((\Phi'[\vec{ta}][\vec{c}] *
       \Psi[\vec{wx}][\vec{yz}])[][] + \\
& \; (\Phi[\vec{ab}][\vec{cd}] *
       \Psi'[\vec{tw}][\vec{y}])[][] + \\
& \; (\Phi'[\vec{ta}][\vec{c}] *
      \Psi'[\vec{tw}][\vec{y}])[][])[][]
\end{tralign}
}
\]


\[
\trfrac{
\Delta_{+R(\vec{t})}(\Phi[\vec{ab}][]) := \Phi[\vec{ta}][]
}
{
\begin{tralign}
\Delta_{+R(\vec{t})} \theta(\Phi[\vec{ab}][])[\vec{ab}][]
:= & \;
( \theta(\Phi[\vec{ab}][] + \Delta \Phi[\vec{ta}][])[\vec{tab}][] * \\
& \; \;
\overline{\theta}(\Phi[\vec{ab}][])[\vec{ab}][] -
\\
& \; \; \overline{\theta}(\Phi[\vec{ab}][] + \Delta \Phi[\vec{ta}][])
[\vec{tab}][] *
\\
& \; \; \theta(\Phi[\vec{ab}][])[\vec{ab}][]
)[\vec{tab}][]
\end{tralign}
}
\]