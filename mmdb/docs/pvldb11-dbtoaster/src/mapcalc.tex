\section{Incremental Queries}

\subsection{Map Calculus}

\def\calcsum{\mbox{Sum}}
\def\calceq{\mbox{{\tt =}}}
\def\calcgt{\mbox{{\tt >}}}
\def\calcgte{\mbox{{\tt >=}}}
\def\calclte{\mbox{{\tt <=}}}

\def \q{q}
\def \qq{Q}
\def \qqa{Q_1}
\def \qqb{Q_2}
\def \v#1{\mbox{#1}}
\def \vv#1{\mbox{{\tiny #1}}}

\begin{align*} 
\q \; \mbox{::-} &
  \;    c \;|\; Var(x)
  \;|\; R(\vec{x}) \;|\; m(\vec{x}) \;|\; f(\vec{x})
\\
\comment{
& \;|\; \theta(x,y)   \;|\; \theta_c(x)
  \;|\; \calceq(\q,y) \;|\; \calceq(x,y)
\\
}
\qq \; \mbox{::-} & \; \q \;|\; \calcsum(\vec{x}, \q)
    \;|\; \qqa(\vec{x}) + \qqb(\vec{y}) \;|\; \qqa(\vec{x}) * \qqb({\vec{y}}) \\
&   \;|\; -(\qq) \;|\; \theta(\qq) \todo{\;|\; \calceq(x,\qq)}
\end{align*}

\begin{align*}
c                   := & \; \tuple{} \mapsto c\\
Var(x)              := & \; \tuple{} \mapsto \Gamma(x)\\
R                   := & \; \vec{x} \mapsto R(\vec{x})\\
m                   := & \; \vec{x} \mapsto m(\vec{x}) \\
\comment{
\theta(x,y)         := & \; \tuple{x,y} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; y \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\theta_c(x)         := & \; \tuple{x} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; c \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\calceq(\q,y)       := & \; \tuple{y} \mapsto \q(\tuple{}) \\
\calceq(x,y)        := & \; \tuple{y} \mapsto \Gamma(x) \\
}
f                   := & \; \vec{x} \mapsto f(\vec{x}) \\
\end{align*}

\begin{align*}
\calcsum(\vec{x}, \q) := & \;
\vec{x} \mapsto \ \sum_{\vec{y}} \q(\vec{x}\vec{y})
\\
\qqa(\vec{y}) + \qqb(\vec{z}) := & \;
\vec{x} \mapsto 
\sum_{\{\vec{x}\} = ext_{\vec{z}}(\vec{y}) \cup ext_{\vec{y}}(\vec{z})}
\qqa(\vec{x}) + \qqb(\vec{x})
\\
\qqa(\vec{y}) * \qqb(\vec{z}) := & \;
\vec{x} \mapsto \sum_{ \{\vec{x}\} = \{\vec{y}\} \Join \{\vec{z}\} }
\qqa(\vec{y}) * \qqb(\vec{z})
\\
-(\qq) := & \; \vec{x} \mapsto -\qq(\vec{x})
\\
\theta(\qq) := & \; \vec{x} \mapsto
                    \begin{cases}
                    1 \ldots \qq(\vec{x}) \theta 0\\
                    0 \ldots \mbox{otherwise.}
                    \end{cases}
\\
\todo{\calceq(x,\qq) :=} & \;
\todo{\vec{y} \mapsto \qq(\vec{y})}
\end{align*}

\begin{itemize}
  \item Primitive maps
  \item Higher-order maps
  \item Explain schema-less union and $ext()$ function
\end{itemize}

\tinysection{Example queries}

\begin{verbatim}
select sum(price * vol)
from bids b0
where 0.25 * (select sum(b1.vol) from bids b1) >
     (select sum(b2.vol) from bids b2
      where b2.price > b0.price)
\end{verbatim}

\begin{align*}
\calcsum(\tuple{},
& B(\v{P0,V0}) * \v{P0} * \v{V0} *\\
& \calcgt(0.25 * \calcsum(B(\v{P1,V1}) * \v{V1}) \\
& \qquad \; \; - \calcsum(B(\v{P2,V2}) * \v{V2} * \calcgt(\v{P2-P0})))
\end{align*}

\comment{
\begin{align*}
\calcsum(\tuple{},
& B(P0,V0) * P0 * V0 *\\
& \calceq(\calcsum(B(P1,V1) * V1), X) * \\
& \calceq(\calcsum(B(P2,V2) * V2 * \calcgt(P2-P0)), Y) * \\
& \calcgt(0, 0.25 * X + Y)
\end{align*}
}

\begin{verbatim}
select c.custkey, sum(l1.quantity)
from customer c, orders o, lineitem l1
where 1 <=
    (select sum(1) from lineitem l2
     where l1.orderkey = l2.orderkey
     and 100 < (select sum(l3.quantity)
                from lineitem l3
                where l2.orderkey = l3.orderkey))
and c.custkey = o.custkey
and o.orderkey = l1.orderkey
group by c.custkey;
\end{verbatim}

\begin{align*}
\calcsum(& \tuple{\v{CK}},
  \; C(\v{CK}) * O(\v{OK,OCK}) * L1(\v{OK1,Q1}) * \v{Q} * \\
& \; \calcgte(\calcsum(\tuple{}, L2(\v{OK2}) * 1 *
     \calceq(\v{OK1}+(-\v{OK2})) * \\
& \qquad \quad
    \calcgt(\calcsum(\tuple{}, L3(\v{OK3,Q3}) * \v{Q3} *
    \calceq(\v{OK2} - \v{OK3}))
\\ & \qquad \qquad + (-100)) + (-1)) * \\
& \; \calceq(\v{CK} - \v{OCK}) * \calceq(\v{OK} - \v{OK1})
\end{align*}

\subsection{Delta Queries and Query Compilation}

\begin{align*}
\Delta_{+R(\vec{x} \mapsto \vec{t})} c := & \; 0
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} Var(y) := & \; 0
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} R(\vec{x}) := & \;
\prod_i^{sch(\vec{x})} \calceq(t_i,x_i)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} S(\vec{y}) := & \; 0
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})}
\calcsum(\vec{x},\q) := & \; \calcsum(\vec{x},\Delta\q)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} (\qqa + \qqb) := & \;
(\Delta\qqa + \Delta\qqb)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} (\qqa * \qqb) := & \;
(\Delta \qqa * \qqb) +
(\qqa * \Delta \qqb) +
(\Delta \qqa * \Delta \qqb)
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} \theta(\qq) := & \;
(\theta(\qq + \Delta \qq) * \overline{\theta}(\qq + \Delta \qq)) \; -
\\
& \; (\overline{\theta}(\qq+\Delta \qq) * \theta(\qq))
\\
\end{align*}

\begin{itemize}
  \item Ring of databases, refer to PODS paper
  \item Higher-order deltas, i.e. \textit{k-th} deltas.
\end{itemize}

\tinysection{Deltas of nested queries}

\noindent\todo{Note the equation below relies on iovars, and given our
generalization of bigsum rewriting as preaggregators, should we defer
discussion of compilation of nested queries to after annotation?}

\noindent\todo{
I think we can describe preaggregation without iovars, since our sum construct
explicitly has outvars. WRONG! since the definition of strictness relies on
invars! We can explain invars as Var(x) occurring in the expression.}

\comment{
\begin{align*}
\calcsum(\phi[][\vec{x}] *
(\calcsum(\ldots)[\vec{x}][] * \calceq_\phi[y][] * (\psi[y][]))) \\
\end{align*}
}

\noindent General nested query form:
\begin{align*}
\calcsum(\vec{x}, \qqa * \theta(\qqb))
\end{align*}

\def \pa#1#2{\llbracket #1 \rrbracket_{PA}(#2)}

\noindent Preaggregation (note assumes left-associativity for product):

\begin{align*}
\pa{\calcsum(\vec{x}, \qq)}{\vec{x}} & :=
    \calcsum(\vec{x}, \pa{\qq}{\vec{x} \cup vars(\qq)})
\\
\pa{\qqa + \qqb}{\vec{x}} & := \pa{\qqa}{\vec{x}} + \pa{\qqb}{\vec{x}}
\\
\pa{\qqa * \qqb}{\vec{x}} & :=
    \pa{\qqa}{\vec{x} \cup vars(\qqb)} * \pa{\qqb}{\vec{x}}
\\
\pa{-(\qq)}{\vec{x}} & := -(\pa{\qq}{\vec{x}})
\\
\pa{\theta(\qq)}{\vec{x}} & := \theta(\pa{\qq}{vars(\qq)})
\\
\pa{\calceq(x,\qq)}{\vec{y}} & := \calceq(x, \pa{\qq}{vars(Q)})
\\[1.5ex]
\pa{c}{\vec{x}} & := c
\\
\pa{Var(x)}{\vec{y}} & := Var(x)
\\
\pa{R(\vec{x})}{\vec{y}} & := \calcsum(\vec{x} \cap \vec{y}, R(\vec{x}))
\\
\pa{m(\vec{x})}{\vec{y}} & := \calcsum(\vec{x} \cap \vec{y}, m(\vec{x}))
\\
\pa{f(\vec{x})}{\vec{y}} & := \calcsum(\vec{x} \cap \vec{y}, f(\vec{x}))
   \mbox{  \todo{// what domain?}}
\end{align*}


\noindent Preaggregation example:
\begin{align*}
\pa{\calcsum(\tuple{},
& B(\v{P0,V0}) * \v{P0} * \v{V0} *\\
& \calcgt(0.25 * \calcsum(B(\v{P1,V1}) * \v{V1}) \\
& \qquad \; \; - \calcsum(B(\v{P2,V2}) * \v{V2} * \calcgt(\v{P2-P0})))}
{\tuple{}} :=
\\[1ex]
\calcsum(\tuple{},
& \calcsum(\tuple{\v{P0}}, B(\v{P0,V0}) * \v{P0} * \v{V0}) *\\
& \calcgt(0.25 * \calcsum(B(\v{P1,V1}) * \v{V1}) \\
& \qquad \; \; - \calcsum(B(\v{P2,V2}) * \v{V2} * \calcgt(\v{P2-P0})))
\end{align*}

\begin{itemize}
  \item Apply preaggregation step. This ensures strictness of subqueries for
  correlated variables. Note preaggregation can be useful beyond nested
  queries, it essentially preaggregates relations to only those variables that
  are needed in the rest of the query. We return to this when describing our
  annotated calculus in the next section.
  \item Preaggregation results in a simpler substructure to the query (i.e.
  variables that are aggregated, are eliminated from the outer query).
  \todo{This definition of simpler is different than the concept of degree.
  Perhaps we can define this as the \textit{width} of a query, i.e. the number
  of outvars it has. Thus bigsum rewriting does not simplify in terms of
  degree, but does in term of width. With preaggregation, we are creating
  queries of minimal width w.r.t propagation.}
  \item Equivalent degree of nested constraint delta (i.e. delta not simpler)
  \item Bigsum rewriting
  \item Lower degree delta, exemplified by VWAP.
\end{itemize}

\tinysection{Query normalization and simplification}

\begin{itemize}
  \item Mostly refer to PODS paper.
\end{itemize}

\begin{itemize}
  \item Recursively monomial form
  \item Factorization
  \item Unifying loop variables
\end{itemize}



\subsection{Query Evaluation Annotations}

\begin{itemize}
  \item Input/output variables, cf. binding patterns, datalog.
  \item Provides a compact representation of the core data flow occuring during
        query evaluation, enabling a principled framework to perform all kinds
        of interesting optimizations.
  \item Annotated grammar, see below. Explain constraints on io-vars for
        base elements, e.g. relmaps. 
  \item Top down propagation, left to right propagation.
  \item Propagation diagram generic + for one of the annotated calculus
        examples.
  \item Determining input/output variables. Should occur as part of the
       compilation algorithm. \todo{Presentation: algorithm described before
       this, need to punt explanation of annotation to here.}
  \item \todo{Annotation rules for annotation algorithm?} 
\end{itemize}

\begin{align*} 
\q \; \mbox{::-} & \; R[][\vec{x}] \;|\; c[][] \;|\; Var[x][] \;|\;
m[\vec{x}][\vec{y}]\;|\; f[\vec{x}][]
\\
\comment{
& \;|\; \theta[x,y][] \;|\; \theta_c[x][] \;|\;
\calceq_\q[][y] \;|\; \calceq[x][y]
\\
}
\qq \; \mbox{::-} & \; \q[\vec{x}][\vec{y}] \;|\;
\calcsum(\q[\vec{x}][\vec{y}\vec{z}])[\vec{x}][\vec{z}] \\ & \;|\;
(\qqa[\vec{u}][\vec{v}] + \qqb[\vec{w}][\vec{x}])[\vec{y}][\vec{z}]
\\
& \;|\;
(\qqa[\vec{u}][\vec{vv'}] * \qqb[\vec{v'w}][\vec{x}])[\vec{y}][\vec{z}]
\\
& \;|\; \theta(\qq[\vec{x}][])[\vec{x}][]
\\
& \todo{\;|\; \calceq(\qq[\vec{x}][\vec{y}])}
\end{align*}

\begin{itemize}
\item Comment on lack of output vars in $\theta$, use of $y$ to
represent free var of bf-equality, which was previously an argument to
bf-equality

\item Propagation diagram:
    \begin{itemize}
      \item VWAP AST
      \item Transitive/multistep LR propagation
      \item Top-down bound var propagation, delta essentially binds a relation's
      variables from the very top
      \item No outvars on inequality constraints and nested queries, outvars only
      on bf-equalities
      \item Sum projection as explicit outvar restriction
    \end{itemize}

\end{itemize}

\noindent\todo{Punt annotated semantics to appendix/omit entirely. Should
explain two-level maps though.}

\begin{align*}
R[][\vec{x}]          := & \; \tuple{} \mapsto \vec{x} \mapsto R(\vec{x})\\
c[][]                 := & \; \tuple{} \mapsto \tuple{} \mapsto c\\
Var[x][]              := & \; \tuple{x} \mapsto \tuple{} \mapsto x\\
m[\vec{x}][\vec{y}]   := & \; \vec{x} \mapsto \vec{y} \mapsto
m(\vec{x})(\vec{y})
\\
\theta[x,y][]         := & \; \tuple{x,y} \mapsto \tuple{} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; y \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\theta_c[x][]         := & \; \tuple{x} \mapsto \tuple{} \mapsto
                           \begin{cases}
                           1 \ldots x \; \theta \; c \\
                           0 \ldots \mbox{otherwise.}
                           \end{cases}\\
\calceq_\q[][y]       := & \; \tuple{} \mapsto \tuple{y} \mapsto
                              \q(\tuple{})(\tuple{})
\\
\calceq[x][y]         := & \; \tuple{x} \mapsto \tuple{y} \mapsto x
\\
f[\vec{x}][\vec{y}]   := & \; \vec{x} \mapsto \vec{y} \mapsto f(\vec{x})
\\ 
\\
\calcsum(\q[\vec{x}] & [\vec{y}\vec{z}])[\vec{x}][\vec{y}] := \;
\vec{x} \mapsto \vec{y} \mapsto \ \sum_{\vec{z}} \q(\vec{x})(\vec{y}\vec{z})
\\
(\qqa[\vec{u}][\vec{v}] & + \qqb[\vec{w}][\vec{x}])[\vec{y}][\vec{z}] :=  \\
& \vec{y} \mapsto \sum_{ \{\vec{y}\} = \{\vec{u}\} \Join \{\vec{w}\} }
\vec{z} \mapsto  \sum_{ \{\vec{z}\} = \{\vec{v}\} \Join \{\vec{x}\} }
\qqa(\vec{u})(\vec{v}) + \qqb(\vec{w})(\vec{x})
\\
\\
(\qqa[\vec{u}][\vec{v_1}\vec{v_2}] & * \qqb[\vec{v_2}\vec{w}][\vec{x}])
[\vec{y}][\vec{z}] :=  \\
& \vec{y} \mapsto \sum_{ \{\vec{y}\} = \{\vec{u}\} \Join \{\vec{w}\} }
\vec{z} \mapsto \\
& \qquad \;\;\;
\sum_{ \{\vec{z}\} = \{\vec{v_1}\vec{v_2}\} \Join \{\vec{x}\} }
\qqa(\vec{u})(\vec{v_1}\vec{v_2}) * \qqb(\vec{v_2}\vec{w})(\vec{x}) 
\end{align*}


\tinysection{Annotated calculus examples}

\begin{itemize}
  \item TODO: what about io-vars inside new $\theta$ expression? Since
  $\theta$ inner expression must have no out-vars, how does the var propagation
  work for the inner expression?
\end{itemize}


%% VWAP with base io-vars
\begin{align*}
\calcsum( & B(\v{P0,V0})_{[][\vv{P0,V0}]} * \v{P0} * \v{V0} \; *
\\
& \calcgt(\calcsum(B(\v{P1,V1})_{[][\vv{P1,V1}]} * \v{V1})_{[][]} \; +
\\
& \quad \;\; \calcsum(B(\v{P2,V2})_{[][\vv{P2,V2}]} * \v{V2} *
                 \calcgt(\v{P2}-\v{P0})_{[\vv{P2,P0}][]})_{[\vv{P0}][]}
\\
& \quad )_{[\vv{P0}][]}
\\
& )_{[][]}
\end{align*}

%% VWAP with intermediate io-vars
\begin{align*}
\calcsum( & \tuple{},
    ((B(\v{P0,V0})_{[][\vv{P0,V0}]}
      * \v{P0})_{[][\vv{P0,V0}]}
      * \v{V0})_{[][\vv{P0,V0}]} *
\\
& \calcgt(\calcsum(\tuple{},
    (B(\v{P1,V1})_{[][\vv{P1,V1}]}
     * \v{V1})_{[][\vv{P1,V1}]})_{[][]} +
\\
& \quad \;\; \calcsum(\tuple{},
    ((B(\v{P2,V2})_{[][\vv{P2,V2}]} * \v{V2})_{[][\vv{P2,V2}]} *
\\
& \qquad \qquad
    \calcgt(\v{P2}-\v{P0})_{[\vv{P2,P0}][]})_{[][\vv{P2,V2}]})_{[\vv{P0}][]}
\\
& \quad )_{[\vv{P0}][]}
\\
& )_{[][]}
\end{align*}

%% Old example annotations, with bf-equalities
\comment{
\begin{align*}
\calcsum(((B[][P0,V0] * P0)[][] * V0)[][])
\end{align*}

\begin{align*}
\calcsum((B[][P0] * V0)[V0][])[V0][]
\end{align*}

\begin{align*}
\calcsum( & B[][P0,V0] * P0 * V0 *\\
& (\calcsum(B[][P1,V1] * V1)[][]) * \calceq[][X] * \\
& (\calcsum(B[][P2,V2] * V2 * >[P2,P0][])[P0][] * \calceq[][Y]) * \\
& ((((0.25 * X)[][] + Y)[][] * \calceq[][Z]) * 0[][] * >[Z][]))
\end{align*}


\begin{figure*}[htbp]
\begin{align*}
\calcsum( & ((B[][P0,V0] * P0)[][] * V0)[][] *\\
& ((\calcsum(B[][P1,V1] * V1)[][]) * \calceq[][X] * \\
& (\calcsum(B[][P2,V2] * Var[V2][] * >[P2,P0][])[P0][] * \calceq[][Y]))[][X,Y] *
\\ & ((((0.25 * X)[][] + Y)[][] * \calceq[][Z]) * >0[Z][])[][])[][]
\end{align*}
\end{figure*}
}

\noindent\todo{Punt/omit delta rules for annotated grammar}
%% Delta rules for annotated grammar
%%
\begin{align*}
\Delta_{+R(\vec{x} \mapsto \vec{t})} c[][] := & \; 0[][]
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} Var[y][] := & \; 0[][]
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} R[][\vec{x}] := & \;
\prod_i \calceq[t_i][x_i]
\\
\Delta_{+R(\vec{x} \mapsto \vec{t})} S[][\vec{y}] := & \; 0[][]
\\
\end{align*}

%% Old delta rules for agg,sum,prod w/ io-vars.
%% -- does not represent io-var changes to inner terms, making it useless
%%    for explaining changes to outer terms
\comment{
\begin{align*}
\Delta_{+R(\vec{t})}
\calcsum(\phi[\vec{w}][\vec{x}\vec{y}\vec{z}])[\vec{w}][\vec{x}\vec{y}]
:= & \;
\calcsum(\Delta\phi[\vec{w}][\vec{x}\vec{y}\vec{z}])
[\vec{t}\vec{w}][\vec{y}]
\\
\Delta_{+R(\vec{t})}
(\Phi[\vec{x}][\vec{y}] + \Psi[\vec{z}][\vec{w}])[\vec{u}][\vec{v}]
:= &
((\Delta\Phi[\vec{x}][\vec{y}]) + \Delta\Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots]
\\
\Delta_{+R(\vec{t})}
(\Phi[\vec{x}][\vec{y}] * \Psi[\vec{z}][\vec{w}])[\vec{u}][\vec{v}]
:= &
(((\Delta \Phi[\vec{x}][\vec{y}]) * \Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots] +
\\
& (\Phi[\vec{x}][\vec{y}] * \Delta \Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots] +
\\
& ((\Delta \Phi[\vec{x}][\vec{y}]) * \Delta \Psi[\vec{z}][\vec{w}])
[\vec{t}\vec{u}][\ldots])\\
& \; [\vec{t}\vec{u}][\vec{v}]
\\
\end{align*}
}

\noindent\todo{Rewrite as }

\[
\trfrac{
\Delta_{+R(\vec{x} \mapsto \vec{t})} \phi[\vec{uw}][\vec{xyz}] := 
\phi'[\vec{tw}][\vec{yz}]}
{
\begin{tralign}
\Delta_{+R(\vec{x} \mapsto \vec{t})}
\calcsum(\phi[\vec{uw}][\vec{xyz}])[\vec{uw}][\vec{xy}] & :=
     \calcsum(\Delta \phi[\vec{uw}][\vec{xyz}])[\ldots][\ldots] \\
& := \calcsum(\phi'[\vec{tw}][\vec{yz}])[\vec{tw}][\vec{yz}]
\end{tralign}
}
\]

\[
\trfrac{
\Delta(\Phi[\vec{ab}][\vec{cd}]) := \Phi'[\vec{ta}][\vec{c}] \qquad
\Delta(\Psi[\vec{wx}][\vec{yz}]) := \Psi'[\vec{tw}][\vec{y}]}
{
\begin{tralign}
\Delta((\Phi[\vec{ab}][\vec{cd}] + \Psi[\vec{wx}][\vec{yz}]) &
[\vec{abwx}][\vec{cdyz}]) := \\
& (\Phi'[\vec{ta}][\vec{c}] +
   \Psi'[\vec{tw}][\vec{y}])
  [\vec{taw}][\vec{cy}]
\end{tralign}
}
\]

\[
\trfrac{
\Delta(\Phi[\vec{ab}][\vec{cd}]) := \Phi'[\vec{ta}][\vec{c}] \quad
\Delta(\Psi[\vec{wx}][\vec{yz}]) := \Psi'[\vec{tw}][\vec{y}] \quad
\vec{cd} \cap \vec{wx} = \emptyset}
{
\begin{tralign}
\Delta((\Phi[\vec{ab}][\vec{cd}] * & \Psi[\vec{wx}][\vec{yz}])[abwx][cdyz])
:= \\
&    ((\Phi'[\vec{ta}][\vec{c}] *
       \Psi[\vec{wx}][\vec{yz}])[\vec{tawx}][\vec{cyz}] + \\
& \; (\Phi[\vec{ab}][\vec{cd}] *
       \Psi'[\vec{tw}][\vec{y}])[\vec{tabw}][\vec{cdy}] + \\
& \; (\Phi'[\vec{ta}][\vec{c}] *
      \Psi'[\vec{tw}][\vec{y}])[\vec{taw}][\vec{cy}])[\vec{tabwx}][\vec{cdyz}]
\end{tralign}
}
\]

\noindent\todo{Finish below -- add intermediate io-vars to product case.}

\noindent\todo{Is this case correct? Why should we care about propagated
variables w.r.t to deltas? Can a delta violate propagation and safety?}
\[
\trfrac{
\Delta(\Phi[\vec{ab}][\vec{cdm}]) := \Phi'[\vec{ta}][\vec{c}] \qquad
\Delta(\Psi[\vec{mwx}][\vec{yz}]) := \Psi'[\vec{tw}][\vec{y}]}
{
\begin{tralign}
\Delta((\Phi[\vec{ab}][\vec{cdm}] * \Psi[\vec{mwx}][\vec{yz}])[][])
:= & \;
     ((\Phi'[\vec{ta}][\vec{c}] *
       \Psi[\vec{wx}][\vec{yz}])[][] + \\
& \; (\Phi[\vec{ab}][\vec{cd}] *
       \Psi'[\vec{tw}][\vec{y}])[][] + \\
& \; (\Phi'[\vec{ta}][\vec{c}] *
      \Psi'[\vec{tw}][\vec{y}])[][])[][]
\end{tralign}
}
\]


\[
\trfrac{
\Delta_{+R(\vec{t})}(\Phi[\vec{ab}][]) := \Phi[\vec{ta}][]
}
{
\begin{tralign}
\Delta_{+R(\vec{t})} \theta(\Phi[\vec{ab}][])[\vec{ab}][]
:= & \;
( \theta(\Phi[\vec{ab}][] + \Delta \Phi[\vec{ta}][])[\vec{tab}][] * \\
& \; \;
\overline{\theta}(\Phi[\vec{ab}][])[\vec{ab}][] -
\\
& \; \; \overline{\theta}(\Phi[\vec{ab}][] + \Delta \Phi[\vec{ta}][])
[\vec{tab}][] *
\\
& \; \; \theta(\Phi[\vec{ab}][])[\vec{ab}][]
)[\vec{tab}][]
\end{tralign}
}
\]