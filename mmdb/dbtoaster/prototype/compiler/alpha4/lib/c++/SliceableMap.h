// TODO: to support typed compilation, where map keys may be strings, floats, etc.
// we need extend to this map to support keys with a polymorphic container,
// e.g. boost::ptr_vector
template<typename KeyElement, typename Value>
class SliceableMap
{
public:
    typedef vector<KeyElement>     Key;
    typedef vector<KeyElement>     PartialKey;
    typedef vector<int>            Pattern;
    typedef list<Pattern>          Patterns;
    typedef list< pair<int, int> > KeyIndexMapping;

    // Constructors
    SliceableMap() {}
    SliceableMap(Patterns p) {}

    // Singleton constructor
    static SliceableMap singleton(Patterns p, vector<KeyElement> key, Value v) {}

    virtual boolean exists(Key k) = 0;
    virtual Value find(Key k) = 0;
    virtual void insert(Key k, Value v) = 0;

    // Adds key-values from the given map into this one.
    virtual void union(SliceableMap<KeyElement,Value>& b) = 0;

    // Splits off entries not in the argument from the current map into the result.
    virtual SliceableMap<KeyElement,Value> partition_diff(SliceableMap<KeyElement,Value>& b) = 0;

    virtual list<Key> dom() = 0;
    virtual list<Value> rng() = 0;

    // Reindexing operations

    // Adds the constants given in the extension to the positions specified,
    // shifting existing keys. The positions are all pre-extension positions.
    // If no positions are given, the extension should be appended to the
    // current key.
    virtual void extend_key(PartialKey extension, vector<int> positions) = 0;

    // Reorders keys given by the mapping.
    virtual void reorder_keys(KeyIndexMapping mapping) = 0;

    // Secondary index methods.
    virtual SliceableMap slice(Pattern p, PartialKey pk) = 0;
    virtual list<Key> slice_keys(Pattern p, PartialKey pk) = 0;

    virtual void add_secondary_index(Pattern p) = 0;
    virtual void strip_indexes() = 0;

    // Ensures this map has at least those secondary indexes of the given map.
    // Assumes both maps have the same keys.
    virtual void extend_secondary_indexes(SliceableMap<KeyElement, Value>& b);

    // Arithmetic operations between indexes. Could be done with operator+() etc.
    virtual void sum(SliceableMap<KeyElement,Value>& b) = 0;

    // Relational operations
    enum ProductOp { Add, Subtract, Multiply, Divide };
    enum Aggregate { Sum }; // to be extended to min etc.

    // Computes a cross product with the given map, concatenating keys, and applying
    // the given arithmetic op to pairs of values.
    // To fully compile down AST, we should have a version of product for each op,
    // e.g. with a macro.
    virtual void product(SliceableMap<KeyElement,Value>& b, ProductOp p) = 0;

    // Aggregates over all map values.
    virtual void aggregate(Aggregate agg_fn) = 0;

    // Aggregates over full keys for each partial key for the given pattern.
    virtual void indexed_aggregate(Aggregate agg_fn, Pattern p) = 0;

    // Additional functional interface
    // -- if this is is not present, we will directly inline these methods into
    //    code generated by DBToaster.
    template<Result>
    virtual Result* fold(FoldFunction<Result>& f, Result* init) = 0;

    template<Result>
    virtual SliceableMap<KeyElement, Result>* mapi(MapiFunction<Result>& f) = 0;

    // Function objects
    template<Result> struct FoldFunction {
        virtual Result* operator()(Result* accumulator) = 0;
    };

    template<Result> struct MapiFunction {
        virtual pair<Key, Result> operator()(Key& k, Value& v) = 0;
    };
};
