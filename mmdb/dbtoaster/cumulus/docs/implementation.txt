== Network Layer == 


== Partitions ==
Each Map is indexed by a vector of non-negative integers called a key.  Each value in the vector is referred to as a dimension; An n-dimensional map is indexed by a key of size n.  

Partitioning occurs on a per-dimension basis.  Each dimension is partitioned independently, such that the product of partitions is equal to the number of nodes in the system (uneven distribution schemes are possible, but not produced by the current dbtoaster incarnation - cumulus can handle them, but they must be generated by hand).  By default, partitioning only occurs over the first dimension, but it is possible to override this behavior.  See the Applications.toaster subsection for details.


== Templates ==
(config/template.rb)
The UpdateTemplate class provides a central point for parsing, querying, and applying templates, or triggers.  Templates are loaded by creating an UpdateTemplate object with a template encoded in the following format:

   List(Thing) := [Thing] | [Thing] /, */ [List(Thing)]
   Variable    := /[a-zA-Z0-9_]+/
   Constant    := /0-9/+ | /0-9+/./0-9/*
   Map Entry   := /Map [0-9]+/ "[" [List(Variable | Constant)] "]"
   Op          := "+" | "-" | "*" | "/"
   Expression  := [Variable] | [Constant] | [Map Entry] | "-" [Expression] | "(" [Expression] ")" | [Expression] [Op] [Expression]
   Cmp         := "<=" | "<>" | "<" | "="
   Condition   := [Expression] [Cmp] [Expression] | [Condition] " AND " [Condition]
   Template    := [Relation Name] <tab> [Parameter List] <tab> [Target Map Entry] <tab> [Condition] <tab> [Expression]

* ''Relation Name'' is the name of the relation triggering this template.  It is an arbitrary string containing no tabs or newlines.  By convention, relation names consist only of upper-case letters and underscores, while negative updates (removals) are prefaced with a minus sign. 
* ''Parameter List'' is a List(Variable), an ordered list of the column names from the triggering relation.  These variables will be bound to values while evaluating the template when the update occurs.  Variables occurring in the template that are not specified here will be treated as loop variables; these values will be iterated over for their entire domains.  The naming scheme for ''Parameter List'' need not be consistent across different templates, but must be self consistent within a template.
* ''Target Map Entry'' is a Map Entry specifying the entry (or entries, if it uses a loop variable) to be updated; Though it accepts floating point values, non-integer portions of the value are truncated.
* ''Condition'' is a conjunctive boolean formula; If it evaluates to false, the trigger is not applied (ie, ''Expression'' is treated as if it were 0).
* ''Expression'' is an algebraic formula.  Upon application, Expression is evaluated and the result is added to the corresponding Target Map Entry.  Variables appearing in the expression itself can not be loop variables; all variables except those appearing in Map Entries must be present in the Parameter List.  

In addition to the explicitly provided values listed above, UpdateTemplate also computes or accepts several other implicit values of interest: 

* Index: A unique numerical identifier assigned to this particular template.  This number is used by the Node to convert 
* Variable List: a list of '''loop''' variable names in order of their appearance in the template expression.  When evaluating the template, variables are assigned values using an array of "params".  The ordering of values in the param array corresponds to the concatenation of the parameter list and the variable list.
* LoopVar List: (yes, the naming is confusing) Unlike the Variable List, which contains the '''names''' of the loop variables, this array is used by the node to optimize iterations over a variable's domain.  It is a list of (TemplateEntry Key Dimension -> TemplateVariable) mappings, grouped by TemplateEntry.  These mappings are used to extract the portions of each variable's domain that are actually in use (when computing the cross-product of all template entries received as part of an application).

==== Compilation ====

In order to streamline the process of evaluating updates, each node performs some precomputation to figure out where it needs to send data, and where it expects to receive data from, given a particular update.  For each template, at each node, we compute an n-dimensional grid, one dimension for each variable/parameter in the template's input relation.  The domain of each dimension is the least common multiple of the number of partitions across the variable in each MapEntry in the template it appears in.

  eg: Consider the template: ON MYRELATION(Foo) Map 1[Foo, Bar] += Map 2[Foo] * Map 3[Bar];
  In our layout, Map 1 has a 2x2 partitioning scheme, while Map 2 has 4 partitions.  For this template and 
  layout, we would use a 1-dimensional grid of size 4 (LCM of 2 and 4).  If Map 2 had 5 partitions, we would 
  use a 1-dimensional grid of size 10 (LCM of 2 and 5).  However, because we use powers of 2 for our 
  partitioning, the LCM is always the MAX number of partitions over that variable.

Each cell in the grid indicates, for the node, which nodes it should push_get to, and which nodes it should expect push_gets from.  When an update arrives, the grid is consulted and the appropriate directives are followed. 

This grid is stored, jointly with the grids of all other templates in org.dbtoaster.cumulus.config.CompiledM3Program; A template is loaded into CompiledM3Program by calling UpdateTemplate.compile_to_local (see examples in node/node.rb/MapNodeHandler).  This first produces an allocation grid; an expansion of the grid with dimensionality n+m, where m is the number of loop variables; The full allocation grid is then projected down (to compute the nodes to which an update at the local node needs to send data) and inverted (to compute the nodes the local node expects data from).

==== (E)Valuation ====
After update arrives, the class TemplateValuation computes the full set of map entries the trigger modifies.  A valuation is created by calling UpdateTemplate.valuation(params)  

Once created, the valuation has 3 operations: 
* discover(entry, value): Inform the TemplateValuation that entry := value, where entry is relevant to this valuation.  A warning will be issued if the TemplateValuation is unable to use the entry.
* ready?(): Verify whether or not the valuation can produce at least one result.  Note: in the case of mass-puts, this is not a relevant operation, as the valuation may not produce any results even if it is ready.
* foreach() { |entry,value| }: Iterate over all entry += value results produced by this valuation.  

foreach and its interactions with loop variables deserves some extra discussion.  We observe the following properties of M3 triggers:
* Each loop variable occurs at most once in the target map, and exactly once in the source expression.
* Loop variables occur only in TemplateEntries in the target map.
* If any TemplateEntry in the trigger is zero for a particular valuation of the loop variables, the entire trigger delta is zero.
Because of the last point, the domain of loop variables is constrained to those values already defined.  Thus, the nonzero domains of the loop variables can be extracted from the cross product of the MapEntries filling each TemplateEntry in the map expression.

As MapEntries are discovered()ed, TemplateValuation figures out which TemplateEntry (or entries, potentially) the MapEntry corresponds to, and adds it to a list set up for that TemplateEntry.  While foreach() is running, we enumerate all possible combinations of TemplateEntry instantiations and obtain the valuation of the loop variables from those entries.  Because the variables appear only once on the RHS of the template, we can avoid equality tests.

As an aside, util/ok_mixins.rb/Array.each_cross_product is called on an Array of Arrays with a block.  The block is evaluated once on every row of the cross product of the inner arrays; For example, 
  [ [ A, B ], [ C ], [ D, E ] ].each_cross_product { |row| puts row.join(", ") }
    produces:
  A, C, D
  A, C, E
  B, C, D
  B, C, E

== Node ==
The administrative center of the node is in node/node.rb/MapNodeHandler, while the data backend is node/versionedmap.rb/VersionedMap.  

==== VersionedMap ====
VersionedMap adds a callback mechanism to the underlying n-dimensional key map implementation (node/multikeymap*.rb; currently the Java BDB implementation).  Puts into the map are implemented through a level of indirection:
* call MapPartition.declare_pending to get a PendingRecord
* call PendingRecord.discover(key, delta) to indicate the delta values for each key associated with this put. (one put can modify several map entries within a map)
* call PendingRecord.finish
* Equivalently, the utility function MapPartition.update performs all three of the above tasks for one MapEntry.

This level of indirection makes it possible to "batch" updates in a sequential order.  More importantly, it makes it possible to ensure sequencing of puts and gets, even if the puts occur out of order.  Consequently, a callback layer is also required for gets; MapPartition.get(target, on_entry, on_finish) takes two callback parameters: 
* on_entry: proc { |key, value| ## This code gets executed once for every key/value pair matching target ## } 
* on_finish: proc { ## This code gets executed at the end; on_entry will not be called again ## }

Note: The values a get reads will be the values at the ''logical'' time the get was issued.  All puts still pending (for which PendingRecord.finish has not been called) will be complete before the get begins returning values.

==== NodeHandler.update ====
The primary entry point is update(), called once every time a base relation is modified.  Update works in two phases: fetch and put, both directed by the CompiledM3Program described above.

The fetch phase registers all read requests necessary for the update and prepares to send them when the values are ready.  
* Create a PluralRemoteCommitNotification for each template the update triggers
* For each MapEntry required (even if there are loop variables in the entry's key), create one PluralRemoteCommitSubquery (technically, one PluralRemoteSubquery is created per Map Partition for the MapEntry's source map)
* Perform a get for the MapEntry and tie the callbacks to the PluralRemoteCommitSubquery instance
Once all the subqueries in a RemoteCommitNotification have completed (the get's on_finish callback has been called), the RemoteCommitNotification sends a push_get message to each node expecting a result (even if there are no MapEntries to send)

The put phase declares all puts that might occur as a result of this update, regardless of whether or not all data is currently available to execute the put.  A variant of the process is used if there are no loop variables required to optimize for this special case.  For every put required by the update: 
* Create a TemplateValuation.
* Create a (Mass)ValuationApplicator and associate the TemplateValuation with it.
* Call MapNodeHandler.preload_locals to:
** perform an implicit read on all relevant local partitions
** check @cmdcallbacks to figure out if any push_gets have already been received for this update
** associate the (Mass)ValuationApplicator with @cmdcallbacks if necessary, so any further required push_gets will be directed properly.
* Use (Mass)ValuationApplicator.apply to finalize the process; Either use VersionedMap.declare_pending on all partitions affected by the put if necessary, or apply the updates directly if possible.
* ... wait for push_gets to arrive as needed
* (Mass)ValuationApplicator calls MapNodeHandler.finish_valuating to remove itself from @cmdcallbacks.

There are several differences between MassValuationApplicator and ValuationApplicator:
* ValuationApplicator considers itself ready once it has exactly one value matching each TemplateEntry, while MassValuationApplicator considers itself ready once it has received a precomputed number of messages from other nodes.
* ValuationApplicator uses to_f to compute the one update it needs to perform, and uses VersionedMap.discover() to streamline insertion, while MassValuationApplicator uses declare_pending explicitly. 
