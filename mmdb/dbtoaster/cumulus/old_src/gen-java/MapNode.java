/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

public class MapNode {

  public interface Iface {

    public void put(long id, long template, List<Double> params) throws TException;

    public void mass_put(long id, long template, long expected_gets, List<Double> params) throws TException;

    public Map<MapEntry,Double> get(List<MapEntry> target) throws SpreadException, TException;

    public void fetch(List<MapEntry> target, NodeID destination, long cmdid) throws TException;

    public void push_get(Map<MapEntry,Double> result, long cmdid) throws TException;

    public void meta_request(long base_cmd, List<PutRequest> put_list, List<GetRequest> get_list, List<Double> params) throws TException;

    public Map<MapEntry,Double> aggreget(List<MapEntry> target, AggregateType agg) throws SpreadException, TException;

    public String dump() throws TException;

    public void localdump() throws TException;

  }

  public static class Client implements Iface {
    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public void put(long id, long template, List<Double> params) throws TException
    {
      send_put(id, template, params);
    }

    public void send_put(long id, long template, List<Double> params) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("put", TMessageType.CALL, seqid_));
      put_args args = new put_args();
      args.id = id;
      args.template = template;
      args.params = params;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void mass_put(long id, long template, long expected_gets, List<Double> params) throws TException
    {
      send_mass_put(id, template, expected_gets, params);
    }

    public void send_mass_put(long id, long template, long expected_gets, List<Double> params) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("mass_put", TMessageType.CALL, seqid_));
      mass_put_args args = new mass_put_args();
      args.id = id;
      args.template = template;
      args.expected_gets = expected_gets;
      args.params = params;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<MapEntry,Double> get(List<MapEntry> target) throws SpreadException, TException
    {
      send_get(target);
      return recv_get();
    }

    public void send_get(List<MapEntry> target) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("get", TMessageType.CALL, seqid_));
      get_args args = new get_args();
      args.target = target;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<MapEntry,Double> recv_get() throws SpreadException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      get_result result = new get_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
    }

    public void fetch(List<MapEntry> target, NodeID destination, long cmdid) throws TException
    {
      send_fetch(target, destination, cmdid);
    }

    public void send_fetch(List<MapEntry> target, NodeID destination, long cmdid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("fetch", TMessageType.CALL, seqid_));
      fetch_args args = new fetch_args();
      args.target = target;
      args.destination = destination;
      args.cmdid = cmdid;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void push_get(Map<MapEntry,Double> result, long cmdid) throws TException
    {
      send_push_get(result, cmdid);
    }

    public void send_push_get(Map<MapEntry,Double> result, long cmdid) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("push_get", TMessageType.CALL, seqid_));
      push_get_args args = new push_get_args();
      args.result = result;
      args.cmdid = cmdid;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void meta_request(long base_cmd, List<PutRequest> put_list, List<GetRequest> get_list, List<Double> params) throws TException
    {
      send_meta_request(base_cmd, put_list, get_list, params);
    }

    public void send_meta_request(long base_cmd, List<PutRequest> put_list, List<GetRequest> get_list, List<Double> params) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("meta_request", TMessageType.CALL, seqid_));
      meta_request_args args = new meta_request_args();
      args.base_cmd = base_cmd;
      args.put_list = put_list;
      args.get_list = get_list;
      args.params = params;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<MapEntry,Double> aggreget(List<MapEntry> target, AggregateType agg) throws SpreadException, TException
    {
      send_aggreget(target, agg);
      return recv_aggreget();
    }

    public void send_aggreget(List<MapEntry> target, AggregateType agg) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("aggreget", TMessageType.CALL, seqid_));
      aggreget_args args = new aggreget_args();
      args.target = target;
      args.agg = agg;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Map<MapEntry,Double> recv_aggreget() throws SpreadException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      aggreget_result result = new aggreget_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.error != null) {
        throw result.error;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "aggreget failed: unknown result");
    }

    public String dump() throws TException
    {
      send_dump();
      return recv_dump();
    }

    public void send_dump() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("dump", TMessageType.CALL, seqid_));
      dump_args args = new dump_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public String recv_dump() throws TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      dump_result result = new dump_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "dump failed: unknown result");
    }

    public void localdump() throws TException
    {
      send_localdump();
    }

    public void send_localdump() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("localdump", TMessageType.CALL, seqid_));
      localdump_args args = new localdump_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

  }
  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("put", new put());
      processMap_.put("mass_put", new mass_put());
      processMap_.put("get", new get());
      processMap_.put("fetch", new fetch());
      processMap_.put("push_get", new push_get());
      processMap_.put("meta_request", new meta_request());
      processMap_.put("aggreget", new aggreget());
      processMap_.put("dump", new dump());
      processMap_.put("localdump", new localdump());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class put implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        put_args args = new put_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.put(args.id, args.template, args.params);
        return;
      }
    }

    private class mass_put implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        mass_put_args args = new mass_put_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.mass_put(args.id, args.template, args.expected_gets, args.params);
        return;
      }
    }

    private class get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        get_args args = new get_args();
        args.read(iprot);
        iprot.readMessageEnd();
        get_result result = new get_result();
        try {
          result.success = iface_.get(args.target);
        } catch (SpreadException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing get", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
          oprot.writeMessageBegin(new TMessage("get", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("get", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class fetch implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        fetch_args args = new fetch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.fetch(args.target, args.destination, args.cmdid);
        return;
      }
    }

    private class push_get implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        push_get_args args = new push_get_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.push_get(args.result, args.cmdid);
        return;
      }
    }

    private class meta_request implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        meta_request_args args = new meta_request_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.meta_request(args.base_cmd, args.put_list, args.get_list, args.params);
        return;
      }
    }

    private class aggreget implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        aggreget_args args = new aggreget_args();
        args.read(iprot);
        iprot.readMessageEnd();
        aggreget_result result = new aggreget_result();
        try {
          result.success = iface_.aggreget(args.target, args.agg);
        } catch (SpreadException error) {
          result.error = error;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing aggreget", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing aggreget");
          oprot.writeMessageBegin(new TMessage("aggreget", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("aggreget", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class dump implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        dump_args args = new dump_args();
        args.read(iprot);
        iprot.readMessageEnd();
        dump_result result = new dump_result();
        result.success = iface_.dump();
        oprot.writeMessageBegin(new TMessage("dump", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class localdump implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        localdump_args args = new localdump_args();
        args.read(iprot);
        iprot.readMessageEnd();
        iface_.localdump();
        return;
      }
    }

  }

  public static class put_args implements TBase<put_args._Fields>, java.io.Serializable, Cloneable, Comparable<put_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("put_args");

    private static final TField ID_FIELD_DESC = new TField("id", TType.I64, (short)1);
    private static final TField TEMPLATE_FIELD_DESC = new TField("template", TType.I64, (short)2);
    private static final TField PARAMS_FIELD_DESC = new TField("params", TType.LIST, (short)3);

    public long id;
    public long template;
    public List<Double> params;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ID((short)1, "id"),
      TEMPLATE((short)2, "template"),
      PARAMS((short)3, "params");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __ID_ISSET_ID = 0;
    private static final int __TEMPLATE_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.ID, new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.TEMPLATE, new FieldMetaData("template", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.PARAMS, new FieldMetaData("params", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(put_args.class, metaDataMap);
    }

    public put_args() {
    }

    public put_args(
      long id,
      long template,
      List<Double> params)
    {
      this();
      this.id = id;
      setIdIsSet(true);
      this.template = template;
      setTemplateIsSet(true);
      this.params = params;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public put_args(put_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.id = other.id;
      this.template = other.template;
      if (other.isSetParams()) {
        List<Double> __this__params = new ArrayList<Double>();
        for (Double other_element : other.params) {
          __this__params.add(other_element);
        }
        this.params = __this__params;
      }
    }

    public put_args deepCopy() {
      return new put_args(this);
    }

    @Deprecated
    public put_args clone() {
      return new put_args(this);
    }

    public long getId() {
      return this.id;
    }

    public put_args setId(long id) {
      this.id = id;
      setIdIsSet(true);
      return this;
    }

    public void unsetId() {
      __isset_bit_vector.clear(__ID_ISSET_ID);
    }

    /** Returns true if field id is set (has been asigned a value) and false otherwise */
    public boolean isSetId() {
      return __isset_bit_vector.get(__ID_ISSET_ID);
    }

    public void setIdIsSet(boolean value) {
      __isset_bit_vector.set(__ID_ISSET_ID, value);
    }

    public long getTemplate() {
      return this.template;
    }

    public put_args setTemplate(long template) {
      this.template = template;
      setTemplateIsSet(true);
      return this;
    }

    public void unsetTemplate() {
      __isset_bit_vector.clear(__TEMPLATE_ISSET_ID);
    }

    /** Returns true if field template is set (has been asigned a value) and false otherwise */
    public boolean isSetTemplate() {
      return __isset_bit_vector.get(__TEMPLATE_ISSET_ID);
    }

    public void setTemplateIsSet(boolean value) {
      __isset_bit_vector.set(__TEMPLATE_ISSET_ID, value);
    }

    public int getParamsSize() {
      return (this.params == null) ? 0 : this.params.size();
    }

    public java.util.Iterator<Double> getParamsIterator() {
      return (this.params == null) ? null : this.params.iterator();
    }

    public void addToParams(double elem) {
      if (this.params == null) {
        this.params = new ArrayList<Double>();
      }
      this.params.add(elem);
    }

    public List<Double> getParams() {
      return this.params;
    }

    public put_args setParams(List<Double> params) {
      this.params = params;
      return this;
    }

    public void unsetParams() {
      this.params = null;
    }

    /** Returns true if field params is set (has been asigned a value) and false otherwise */
    public boolean isSetParams() {
      return this.params != null;
    }

    public void setParamsIsSet(boolean value) {
      if (!value) {
        this.params = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          setId((Long)value);
        }
        break;

      case TEMPLATE:
        if (value == null) {
          unsetTemplate();
        } else {
          setTemplate((Long)value);
        }
        break;

      case PARAMS:
        if (value == null) {
          unsetParams();
        } else {
          setParams((List<Double>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ID:
        return new Long(getId());

      case TEMPLATE:
        return new Long(getTemplate());

      case PARAMS:
        return getParams();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case ID:
        return isSetId();
      case TEMPLATE:
        return isSetTemplate();
      case PARAMS:
        return isSetParams();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof put_args)
        return this.equals((put_args)that);
      return false;
    }

    public boolean equals(put_args that) {
      if (that == null)
        return false;

      boolean this_present_id = true;
      boolean that_present_id = true;
      if (this_present_id || that_present_id) {
        if (!(this_present_id && that_present_id))
          return false;
        if (this.id != that.id)
          return false;
      }

      boolean this_present_template = true;
      boolean that_present_template = true;
      if (this_present_template || that_present_template) {
        if (!(this_present_template && that_present_template))
          return false;
        if (this.template != that.template)
          return false;
      }

      boolean this_present_params = true && this.isSetParams();
      boolean that_present_params = true && that.isSetParams();
      if (this_present_params || that_present_params) {
        if (!(this_present_params && that_present_params))
          return false;
        if (!this.params.equals(that.params))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(put_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      put_args typedOther = (put_args)other;

      lastComparison = Boolean.valueOf(isSetId()).compareTo(isSetId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(id, typedOther.id);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTemplate()).compareTo(isSetTemplate());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(template, typedOther.template);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetParams()).compareTo(isSetParams());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(params, typedOther.params);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case ID:
              if (field.type == TType.I64) {
                this.id = iprot.readI64();
                setIdIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TEMPLATE:
              if (field.type == TType.I64) {
                this.template = iprot.readI64();
                setTemplateIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case PARAMS:
              if (field.type == TType.LIST) {
                {
                  TList _list12 = iprot.readListBegin();
                  this.params = new ArrayList<Double>(_list12.size);
                  for (int _i13 = 0; _i13 < _list12.size; ++_i13)
                  {
                    double _elem14;
                    _elem14 = iprot.readDouble();
                    this.params.add(_elem14);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI64(this.id);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(TEMPLATE_FIELD_DESC);
      oprot.writeI64(this.template);
      oprot.writeFieldEnd();
      if (this.params != null) {
        oprot.writeFieldBegin(PARAMS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.params.size()));
          for (double _iter15 : this.params)
          {
            oprot.writeDouble(_iter15);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("put_args(");
      boolean first = true;

      sb.append("id:");
      sb.append(this.id);
      first = false;
      if (!first) sb.append(", ");
      sb.append("template:");
      sb.append(this.template);
      first = false;
      if (!first) sb.append(", ");
      sb.append("params:");
      if (this.params == null) {
        sb.append("null");
      } else {
        sb.append(this.params);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class mass_put_args implements TBase<mass_put_args._Fields>, java.io.Serializable, Cloneable, Comparable<mass_put_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("mass_put_args");

    private static final TField ID_FIELD_DESC = new TField("id", TType.I64, (short)1);
    private static final TField TEMPLATE_FIELD_DESC = new TField("template", TType.I64, (short)2);
    private static final TField EXPECTED_GETS_FIELD_DESC = new TField("expected_gets", TType.I64, (short)3);
    private static final TField PARAMS_FIELD_DESC = new TField("params", TType.LIST, (short)4);

    public long id;
    public long template;
    public long expected_gets;
    public List<Double> params;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      ID((short)1, "id"),
      TEMPLATE((short)2, "template"),
      EXPECTED_GETS((short)3, "expected_gets"),
      PARAMS((short)4, "params");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __ID_ISSET_ID = 0;
    private static final int __TEMPLATE_ISSET_ID = 1;
    private static final int __EXPECTED_GETS_ISSET_ID = 2;
    private BitSet __isset_bit_vector = new BitSet(3);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.ID, new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.TEMPLATE, new FieldMetaData("template", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.EXPECTED_GETS, new FieldMetaData("expected_gets", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.PARAMS, new FieldMetaData("params", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(mass_put_args.class, metaDataMap);
    }

    public mass_put_args() {
    }

    public mass_put_args(
      long id,
      long template,
      long expected_gets,
      List<Double> params)
    {
      this();
      this.id = id;
      setIdIsSet(true);
      this.template = template;
      setTemplateIsSet(true);
      this.expected_gets = expected_gets;
      setExpected_getsIsSet(true);
      this.params = params;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public mass_put_args(mass_put_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.id = other.id;
      this.template = other.template;
      this.expected_gets = other.expected_gets;
      if (other.isSetParams()) {
        List<Double> __this__params = new ArrayList<Double>();
        for (Double other_element : other.params) {
          __this__params.add(other_element);
        }
        this.params = __this__params;
      }
    }

    public mass_put_args deepCopy() {
      return new mass_put_args(this);
    }

    @Deprecated
    public mass_put_args clone() {
      return new mass_put_args(this);
    }

    public long getId() {
      return this.id;
    }

    public mass_put_args setId(long id) {
      this.id = id;
      setIdIsSet(true);
      return this;
    }

    public void unsetId() {
      __isset_bit_vector.clear(__ID_ISSET_ID);
    }

    /** Returns true if field id is set (has been asigned a value) and false otherwise */
    public boolean isSetId() {
      return __isset_bit_vector.get(__ID_ISSET_ID);
    }

    public void setIdIsSet(boolean value) {
      __isset_bit_vector.set(__ID_ISSET_ID, value);
    }

    public long getTemplate() {
      return this.template;
    }

    public mass_put_args setTemplate(long template) {
      this.template = template;
      setTemplateIsSet(true);
      return this;
    }

    public void unsetTemplate() {
      __isset_bit_vector.clear(__TEMPLATE_ISSET_ID);
    }

    /** Returns true if field template is set (has been asigned a value) and false otherwise */
    public boolean isSetTemplate() {
      return __isset_bit_vector.get(__TEMPLATE_ISSET_ID);
    }

    public void setTemplateIsSet(boolean value) {
      __isset_bit_vector.set(__TEMPLATE_ISSET_ID, value);
    }

    public long getExpected_gets() {
      return this.expected_gets;
    }

    public mass_put_args setExpected_gets(long expected_gets) {
      this.expected_gets = expected_gets;
      setExpected_getsIsSet(true);
      return this;
    }

    public void unsetExpected_gets() {
      __isset_bit_vector.clear(__EXPECTED_GETS_ISSET_ID);
    }

    /** Returns true if field expected_gets is set (has been asigned a value) and false otherwise */
    public boolean isSetExpected_gets() {
      return __isset_bit_vector.get(__EXPECTED_GETS_ISSET_ID);
    }

    public void setExpected_getsIsSet(boolean value) {
      __isset_bit_vector.set(__EXPECTED_GETS_ISSET_ID, value);
    }

    public int getParamsSize() {
      return (this.params == null) ? 0 : this.params.size();
    }

    public java.util.Iterator<Double> getParamsIterator() {
      return (this.params == null) ? null : this.params.iterator();
    }

    public void addToParams(double elem) {
      if (this.params == null) {
        this.params = new ArrayList<Double>();
      }
      this.params.add(elem);
    }

    public List<Double> getParams() {
      return this.params;
    }

    public mass_put_args setParams(List<Double> params) {
      this.params = params;
      return this;
    }

    public void unsetParams() {
      this.params = null;
    }

    /** Returns true if field params is set (has been asigned a value) and false otherwise */
    public boolean isSetParams() {
      return this.params != null;
    }

    public void setParamsIsSet(boolean value) {
      if (!value) {
        this.params = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case ID:
        if (value == null) {
          unsetId();
        } else {
          setId((Long)value);
        }
        break;

      case TEMPLATE:
        if (value == null) {
          unsetTemplate();
        } else {
          setTemplate((Long)value);
        }
        break;

      case EXPECTED_GETS:
        if (value == null) {
          unsetExpected_gets();
        } else {
          setExpected_gets((Long)value);
        }
        break;

      case PARAMS:
        if (value == null) {
          unsetParams();
        } else {
          setParams((List<Double>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case ID:
        return new Long(getId());

      case TEMPLATE:
        return new Long(getTemplate());

      case EXPECTED_GETS:
        return new Long(getExpected_gets());

      case PARAMS:
        return getParams();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case ID:
        return isSetId();
      case TEMPLATE:
        return isSetTemplate();
      case EXPECTED_GETS:
        return isSetExpected_gets();
      case PARAMS:
        return isSetParams();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof mass_put_args)
        return this.equals((mass_put_args)that);
      return false;
    }

    public boolean equals(mass_put_args that) {
      if (that == null)
        return false;

      boolean this_present_id = true;
      boolean that_present_id = true;
      if (this_present_id || that_present_id) {
        if (!(this_present_id && that_present_id))
          return false;
        if (this.id != that.id)
          return false;
      }

      boolean this_present_template = true;
      boolean that_present_template = true;
      if (this_present_template || that_present_template) {
        if (!(this_present_template && that_present_template))
          return false;
        if (this.template != that.template)
          return false;
      }

      boolean this_present_expected_gets = true;
      boolean that_present_expected_gets = true;
      if (this_present_expected_gets || that_present_expected_gets) {
        if (!(this_present_expected_gets && that_present_expected_gets))
          return false;
        if (this.expected_gets != that.expected_gets)
          return false;
      }

      boolean this_present_params = true && this.isSetParams();
      boolean that_present_params = true && that.isSetParams();
      if (this_present_params || that_present_params) {
        if (!(this_present_params && that_present_params))
          return false;
        if (!this.params.equals(that.params))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(mass_put_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      mass_put_args typedOther = (mass_put_args)other;

      lastComparison = Boolean.valueOf(isSetId()).compareTo(isSetId());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(id, typedOther.id);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetTemplate()).compareTo(isSetTemplate());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(template, typedOther.template);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetExpected_gets()).compareTo(isSetExpected_gets());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(expected_gets, typedOther.expected_gets);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetParams()).compareTo(isSetParams());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(params, typedOther.params);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case ID:
              if (field.type == TType.I64) {
                this.id = iprot.readI64();
                setIdIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case TEMPLATE:
              if (field.type == TType.I64) {
                this.template = iprot.readI64();
                setTemplateIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case EXPECTED_GETS:
              if (field.type == TType.I64) {
                this.expected_gets = iprot.readI64();
                setExpected_getsIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case PARAMS:
              if (field.type == TType.LIST) {
                {
                  TList _list16 = iprot.readListBegin();
                  this.params = new ArrayList<Double>(_list16.size);
                  for (int _i17 = 0; _i17 < _list16.size; ++_i17)
                  {
                    double _elem18;
                    _elem18 = iprot.readDouble();
                    this.params.add(_elem18);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(ID_FIELD_DESC);
      oprot.writeI64(this.id);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(TEMPLATE_FIELD_DESC);
      oprot.writeI64(this.template);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(EXPECTED_GETS_FIELD_DESC);
      oprot.writeI64(this.expected_gets);
      oprot.writeFieldEnd();
      if (this.params != null) {
        oprot.writeFieldBegin(PARAMS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.params.size()));
          for (double _iter19 : this.params)
          {
            oprot.writeDouble(_iter19);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("mass_put_args(");
      boolean first = true;

      sb.append("id:");
      sb.append(this.id);
      first = false;
      if (!first) sb.append(", ");
      sb.append("template:");
      sb.append(this.template);
      first = false;
      if (!first) sb.append(", ");
      sb.append("expected_gets:");
      sb.append(this.expected_gets);
      first = false;
      if (!first) sb.append(", ");
      sb.append("params:");
      if (this.params == null) {
        sb.append("null");
      } else {
        sb.append(this.params);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_args implements TBase<get_args._Fields>, java.io.Serializable, Cloneable, Comparable<get_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("get_args");

    private static final TField TARGET_FIELD_DESC = new TField("target", TType.LIST, (short)1);

    public List<MapEntry> target;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TARGET((short)1, "target");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TARGET, new FieldMetaData("target", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, MapEntry.class))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_args.class, metaDataMap);
    }

    public get_args() {
    }

    public get_args(
      List<MapEntry> target)
    {
      this();
      this.target = target;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_args(get_args other) {
      if (other.isSetTarget()) {
        List<MapEntry> __this__target = new ArrayList<MapEntry>();
        for (MapEntry other_element : other.target) {
          __this__target.add(new MapEntry(other_element));
        }
        this.target = __this__target;
      }
    }

    public get_args deepCopy() {
      return new get_args(this);
    }

    @Deprecated
    public get_args clone() {
      return new get_args(this);
    }

    public int getTargetSize() {
      return (this.target == null) ? 0 : this.target.size();
    }

    public java.util.Iterator<MapEntry> getTargetIterator() {
      return (this.target == null) ? null : this.target.iterator();
    }

    public void addToTarget(MapEntry elem) {
      if (this.target == null) {
        this.target = new ArrayList<MapEntry>();
      }
      this.target.add(elem);
    }

    public List<MapEntry> getTarget() {
      return this.target;
    }

    public get_args setTarget(List<MapEntry> target) {
      this.target = target;
      return this;
    }

    public void unsetTarget() {
      this.target = null;
    }

    /** Returns true if field target is set (has been asigned a value) and false otherwise */
    public boolean isSetTarget() {
      return this.target != null;
    }

    public void setTargetIsSet(boolean value) {
      if (!value) {
        this.target = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TARGET:
        if (value == null) {
          unsetTarget();
        } else {
          setTarget((List<MapEntry>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TARGET:
        return getTarget();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TARGET:
        return isSetTarget();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_args)
        return this.equals((get_args)that);
      return false;
    }

    public boolean equals(get_args that) {
      if (that == null)
        return false;

      boolean this_present_target = true && this.isSetTarget();
      boolean that_present_target = true && that.isSetTarget();
      if (this_present_target || that_present_target) {
        if (!(this_present_target && that_present_target))
          return false;
        if (!this.target.equals(that.target))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(get_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      get_args typedOther = (get_args)other;

      lastComparison = Boolean.valueOf(isSetTarget()).compareTo(isSetTarget());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(target, typedOther.target);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TARGET:
              if (field.type == TType.LIST) {
                {
                  TList _list20 = iprot.readListBegin();
                  this.target = new ArrayList<MapEntry>(_list20.size);
                  for (int _i21 = 0; _i21 < _list20.size; ++_i21)
                  {
                    MapEntry _elem22;
                    _elem22 = new MapEntry();
                    _elem22.read(iprot);
                    this.target.add(_elem22);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.target != null) {
        oprot.writeFieldBegin(TARGET_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.target.size()));
          for (MapEntry _iter23 : this.target)
          {
            _iter23.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_args(");
      boolean first = true;

      sb.append("target:");
      if (this.target == null) {
        sb.append("null");
      } else {
        sb.append(this.target);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class get_result implements TBase<get_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("get_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public Map<MapEntry,Double> success;
    public SpreadException error;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      ERROR((short)1, "error");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.MAP)));
      put(_Fields.ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(get_result.class, metaDataMap);
    }

    public get_result() {
    }

    public get_result(
      Map<MapEntry,Double> success,
      SpreadException error)
    {
      this();
      this.success = success;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public get_result(get_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetError()) {
        this.error = new SpreadException(other.error);
      }
    }

    public get_result deepCopy() {
      return new get_result(this);
    }

    @Deprecated
    public get_result clone() {
      return new get_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(MapEntry key, double val) {
      if (this.success == null) {
        this.success = new HashMap<MapEntry,Double>();
      }
      this.success.put(key, val);
    }

    public Map<MapEntry,Double> getSuccess() {
      return this.success;
    }

    public get_result setSuccess(Map<MapEntry,Double> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public SpreadException getError() {
      return this.error;
    }

    public get_result setError(SpreadException error) {
      this.error = error;
      return this;
    }

    public void unsetError() {
      this.error = null;
    }

    /** Returns true if field error is set (has been asigned a value) and false otherwise */
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<MapEntry,Double>)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((SpreadException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof get_result)
        return this.equals((get_result)that);
      return false;
    }

    public boolean equals(get_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.MAP) {
                {
                  TMap _map24 = iprot.readMapBegin();
                  this.success = new HashMap<MapEntry,Double>(2*_map24.size);
                  for (int _i25 = 0; _i25 < _map24.size; ++_i25)
                  {
                    MapEntry _key26;
                    double _val27;
                    _key26 = new MapEntry();
                    _key26.read(iprot);
                    _val27 = iprot.readDouble();
                    this.success.put(_key26, _val27);
                  }
                  iprot.readMapEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ERROR:
              if (field.type == TType.STRUCT) {
                this.error = new SpreadException();
                this.error.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRUCT, TType.DOUBLE, this.success.size()));
          for (Map.Entry<MapEntry, Double> _iter28 : this.success.entrySet())
          {
            _iter28.getKey().write(oprot);
            oprot.writeDouble(_iter28.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("get_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class fetch_args implements TBase<fetch_args._Fields>, java.io.Serializable, Cloneable, Comparable<fetch_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("fetch_args");

    private static final TField TARGET_FIELD_DESC = new TField("target", TType.LIST, (short)1);
    private static final TField DESTINATION_FIELD_DESC = new TField("destination", TType.STRUCT, (short)2);
    private static final TField CMDID_FIELD_DESC = new TField("cmdid", TType.I64, (short)3);

    public List<MapEntry> target;
    public NodeID destination;
    public long cmdid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TARGET((short)1, "target"),
      DESTINATION((short)2, "destination"),
      CMDID((short)3, "cmdid");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __CMDID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TARGET, new FieldMetaData("target", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, MapEntry.class))));
      put(_Fields.DESTINATION, new FieldMetaData("destination", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, NodeID.class)));
      put(_Fields.CMDID, new FieldMetaData("cmdid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(fetch_args.class, metaDataMap);
    }

    public fetch_args() {
    }

    public fetch_args(
      List<MapEntry> target,
      NodeID destination,
      long cmdid)
    {
      this();
      this.target = target;
      this.destination = destination;
      this.cmdid = cmdid;
      setCmdidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public fetch_args(fetch_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetTarget()) {
        List<MapEntry> __this__target = new ArrayList<MapEntry>();
        for (MapEntry other_element : other.target) {
          __this__target.add(new MapEntry(other_element));
        }
        this.target = __this__target;
      }
      if (other.isSetDestination()) {
        this.destination = new NodeID(other.destination);
      }
      this.cmdid = other.cmdid;
    }

    public fetch_args deepCopy() {
      return new fetch_args(this);
    }

    @Deprecated
    public fetch_args clone() {
      return new fetch_args(this);
    }

    public int getTargetSize() {
      return (this.target == null) ? 0 : this.target.size();
    }

    public java.util.Iterator<MapEntry> getTargetIterator() {
      return (this.target == null) ? null : this.target.iterator();
    }

    public void addToTarget(MapEntry elem) {
      if (this.target == null) {
        this.target = new ArrayList<MapEntry>();
      }
      this.target.add(elem);
    }

    public List<MapEntry> getTarget() {
      return this.target;
    }

    public fetch_args setTarget(List<MapEntry> target) {
      this.target = target;
      return this;
    }

    public void unsetTarget() {
      this.target = null;
    }

    /** Returns true if field target is set (has been asigned a value) and false otherwise */
    public boolean isSetTarget() {
      return this.target != null;
    }

    public void setTargetIsSet(boolean value) {
      if (!value) {
        this.target = null;
      }
    }

    public NodeID getDestination() {
      return this.destination;
    }

    public fetch_args setDestination(NodeID destination) {
      this.destination = destination;
      return this;
    }

    public void unsetDestination() {
      this.destination = null;
    }

    /** Returns true if field destination is set (has been asigned a value) and false otherwise */
    public boolean isSetDestination() {
      return this.destination != null;
    }

    public void setDestinationIsSet(boolean value) {
      if (!value) {
        this.destination = null;
      }
    }

    public long getCmdid() {
      return this.cmdid;
    }

    public fetch_args setCmdid(long cmdid) {
      this.cmdid = cmdid;
      setCmdidIsSet(true);
      return this;
    }

    public void unsetCmdid() {
      __isset_bit_vector.clear(__CMDID_ISSET_ID);
    }

    /** Returns true if field cmdid is set (has been asigned a value) and false otherwise */
    public boolean isSetCmdid() {
      return __isset_bit_vector.get(__CMDID_ISSET_ID);
    }

    public void setCmdidIsSet(boolean value) {
      __isset_bit_vector.set(__CMDID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TARGET:
        if (value == null) {
          unsetTarget();
        } else {
          setTarget((List<MapEntry>)value);
        }
        break;

      case DESTINATION:
        if (value == null) {
          unsetDestination();
        } else {
          setDestination((NodeID)value);
        }
        break;

      case CMDID:
        if (value == null) {
          unsetCmdid();
        } else {
          setCmdid((Long)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TARGET:
        return getTarget();

      case DESTINATION:
        return getDestination();

      case CMDID:
        return new Long(getCmdid());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TARGET:
        return isSetTarget();
      case DESTINATION:
        return isSetDestination();
      case CMDID:
        return isSetCmdid();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof fetch_args)
        return this.equals((fetch_args)that);
      return false;
    }

    public boolean equals(fetch_args that) {
      if (that == null)
        return false;

      boolean this_present_target = true && this.isSetTarget();
      boolean that_present_target = true && that.isSetTarget();
      if (this_present_target || that_present_target) {
        if (!(this_present_target && that_present_target))
          return false;
        if (!this.target.equals(that.target))
          return false;
      }

      boolean this_present_destination = true && this.isSetDestination();
      boolean that_present_destination = true && that.isSetDestination();
      if (this_present_destination || that_present_destination) {
        if (!(this_present_destination && that_present_destination))
          return false;
        if (!this.destination.equals(that.destination))
          return false;
      }

      boolean this_present_cmdid = true;
      boolean that_present_cmdid = true;
      if (this_present_cmdid || that_present_cmdid) {
        if (!(this_present_cmdid && that_present_cmdid))
          return false;
        if (this.cmdid != that.cmdid)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(fetch_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      fetch_args typedOther = (fetch_args)other;

      lastComparison = Boolean.valueOf(isSetTarget()).compareTo(isSetTarget());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(target, typedOther.target);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetDestination()).compareTo(isSetDestination());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(destination, typedOther.destination);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetCmdid()).compareTo(isSetCmdid());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(cmdid, typedOther.cmdid);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TARGET:
              if (field.type == TType.LIST) {
                {
                  TList _list29 = iprot.readListBegin();
                  this.target = new ArrayList<MapEntry>(_list29.size);
                  for (int _i30 = 0; _i30 < _list29.size; ++_i30)
                  {
                    MapEntry _elem31;
                    _elem31 = new MapEntry();
                    _elem31.read(iprot);
                    this.target.add(_elem31);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case DESTINATION:
              if (field.type == TType.STRUCT) {
                this.destination = new NodeID();
                this.destination.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case CMDID:
              if (field.type == TType.I64) {
                this.cmdid = iprot.readI64();
                setCmdidIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.target != null) {
        oprot.writeFieldBegin(TARGET_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.target.size()));
          for (MapEntry _iter32 : this.target)
          {
            _iter32.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.destination != null) {
        oprot.writeFieldBegin(DESTINATION_FIELD_DESC);
        this.destination.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CMDID_FIELD_DESC);
      oprot.writeI64(this.cmdid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("fetch_args(");
      boolean first = true;

      sb.append("target:");
      if (this.target == null) {
        sb.append("null");
      } else {
        sb.append(this.target);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("destination:");
      if (this.destination == null) {
        sb.append("null");
      } else {
        sb.append(this.destination);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cmdid:");
      sb.append(this.cmdid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class push_get_args implements TBase<push_get_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("push_get_args");

    private static final TField RESULT_FIELD_DESC = new TField("result", TType.MAP, (short)1);
    private static final TField CMDID_FIELD_DESC = new TField("cmdid", TType.I64, (short)2);

    public Map<MapEntry,Double> result;
    public long cmdid;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      RESULT((short)1, "result"),
      CMDID((short)2, "cmdid");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __CMDID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.RESULT, new FieldMetaData("result", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.MAP)));
      put(_Fields.CMDID, new FieldMetaData("cmdid", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(push_get_args.class, metaDataMap);
    }

    public push_get_args() {
    }

    public push_get_args(
      Map<MapEntry,Double> result,
      long cmdid)
    {
      this();
      this.result = result;
      this.cmdid = cmdid;
      setCmdidIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public push_get_args(push_get_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetResult()) {
        this.result = other.result;
      }
      this.cmdid = other.cmdid;
    }

    public push_get_args deepCopy() {
      return new push_get_args(this);
    }

    @Deprecated
    public push_get_args clone() {
      return new push_get_args(this);
    }

    public int getResultSize() {
      return (this.result == null) ? 0 : this.result.size();
    }

    public void putToResult(MapEntry key, double val) {
      if (this.result == null) {
        this.result = new HashMap<MapEntry,Double>();
      }
      this.result.put(key, val);
    }

    public Map<MapEntry,Double> getResult() {
      return this.result;
    }

    public push_get_args setResult(Map<MapEntry,Double> result) {
      this.result = result;
      return this;
    }

    public void unsetResult() {
      this.result = null;
    }

    /** Returns true if field result is set (has been asigned a value) and false otherwise */
    public boolean isSetResult() {
      return this.result != null;
    }

    public void setResultIsSet(boolean value) {
      if (!value) {
        this.result = null;
      }
    }

    public long getCmdid() {
      return this.cmdid;
    }

    public push_get_args setCmdid(long cmdid) {
      this.cmdid = cmdid;
      setCmdidIsSet(true);
      return this;
    }

    public void unsetCmdid() {
      __isset_bit_vector.clear(__CMDID_ISSET_ID);
    }

    /** Returns true if field cmdid is set (has been asigned a value) and false otherwise */
    public boolean isSetCmdid() {
      return __isset_bit_vector.get(__CMDID_ISSET_ID);
    }

    public void setCmdidIsSet(boolean value) {
      __isset_bit_vector.set(__CMDID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case RESULT:
        if (value == null) {
          unsetResult();
        } else {
          setResult((Map<MapEntry,Double>)value);
        }
        break;

      case CMDID:
        if (value == null) {
          unsetCmdid();
        } else {
          setCmdid((Long)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case RESULT:
        return getResult();

      case CMDID:
        return new Long(getCmdid());

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case RESULT:
        return isSetResult();
      case CMDID:
        return isSetCmdid();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof push_get_args)
        return this.equals((push_get_args)that);
      return false;
    }

    public boolean equals(push_get_args that) {
      if (that == null)
        return false;

      boolean this_present_result = true && this.isSetResult();
      boolean that_present_result = true && that.isSetResult();
      if (this_present_result || that_present_result) {
        if (!(this_present_result && that_present_result))
          return false;
        if (!this.result.equals(that.result))
          return false;
      }

      boolean this_present_cmdid = true;
      boolean that_present_cmdid = true;
      if (this_present_cmdid || that_present_cmdid) {
        if (!(this_present_cmdid && that_present_cmdid))
          return false;
        if (this.cmdid != that.cmdid)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case RESULT:
              if (field.type == TType.MAP) {
                {
                  TMap _map33 = iprot.readMapBegin();
                  this.result = new HashMap<MapEntry,Double>(2*_map33.size);
                  for (int _i34 = 0; _i34 < _map33.size; ++_i34)
                  {
                    MapEntry _key35;
                    double _val36;
                    _key35 = new MapEntry();
                    _key35.read(iprot);
                    _val36 = iprot.readDouble();
                    this.result.put(_key35, _val36);
                  }
                  iprot.readMapEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case CMDID:
              if (field.type == TType.I64) {
                this.cmdid = iprot.readI64();
                setCmdidIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.result != null) {
        oprot.writeFieldBegin(RESULT_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRUCT, TType.DOUBLE, this.result.size()));
          for (Map.Entry<MapEntry, Double> _iter37 : this.result.entrySet())
          {
            _iter37.getKey().write(oprot);
            oprot.writeDouble(_iter37.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(CMDID_FIELD_DESC);
      oprot.writeI64(this.cmdid);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("push_get_args(");
      boolean first = true;

      sb.append("result:");
      if (this.result == null) {
        sb.append("null");
      } else {
        sb.append(this.result);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("cmdid:");
      sb.append(this.cmdid);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class meta_request_args implements TBase<meta_request_args._Fields>, java.io.Serializable, Cloneable, Comparable<meta_request_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("meta_request_args");

    private static final TField BASE_CMD_FIELD_DESC = new TField("base_cmd", TType.I64, (short)1);
    private static final TField PUT_LIST_FIELD_DESC = new TField("put_list", TType.LIST, (short)2);
    private static final TField GET_LIST_FIELD_DESC = new TField("get_list", TType.LIST, (short)3);
    private static final TField PARAMS_FIELD_DESC = new TField("params", TType.LIST, (short)4);

    public long base_cmd;
    public List<PutRequest> put_list;
    public List<GetRequest> get_list;
    public List<Double> params;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      BASE_CMD((short)1, "base_cmd"),
      PUT_LIST((short)2, "put_list"),
      GET_LIST((short)3, "get_list"),
      PARAMS((short)4, "params");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __BASE_CMD_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.BASE_CMD, new FieldMetaData("base_cmd", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      put(_Fields.PUT_LIST, new FieldMetaData("put_list", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, PutRequest.class))));
      put(_Fields.GET_LIST, new FieldMetaData("get_list", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, GetRequest.class))));
      put(_Fields.PARAMS, new FieldMetaData("params", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.DOUBLE))));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(meta_request_args.class, metaDataMap);
    }

    public meta_request_args() {
    }

    public meta_request_args(
      long base_cmd,
      List<PutRequest> put_list,
      List<GetRequest> get_list,
      List<Double> params)
    {
      this();
      this.base_cmd = base_cmd;
      setBase_cmdIsSet(true);
      this.put_list = put_list;
      this.get_list = get_list;
      this.params = params;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public meta_request_args(meta_request_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.base_cmd = other.base_cmd;
      if (other.isSetPut_list()) {
        List<PutRequest> __this__put_list = new ArrayList<PutRequest>();
        for (PutRequest other_element : other.put_list) {
          __this__put_list.add(new PutRequest(other_element));
        }
        this.put_list = __this__put_list;
      }
      if (other.isSetGet_list()) {
        List<GetRequest> __this__get_list = new ArrayList<GetRequest>();
        for (GetRequest other_element : other.get_list) {
          __this__get_list.add(new GetRequest(other_element));
        }
        this.get_list = __this__get_list;
      }
      if (other.isSetParams()) {
        List<Double> __this__params = new ArrayList<Double>();
        for (Double other_element : other.params) {
          __this__params.add(other_element);
        }
        this.params = __this__params;
      }
    }

    public meta_request_args deepCopy() {
      return new meta_request_args(this);
    }

    @Deprecated
    public meta_request_args clone() {
      return new meta_request_args(this);
    }

    public long getBase_cmd() {
      return this.base_cmd;
    }

    public meta_request_args setBase_cmd(long base_cmd) {
      this.base_cmd = base_cmd;
      setBase_cmdIsSet(true);
      return this;
    }

    public void unsetBase_cmd() {
      __isset_bit_vector.clear(__BASE_CMD_ISSET_ID);
    }

    /** Returns true if field base_cmd is set (has been asigned a value) and false otherwise */
    public boolean isSetBase_cmd() {
      return __isset_bit_vector.get(__BASE_CMD_ISSET_ID);
    }

    public void setBase_cmdIsSet(boolean value) {
      __isset_bit_vector.set(__BASE_CMD_ISSET_ID, value);
    }

    public int getPut_listSize() {
      return (this.put_list == null) ? 0 : this.put_list.size();
    }

    public java.util.Iterator<PutRequest> getPut_listIterator() {
      return (this.put_list == null) ? null : this.put_list.iterator();
    }

    public void addToPut_list(PutRequest elem) {
      if (this.put_list == null) {
        this.put_list = new ArrayList<PutRequest>();
      }
      this.put_list.add(elem);
    }

    public List<PutRequest> getPut_list() {
      return this.put_list;
    }

    public meta_request_args setPut_list(List<PutRequest> put_list) {
      this.put_list = put_list;
      return this;
    }

    public void unsetPut_list() {
      this.put_list = null;
    }

    /** Returns true if field put_list is set (has been asigned a value) and false otherwise */
    public boolean isSetPut_list() {
      return this.put_list != null;
    }

    public void setPut_listIsSet(boolean value) {
      if (!value) {
        this.put_list = null;
      }
    }

    public int getGet_listSize() {
      return (this.get_list == null) ? 0 : this.get_list.size();
    }

    public java.util.Iterator<GetRequest> getGet_listIterator() {
      return (this.get_list == null) ? null : this.get_list.iterator();
    }

    public void addToGet_list(GetRequest elem) {
      if (this.get_list == null) {
        this.get_list = new ArrayList<GetRequest>();
      }
      this.get_list.add(elem);
    }

    public List<GetRequest> getGet_list() {
      return this.get_list;
    }

    public meta_request_args setGet_list(List<GetRequest> get_list) {
      this.get_list = get_list;
      return this;
    }

    public void unsetGet_list() {
      this.get_list = null;
    }

    /** Returns true if field get_list is set (has been asigned a value) and false otherwise */
    public boolean isSetGet_list() {
      return this.get_list != null;
    }

    public void setGet_listIsSet(boolean value) {
      if (!value) {
        this.get_list = null;
      }
    }

    public int getParamsSize() {
      return (this.params == null) ? 0 : this.params.size();
    }

    public java.util.Iterator<Double> getParamsIterator() {
      return (this.params == null) ? null : this.params.iterator();
    }

    public void addToParams(double elem) {
      if (this.params == null) {
        this.params = new ArrayList<Double>();
      }
      this.params.add(elem);
    }

    public List<Double> getParams() {
      return this.params;
    }

    public meta_request_args setParams(List<Double> params) {
      this.params = params;
      return this;
    }

    public void unsetParams() {
      this.params = null;
    }

    /** Returns true if field params is set (has been asigned a value) and false otherwise */
    public boolean isSetParams() {
      return this.params != null;
    }

    public void setParamsIsSet(boolean value) {
      if (!value) {
        this.params = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case BASE_CMD:
        if (value == null) {
          unsetBase_cmd();
        } else {
          setBase_cmd((Long)value);
        }
        break;

      case PUT_LIST:
        if (value == null) {
          unsetPut_list();
        } else {
          setPut_list((List<PutRequest>)value);
        }
        break;

      case GET_LIST:
        if (value == null) {
          unsetGet_list();
        } else {
          setGet_list((List<GetRequest>)value);
        }
        break;

      case PARAMS:
        if (value == null) {
          unsetParams();
        } else {
          setParams((List<Double>)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case BASE_CMD:
        return new Long(getBase_cmd());

      case PUT_LIST:
        return getPut_list();

      case GET_LIST:
        return getGet_list();

      case PARAMS:
        return getParams();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case BASE_CMD:
        return isSetBase_cmd();
      case PUT_LIST:
        return isSetPut_list();
      case GET_LIST:
        return isSetGet_list();
      case PARAMS:
        return isSetParams();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof meta_request_args)
        return this.equals((meta_request_args)that);
      return false;
    }

    public boolean equals(meta_request_args that) {
      if (that == null)
        return false;

      boolean this_present_base_cmd = true;
      boolean that_present_base_cmd = true;
      if (this_present_base_cmd || that_present_base_cmd) {
        if (!(this_present_base_cmd && that_present_base_cmd))
          return false;
        if (this.base_cmd != that.base_cmd)
          return false;
      }

      boolean this_present_put_list = true && this.isSetPut_list();
      boolean that_present_put_list = true && that.isSetPut_list();
      if (this_present_put_list || that_present_put_list) {
        if (!(this_present_put_list && that_present_put_list))
          return false;
        if (!this.put_list.equals(that.put_list))
          return false;
      }

      boolean this_present_get_list = true && this.isSetGet_list();
      boolean that_present_get_list = true && that.isSetGet_list();
      if (this_present_get_list || that_present_get_list) {
        if (!(this_present_get_list && that_present_get_list))
          return false;
        if (!this.get_list.equals(that.get_list))
          return false;
      }

      boolean this_present_params = true && this.isSetParams();
      boolean that_present_params = true && that.isSetParams();
      if (this_present_params || that_present_params) {
        if (!(this_present_params && that_present_params))
          return false;
        if (!this.params.equals(that.params))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(meta_request_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      meta_request_args typedOther = (meta_request_args)other;

      lastComparison = Boolean.valueOf(isSetBase_cmd()).compareTo(isSetBase_cmd());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(base_cmd, typedOther.base_cmd);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetPut_list()).compareTo(isSetPut_list());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(put_list, typedOther.put_list);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetGet_list()).compareTo(isSetGet_list());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(get_list, typedOther.get_list);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetParams()).compareTo(isSetParams());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(params, typedOther.params);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case BASE_CMD:
              if (field.type == TType.I64) {
                this.base_cmd = iprot.readI64();
                setBase_cmdIsSet(true);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case PUT_LIST:
              if (field.type == TType.LIST) {
                {
                  TList _list38 = iprot.readListBegin();
                  this.put_list = new ArrayList<PutRequest>(_list38.size);
                  for (int _i39 = 0; _i39 < _list38.size; ++_i39)
                  {
                    PutRequest _elem40;
                    _elem40 = new PutRequest();
                    _elem40.read(iprot);
                    this.put_list.add(_elem40);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case GET_LIST:
              if (field.type == TType.LIST) {
                {
                  TList _list41 = iprot.readListBegin();
                  this.get_list = new ArrayList<GetRequest>(_list41.size);
                  for (int _i42 = 0; _i42 < _list41.size; ++_i42)
                  {
                    GetRequest _elem43;
                    _elem43 = new GetRequest();
                    _elem43.read(iprot);
                    this.get_list.add(_elem43);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case PARAMS:
              if (field.type == TType.LIST) {
                {
                  TList _list44 = iprot.readListBegin();
                  this.params = new ArrayList<Double>(_list44.size);
                  for (int _i45 = 0; _i45 < _list44.size; ++_i45)
                  {
                    double _elem46;
                    _elem46 = iprot.readDouble();
                    this.params.add(_elem46);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(BASE_CMD_FIELD_DESC);
      oprot.writeI64(this.base_cmd);
      oprot.writeFieldEnd();
      if (this.put_list != null) {
        oprot.writeFieldBegin(PUT_LIST_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.put_list.size()));
          for (PutRequest _iter47 : this.put_list)
          {
            _iter47.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.get_list != null) {
        oprot.writeFieldBegin(GET_LIST_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.get_list.size()));
          for (GetRequest _iter48 : this.get_list)
          {
            _iter48.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.params != null) {
        oprot.writeFieldBegin(PARAMS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.DOUBLE, this.params.size()));
          for (double _iter49 : this.params)
          {
            oprot.writeDouble(_iter49);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("meta_request_args(");
      boolean first = true;

      sb.append("base_cmd:");
      sb.append(this.base_cmd);
      first = false;
      if (!first) sb.append(", ");
      sb.append("put_list:");
      if (this.put_list == null) {
        sb.append("null");
      } else {
        sb.append(this.put_list);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("get_list:");
      if (this.get_list == null) {
        sb.append("null");
      } else {
        sb.append(this.get_list);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("params:");
      if (this.params == null) {
        sb.append("null");
      } else {
        sb.append(this.params);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class aggreget_args implements TBase<aggreget_args._Fields>, java.io.Serializable, Cloneable, Comparable<aggreget_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("aggreget_args");

    private static final TField TARGET_FIELD_DESC = new TField("target", TType.LIST, (short)1);
    private static final TField AGG_FIELD_DESC = new TField("agg", TType.I32, (short)2);

    public List<MapEntry> target;
    /**
     * 
     * @see AggregateType
     */
    public AggregateType agg;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TARGET((short)1, "target"),
      /**
       * 
       * @see AggregateType
       */
      AGG((short)2, "agg");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.TARGET, new FieldMetaData("target", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, MapEntry.class))));
      put(_Fields.AGG, new FieldMetaData("agg", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, AggregateType.class)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(aggreget_args.class, metaDataMap);
    }

    public aggreget_args() {
    }

    public aggreget_args(
      List<MapEntry> target,
      AggregateType agg)
    {
      this();
      this.target = target;
      this.agg = agg;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public aggreget_args(aggreget_args other) {
      if (other.isSetTarget()) {
        List<MapEntry> __this__target = new ArrayList<MapEntry>();
        for (MapEntry other_element : other.target) {
          __this__target.add(new MapEntry(other_element));
        }
        this.target = __this__target;
      }
      if (other.isSetAgg()) {
        this.agg = other.agg;
      }
    }

    public aggreget_args deepCopy() {
      return new aggreget_args(this);
    }

    @Deprecated
    public aggreget_args clone() {
      return new aggreget_args(this);
    }

    public int getTargetSize() {
      return (this.target == null) ? 0 : this.target.size();
    }

    public java.util.Iterator<MapEntry> getTargetIterator() {
      return (this.target == null) ? null : this.target.iterator();
    }

    public void addToTarget(MapEntry elem) {
      if (this.target == null) {
        this.target = new ArrayList<MapEntry>();
      }
      this.target.add(elem);
    }

    public List<MapEntry> getTarget() {
      return this.target;
    }

    public aggreget_args setTarget(List<MapEntry> target) {
      this.target = target;
      return this;
    }

    public void unsetTarget() {
      this.target = null;
    }

    /** Returns true if field target is set (has been asigned a value) and false otherwise */
    public boolean isSetTarget() {
      return this.target != null;
    }

    public void setTargetIsSet(boolean value) {
      if (!value) {
        this.target = null;
      }
    }

    /**
     * 
     * @see AggregateType
     */
    public AggregateType getAgg() {
      return this.agg;
    }

    /**
     * 
     * @see AggregateType
     */
    public aggreget_args setAgg(AggregateType agg) {
      this.agg = agg;
      return this;
    }

    public void unsetAgg() {
      this.agg = null;
    }

    /** Returns true if field agg is set (has been asigned a value) and false otherwise */
    public boolean isSetAgg() {
      return this.agg != null;
    }

    public void setAggIsSet(boolean value) {
      if (!value) {
        this.agg = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TARGET:
        if (value == null) {
          unsetTarget();
        } else {
          setTarget((List<MapEntry>)value);
        }
        break;

      case AGG:
        if (value == null) {
          unsetAgg();
        } else {
          setAgg((AggregateType)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TARGET:
        return getTarget();

      case AGG:
        return getAgg();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case TARGET:
        return isSetTarget();
      case AGG:
        return isSetAgg();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof aggreget_args)
        return this.equals((aggreget_args)that);
      return false;
    }

    public boolean equals(aggreget_args that) {
      if (that == null)
        return false;

      boolean this_present_target = true && this.isSetTarget();
      boolean that_present_target = true && that.isSetTarget();
      if (this_present_target || that_present_target) {
        if (!(this_present_target && that_present_target))
          return false;
        if (!this.target.equals(that.target))
          return false;
      }

      boolean this_present_agg = true && this.isSetAgg();
      boolean that_present_agg = true && that.isSetAgg();
      if (this_present_agg || that_present_agg) {
        if (!(this_present_agg && that_present_agg))
          return false;
        if (!this.agg.equals(that.agg))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(aggreget_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      aggreget_args typedOther = (aggreget_args)other;

      lastComparison = Boolean.valueOf(isSetTarget()).compareTo(isSetTarget());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(target, typedOther.target);
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = Boolean.valueOf(isSetAgg()).compareTo(isSetAgg());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(agg, typedOther.agg);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case TARGET:
              if (field.type == TType.LIST) {
                {
                  TList _list50 = iprot.readListBegin();
                  this.target = new ArrayList<MapEntry>(_list50.size);
                  for (int _i51 = 0; _i51 < _list50.size; ++_i51)
                  {
                    MapEntry _elem52;
                    _elem52 = new MapEntry();
                    _elem52.read(iprot);
                    this.target.add(_elem52);
                  }
                  iprot.readListEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case AGG:
              if (field.type == TType.I32) {
                this.agg = AggregateType.findByValue(iprot.readI32());
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.target != null) {
        oprot.writeFieldBegin(TARGET_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.target.size()));
          for (MapEntry _iter53 : this.target)
          {
            _iter53.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.agg != null) {
        oprot.writeFieldBegin(AGG_FIELD_DESC);
        oprot.writeI32(this.agg.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("aggreget_args(");
      boolean first = true;

      sb.append("target:");
      if (this.target == null) {
        sb.append("null");
      } else {
        sb.append(this.target);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("agg:");
      if (this.agg == null) {
        sb.append("null");
      } else {
        String agg_name = agg.name();
        if (agg_name != null) {
          sb.append(agg_name);
          sb.append(" (");
        }
        sb.append(this.agg);
        if (agg_name != null) {
          sb.append(")");
        }
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class aggreget_result implements TBase<aggreget_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("aggreget_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
    private static final TField ERROR_FIELD_DESC = new TField("error", TType.STRUCT, (short)1);

    public Map<MapEntry,Double> success;
    public SpreadException error;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      ERROR((short)1, "error");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.MAP)));
      put(_Fields.ERROR, new FieldMetaData("error", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(aggreget_result.class, metaDataMap);
    }

    public aggreget_result() {
    }

    public aggreget_result(
      Map<MapEntry,Double> success,
      SpreadException error)
    {
      this();
      this.success = success;
      this.error = error;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public aggreget_result(aggreget_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
      if (other.isSetError()) {
        this.error = new SpreadException(other.error);
      }
    }

    public aggreget_result deepCopy() {
      return new aggreget_result(this);
    }

    @Deprecated
    public aggreget_result clone() {
      return new aggreget_result(this);
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public void putToSuccess(MapEntry key, double val) {
      if (this.success == null) {
        this.success = new HashMap<MapEntry,Double>();
      }
      this.success.put(key, val);
    }

    public Map<MapEntry,Double> getSuccess() {
      return this.success;
    }

    public aggreget_result setSuccess(Map<MapEntry,Double> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public SpreadException getError() {
      return this.error;
    }

    public aggreget_result setError(SpreadException error) {
      this.error = error;
      return this;
    }

    public void unsetError() {
      this.error = null;
    }

    /** Returns true if field error is set (has been asigned a value) and false otherwise */
    public boolean isSetError() {
      return this.error != null;
    }

    public void setErrorIsSet(boolean value) {
      if (!value) {
        this.error = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Map<MapEntry,Double>)value);
        }
        break;

      case ERROR:
        if (value == null) {
          unsetError();
        } else {
          setError((SpreadException)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case ERROR:
        return getError();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case ERROR:
        return isSetError();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof aggreget_result)
        return this.equals((aggreget_result)that);
      return false;
    }

    public boolean equals(aggreget_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_error = true && this.isSetError();
      boolean that_present_error = true && that.isSetError();
      if (this_present_error || that_present_error) {
        if (!(this_present_error && that_present_error))
          return false;
        if (!this.error.equals(that.error))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.MAP) {
                {
                  TMap _map54 = iprot.readMapBegin();
                  this.success = new HashMap<MapEntry,Double>(2*_map54.size);
                  for (int _i55 = 0; _i55 < _map54.size; ++_i55)
                  {
                    MapEntry _key56;
                    double _val57;
                    _key56 = new MapEntry();
                    _key56.read(iprot);
                    _val57 = iprot.readDouble();
                    this.success.put(_key56, _val57);
                  }
                  iprot.readMapEnd();
                }
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
            case ERROR:
              if (field.type == TType.STRUCT) {
                this.error = new SpreadException();
                this.error.read(iprot);
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeMapBegin(new TMap(TType.STRUCT, TType.DOUBLE, this.success.size()));
          for (Map.Entry<MapEntry, Double> _iter58 : this.success.entrySet())
          {
            _iter58.getKey().write(oprot);
            oprot.writeDouble(_iter58.getValue());
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetError()) {
        oprot.writeFieldBegin(ERROR_FIELD_DESC);
        this.error.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("aggreget_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("error:");
      if (this.error == null) {
        sb.append("null");
      } else {
        sb.append(this.error);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dump_args implements TBase<dump_args._Fields>, java.io.Serializable, Cloneable, Comparable<dump_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("dump_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(dump_args.class, metaDataMap);
    }

    public dump_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dump_args(dump_args other) {
    }

    public dump_args deepCopy() {
      return new dump_args(this);
    }

    @Deprecated
    public dump_args clone() {
      return new dump_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dump_args)
        return this.equals((dump_args)that);
      return false;
    }

    public boolean equals(dump_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(dump_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      dump_args typedOther = (dump_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("dump_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class dump_result implements TBase<dump_result._Fields>, java.io.Serializable, Cloneable, Comparable<dump_result>   {
    private static final TStruct STRUCT_DESC = new TStruct("dump_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRING, (short)0);

    public String success;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success");

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
    }});

    static {
      FieldMetaData.addStructMetaDataMap(dump_result.class, metaDataMap);
    }

    public dump_result() {
    }

    public dump_result(
      String success)
    {
      this();
      this.success = success;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public dump_result(dump_result other) {
      if (other.isSetSuccess()) {
        this.success = other.success;
      }
    }

    public dump_result deepCopy() {
      return new dump_result(this);
    }

    @Deprecated
    public dump_result clone() {
      return new dump_result(this);
    }

    public String getSuccess() {
      return this.success;
    }

    public dump_result setSuccess(String success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((String)value);
        }
        break;

      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof dump_result)
        return this.equals((dump_result)that);
      return false;
    }

    public boolean equals(dump_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(dump_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      dump_result typedOther = (dump_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      lastComparison = TBaseHelper.compareTo(success, typedOther.success);
      if (lastComparison != 0) {
        return lastComparison;
      }
      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
            case SUCCESS:
              if (field.type == TType.STRING) {
                this.success = iprot.readString();
              } else { 
                TProtocolUtil.skip(iprot, field.type);
              }
              break;
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeString(this.success);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("dump_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class localdump_args implements TBase<localdump_args._Fields>, java.io.Serializable, Cloneable, Comparable<localdump_args>   {
    private static final TStruct STRUCT_DESC = new TStruct("localdump_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byId.put((int)field._thriftId, field);
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        return byId.get(fieldId);
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
    }});

    static {
      FieldMetaData.addStructMetaDataMap(localdump_args.class, metaDataMap);
    }

    public localdump_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public localdump_args(localdump_args other) {
    }

    public localdump_args deepCopy() {
      return new localdump_args(this);
    }

    @Deprecated
    public localdump_args clone() {
      return new localdump_args(this);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public void setFieldValue(int fieldID, Object value) {
      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public Object getFieldValue(int fieldId) {
      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    public boolean isSet(int fieldID) {
      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof localdump_args)
        return this.equals((localdump_args)that);
      return false;
    }

    public boolean equals(localdump_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(localdump_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      localdump_args typedOther = (localdump_args)other;

      return 0;
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        _Fields fieldId = _Fields.findByThriftId(field.id);
        if (fieldId == null) {
          TProtocolUtil.skip(iprot, field.type);
        } else {
          switch (fieldId) {
          }
          iprot.readFieldEnd();
        }
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("localdump_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
