
#ifndef ORDER_MANAGER_DEMO
#define ORDER_MANAGER_DEMO

#include <iostream>
#include <string>
#include <deque>

#include <boost/ptr_container/ptr_map.hpp>
#include <boost/bind.hpp>
#include <boost/asio.hpp>
#include <boost/thread.hpp>

#include <tr1/tuple>

#include "WriterConnection.h"
#include "DataTuple.h"
#include "AlgoTypeDefs.h"

namespace DBToaster
{
    namespace DemoAlgEngine
    {
        using namespace std;
        using namespace tr1;
        using namespace boost;
        using namespace DBToaster::DemoAlgEngine;

        class OrderManager
        {
        public:

            OrderManager(boost::asio::io_service& io_service, int shares, int m):
                localIOService(io_service), 
                numberShares(shares),
                currentMoney(m)
            {
                localIdCounter=0;
                currentStockPrice=0;
//                numberOfMessages=0;
                writer=new WriterConnection(localIOService, 0);
                
//                numReads=0;
//                numWrites=0;
            }
            
            void sendOrders(boost::function<void ()>  handler, deque<AlgoMessages*> & messages)
            {
//                handler=return_function;
//                numberOfMessages=messages.size();
                
//                cout<<"sendOrder size: "<<messages.size()<<endl;

/*                while (!messages.empty())
                {
                    AlgoMessages * msg=messages.front();
                    sendOrder(msg->tuple, msg->type);
                    messages.pop_front();
                    delete msg;
                }
                */
                
                deque<AlgoMessages*>::iterator message=messages.begin();
                
                for (; message != messages.end(); message++)
                {
                    sendOrder((*message)->tuple, (*message)->type);
//                    ++numWrites;
                }
                
               localIOService.post(handler);
               
//               cout<<"sendOrders: done here "<<numWrites<<endl;
            }

            int sendOrder(DataTuple & tuple, int & type)
            {
                //this function is called by algorithms
                //if type is 0 no return is expected (on delete)
                //type 1 returns internal id. 


                if (type == 1)
                {
                    //this is desiged for "S" and "B" orders;
                    localIdCounter++;
 //                   cout<<"sendOrder: id "<<localIdCounter<<endl;
                    writer->write((boost::bind(&OrderManager::handleOrder, this, _1, localIdCounter)), tuple, type);

                    return localIdCounter;
                }
                else
                {
                    //this is for the other orders;
//                    cout<<"wrong place wrong time"<<endl;
//                    flush(cout);
//                    exit(1);

                    writer->write(boost::bind(&OrderManager::handleOrder, this, tuple, localIdCounter), tuple, type);
                    return tuple.id;
                }

            }

            void handleOrder(DataTuple & tuple, int & id)
            {
                boost::mutex::scoped_lock lock(mutex);
                
 //               cout<<"handleOrder: in"<<endl;
 //               cout<<"handleOrder: "<<tuple.action<<" "<<tuple.price<<" "<<id<<endl;
                
                ptr_map<LocalID, DataTuple>::iterator item=dataOrders.find(id);

                if (item == dataOrders.end())
                {
                    dataOrders[id]=tuple;
                    orderIDtoLocalId[tuple.id]=id;
                }
                else
                {
                    cout<<"The item with OrderID "<<tuple.id<<" and LocalID "
                        <<id<<" is already in the database"<<endl;
                }
//                cout<<"handleOrder "<<++numReads<<endl;
            }

            void startReading(boost::asio::io_service& io_service)
            {
                reader=new WriterConnection(io_service, 1);

                reader->read(boost::bind(&OrderManager::processOrder,this, _1, 0));
            }

            void processOrder(DataTuple & tuple, int & temp)
            {
                ptr_map<OrderID, LocalID>::iterator item=orderIDtoLocalId.find(tuple.id);
                
                if (tuple.action == "E" || tuple.action == "F")
                {
                    currentStockPrice=tuple.price;
                }

                if (item != orderIDtoLocalId.end())
                {//tuple was generated by one of the algorithms;
                    processTuple(tuple, *(item->second));
                }              
                reader->read(boost::bind(&OrderManager::processOrder, this, _1, 0));
            }
            
            double getCurrentStockPrice()
            {
                return (double)currentStockPrice;
            }

/*            void checkAndChange(DataTuple & tuple)
            {

            }

            int addTuple(DataTuple & tuple)
            {
                return 0;
            }
  */          
            DataTuplesPair  getTuple(LocalID localID)
            {
                DataTuplesPair t(dataOrders[localID], executedOrders[localID]);
                return t;
            }

            int getCurrentShares()
            {
                return numberShares;
            }

            int getCurrentMoney()
            {
                return currentMoney;
            }

        private:

            void processTuple(DataTuple & tuple, LocalID & id)
            {
                boost::mutex::scoped_lock lock(mutex);
                
                cout<<"In processTuple: ";
                cout<<tuple.t<<" "<<tuple.id<<" "<<tuple.b_id<<" "<<tuple.action<<" "<<tuple.volume<<" "<<tuple.price<<endl;
                
                if (tuple.action == "D")
                {
                    dataOrders.erase(id);
 //                   orderIDtoLocalId.erase(tuple.id);
                }

                if (tuple.action == "E")
                {
                    if (dataOrders[id].action == "S")
                    {
                        currentMoney+=tuple.volume*tuple.price;
                        numberShares-=tuple.volume;
                    }
                    else if (dataOrders[id].action == "B")
                    {
                        currentMoney-=tuple.volume*tuple.price;
                        numberShares+=tuple.volume;
                    }
                    else
                    {
                        cout<<dataOrders[id].action<<endl;
                        cout<<"In OrderManager: dataOrders should only store S/B orders (fn:processingTuple)"<<endl;
                    }

                    dataOrders[id].volume=dataOrders[id].volume-tuple.volume;

                    ptr_map<LocalID, DataTuple>::iterator item=executedOrders.find(id);
                    if (item != executedOrders.end())
                    {
                        (item->second)->volume+=tuple.volume;
                        //TODO: account for the price somehow ...
                    }
                    else
                    {
                        executedOrders[id]=tuple;
                    }
                }

                if (tuple.action == "F")
                {
                    if (dataOrders[id].action == "S")
                    {
                        currentMoney+=tuple.volume*tuple.price;
                        numberShares-=tuple.volume;
                    }
                    else if (dataOrders[id].action == "B")
                    {
                        currentMoney-=tuple.volume*tuple.price;
                        numberShares+=tuple.volume;
                    }
                    else
                    {
                        cout<<"In OrderManager: dataOrders should only store S/B orders (fn:processingTuple)"<<endl;
                    }

                    ptr_map<LocalID, DataTuple>::iterator item=executedOrders.find(id);
                    if (item != executedOrders.end())
                    {
                        (item->second)->volume+=tuple.volume;
                        (item->second)->action="F";
                        //TODO: account for the price somehow ...
                    }
                    else
                    {
                        executedOrders[id]=tuple;
                    }

                    dataOrders.erase(id);
                }
            }

            boost::asio::io_service& localIOService;
//            boost::function<void ()>  handler;
//            int numberOfMessages;

            boost::mutex mutex;

            WriterConnection *             writer;
            WriterConnection *             reader;

            int localIdCounter;

            int numberShares;
            int currentMoney;
            
            int currentStockPrice;
            
 //           int numReads;
 //           int numWrites;

            ptr_map<LocalID, DataTuple>   dataOrders;
            ptr_map<OrderID, LocalID>     orderIDtoLocalId;
            ptr_map<LocalID, DataTuple>   executedOrders;

        };
    };
};


#endif