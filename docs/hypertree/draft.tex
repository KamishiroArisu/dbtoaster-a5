\documentclass[12pt]{article}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes}
\usepackage{algorithm}
\usepackage{algorithmic}%\usepackage[pagebackref=true,colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{graphicx} 
\usepackage{fancybox}
\usepackage{setspace}  
\usepackage[colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{enumerate} 
\usepackage{amsthm,amssymb,amsmath}
\usepackage{indentfirst}

\begin{document}

\title{Draft}
\date{}
\maketitle
\section{Join Tree}
Throughout these sections, for the sake of simplicity, we are dealing only with Boolean Conjunctive Query (BCQ) and we call them query. These result can be extended to other queries. 
Let fix a given query  as $Q$. Suppose for $Q$  we have its join tree $JT_{Q}<V>$ which $V, |V|=n$ represents the set of its nodes (i.e. Figure \ref{fig1}). 
This join tree has several nice properties. The most important property of join trees is that we can compute their results in linear time ???.
The other important property of join trees is \emph{connectedness property}. By the connectedness we mean that if we select a variable which occurs in the given query, ???. 

%\usetikzlibrary{positioning,shadows,arrows}
\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[
    %
    level 1/.style={rectangle, draw,scale=1.0, fill=red,
    level distance=30pt, sibling distance=130pt},
    level 2/.style={rectangle, draw, scale=1.0,
    level distance=50pt, sibling distance=60pt}]
    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
    \node[fill=red!40] {$p(x,y)$}
        child { 
            node [fill=red!40] {$q(x,y)$}
            child { node {$q(z,t)$}} 
        }
        child { 
        		node[fill=red!40]  {$h(y,v,w)$}
		child{ node[fill=red!40]{$p(y,v)$}}
		child{node{$q(v,w)$}}
		child{node{$p(w,u)$}}
		}
    ;
\end{tikzpicture}
\end{center}
\caption{A sample join tree of a query}
\label{fig1}
\end{figure}
\subsection{Number of different nodes is polynomial}
Let fix $k$ as the tree width of given $JT_{Q}$. Here we consider the case when $k$ is constant (we have an upper bound for that).
When we apply the $\Delta$-operator to a join tree its nodes change also the structure. Here we prove that the number of all nodes in all different trees that emerge from all different sequence of applying the $\Delta$-operator is polynomial in term of $n$ for a fixed $k$.\\

The nodes of $JT_{Q}$ are all in form of $R_{i_{1}}\bowtie\cdots\bowtie R_{i_{m}}$ which $m\leq k$, $m$ relations join together. Lets fix one particular node as $l$ with $m$ relations and the set of its indices is $I$. If we apply $\Delta_{\pm R_{i_{p}}}$ when $i_{p}\not\in I$ this node is $\emptyset$. For the other case we will have node $R_{i_{1}}\bowtie\cdots R_{i_{p-1}}\bowtie R_{i_{p+1}}\cdots R_{i_{m}}$, in the other words relation $R_{i_{p}}$ was deleted from the join operation. Thus, for counting the number of all nodes in all $JT_{Q}$ for all sequences of applying $\Delta$-operator, we should count all nodes which contain $1,2,\cdots,k$ different relations. This number is 
$\sum_{i=1}^{k}{\binom{n}{i}}<(n+1)^{k}$ which is polynomial for a fixed $k$. \\

\subsection{Cost of Evaluation}
\label{subsection:eval}
According to the last section the number of nodes in all delta trees is polynomial for a fixed $k$. Now we want to prove that the structures of all these trees are polynomial for a fixed $k$. \\

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[
    %
    level 1/.style={rectangle, draw,scale=1.0, fill=red,
    level distance=30pt, sibling distance=130pt},
    level 2/.style={rectangle, draw, scale=1.0,
    level distance=50pt, sibling distance=70pt}]
    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
    \node {$\cdots R\bowtie \cdots$}
        child { 
            node {$\cdots R\bowtie \cdots$}
        }
        child { 
        		node {$\cdots R\bowtie \cdots$}
		child{
       		node {$\cdots R\bowtie \cdots$}
		}
		child{
       		node {$\cdots R\bowtie \cdots$}
		}		
	}
    ;
\end{tikzpicture}
\end{center}
\caption{??}
\label{fig2}
\end{figure}

When $\Delta_{R}$-operator applies to a join tree it doesn't change the nodes that do not contain $R$ relation. Thus, without loss of generality we can assume that $R$ has appeared in all nodes, since we have connectedness property. 

When we apply $\Delta_{R}$-operator the such a tree, each node splits into 3 different nodes($\Delta(R\bowtie S)=\Delta(R)\bowtie S+R\bowtie\Delta(S)+\Delta(R)\bowtie\Delta(S)$). If we consider each $+,\bowtie$ as one operation, evaluation of $\Delta(R\bowtie S)$ needs at most 5 operations. Thus, the cost of evaluation of all $\Delta$ trees is $O(n)*(\text{Cost of join operator})$.


\subsection{Hypertree Decomposition}
Gottlob et al. have shown that for each Hypertree there exists a join tree with the same tree structure(Lemma 4.6). Thus, we have these results for hypertrees too.

\section{Algorithms}
In this section we give some algorithms for converting the $JT_{Q}$ into the proper data structures which are used in DBToaster.
Suppose we want to compute $\Delta_{\pm R}{JT_{Q}}$. As shown in \ref{subsection:eval} we can assume that every node contains relation $R$ (i.e. \ref{fig3}).

\begin{figure}[htbp]
\begin{center}
\usetikzlibrary{fit}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[
    %
    level 1/.style={scale=1.0, fill=red,
    level distance=30pt, sibling distance=150pt},
    level 2/.style={ scale=1.0,
    level distance=30pt, sibling distance=70pt},
    level 3/.style={ scale=0.7,
    level distance=60pt, sibling distance=120pt}]
    
%    \tikzstyle{every node}=[rectangle,draw,fill=red!20]
    \node [rectangle,draw,fill=red!20]{$\cdots R\bowtie \cdots$}
        child { 
            node[rectangle,draw,fill=red!20] {$\cdots R\bowtie \cdots$}
        }
        child { 
        		node[rectangle,draw,fill=red!20] {$\cdots R\bowtie \cdots$}
		child{
       		node[rectangle,draw,fill=red!20] {$\cdots R\bowtie \cdots$}
		}
		child{
       		node[rectangle,draw,fill=red!20] {$\cdots R\bowtie \cdots$}
		child{
			node(b) [rectangle,draw,fill=red!20]{$\cdots R\bowtie \cdots$}
		}
%		child{
%			node{$\cdots$}
%		}
		child{
			node (a) [rectangle,draw,fill=red!20]{$\cdots R\bowtie \cdots$}
		}
		}		
	}
    ;
    \draw[dotted] (a) -- (b);
    \node[draw=blue,inner sep=0pt,thick,ellipse,fit=(a) (b),label=above] {j elements};
\end{tikzpicture}
\end{center}
\caption{??}
\label{fig3}
\end{figure}

\begin{algorithm}[H]
\caption{Computing $\Delta_{\pm R}$} 
\label{alg1}
\textbf{Input:} node $v$ as the root of $JT_{Q}$ and relation $R$ as the $\Delta$ variable.\\
\textbf{Output:} Calculus expression for $\Delta_{R}$ for node $v$
\begin{algorithmic}[1]
\STATE $J\gets \emptyset$
\FORALL{Child $i$ of node $v$}
\IF{ the subtree rooted at $i$ has any node labeled by $R$}
\STATE Computes the $\Delta_{R}$ of $i$ recursively and store it in $\Delta[i]$ if it is not already computed.
\STATE add $i$ to $J$
\ENDIF
\ENDFOR
%\STATE $Exp\gets\emptyset$
\STATE $value\gets ComputeChain(J)$
\RETURN $value.expr$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{ComputeChain} 
\label{alg2}
\textbf{Input:} A set of sibling nodes of $JT_{Q}$ as $J$ and relation $R$ as the $\Delta$ variable.\\
\textbf{Output:} Calculus expression for $\Delta_{R}$ for input nodes\\
\begin{algorithmic}[1]
\IF{$|J|=1$}
\STATE $expr\gets \Delta_{R}(J_{1})$ \COMMENT{$J_{1}$ is the first element of $J$}
\STATE $join\gets J_{1}$
\ELSE
\STATE $rest\gets ComputeChain(J\setminus J_{1})$
\STATE $join\gets J_{1}\bowtie rest.join$
\STATE $expr\gets rest.expr\bowtie \Delta(J_{1})+\Delta(J_{1})\bowtie rest.join+J_{1}\bowtie rest.expr$
\ENDIF
\RETURN $(exp,join)$
\end{algorithmic}
\end{algorithm}

Obviously this algorithm needs to compute the delta of each element just one time. If we want to compute the $\Delta$ of a node with branching factor $j$ it needs $2^{j}-1$ different joint operation($\bowtie$) which is exponential in the worst case. But we can use a simple trick here. For the node we can first consider $\Delta$ of $j-1$ children and store it somewhere then with this value we can merge the $j$th one. With Algorithm. \ref{alg2} we can compute the $\Delta$ in $O(n)$.

\end{document}
