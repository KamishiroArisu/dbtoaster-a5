\documentclass[12pt]{article}

\usepackage{tikz}
\usetikzlibrary{shapes,snakes}
\usetikzlibrary{arrows,automata}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx} 
\usepackage{fancybox}
\usepackage{setspace}  
\usepackage[colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{enumerate} 
\usepackage{amsthm,amssymb,amsmath}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{alltt}
\usepackage{clrscode}
\usepackage{float}
\renewcommand{\algorithmiccomment}[1]{// #1}
\floatstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newfloat{program}{h}{lop}[section]
\floatname{program}{}

\newcommand{\dom}{\textsf{dom}}
\newcommand{\arity}{\textsf{arity}}
\newcommand{\InputVars}{\textsf{InputVars}}
\newcommand{\OutputVars}{\textsf{OutputVars}}
\newcommand{\Rel}{\textsf{Rel}}
\newcommand{\Ext}{\textsf{Ext}}
\title{Map Initializations}
\date{\today}

\begin{document}
\maketitle
\section{Introduction}
In this section we would want to discuss the matter of map initialization. From $\cite{1}$ we know that the compilation algorithm takes an aggregate query and defines a map for it, which represents the materialized view of the query. The algorithm creates a trigger for each possible update on an event, that will specify how to update the main query. To this operation, the algorithm computes the delta query, and creates a new map that will represent the materialized view of the delta. For example, if we have the following query q:
\begin{equation}
\mbox{SELECT sum(}a\cdot c\mbox{) FROM R(a,b), S(b,c) WHERE } R.b=S.b
\end{equation}
The compilation algorithm will take this query and replaces it with a map $q[][]$ and computes its deltas. We will have two events: $onR$, $onS$. For simplicity we will take for now only the inserting operation, the trigger code will look like, :
\begin{align*}
+onR(a,b)&:\\
&q[][]+=a*m_R[][b]\\
&m_S[][b]+=a\\
\end{align*}\vspace{-40pt}
\begin{align*}
+onS&(b,c):\\
&q[][]+=c*m_S[][b]\\
&m_R[][b]+=c\\
\end{align*}
In \cite{1} a map is defined by as function which takes input values and produces output values. With this definition, we can consider the initialization as a process of computing the function's output values for some new input values without computing the function body.

\section{Definitions}\label{defin}
DBToaster uses query language AGCA(which is stands for AGgregation CAlculus). 
AGCA expressions are built from constants, variables, relational atoms, aggregate sums (Sum), conditions, and variable assignments ($\gets$) using ``+''  and ``$\cdot$''. The abstract syntax can be given by the EBNF:
\begin{equation}
\label{def:agca}
q\text{ ::- }q\cdot q | q + q|v \gets q |v_{1}\theta v_{2}|R(\vec{y})|\text{c}|\text{v}|(M[\vec{x}][\vec{y}]\text{::-}q)
\end{equation}
The above definition can express all SQL statements. Here $v$ denotes variables, $\vec{x},\vec{y}$ tuples of variables, $R$ relation names, $c$ constants, and $\theta$ denotes comparison operations $(=,\neq, >, \geq, <, \text{ and }\leq)$.
 ``+'' represents unions and ``$\cdot$'' represents joins. Assignment operator($\gets$) takes an query and assigns its result to a variable($v$). A map $M[\vec{x}][\vec{y}]$ is a subquery with some input($\vec{x}$) and output($\vec{y}$) variables. It can be seen as a nested query that for the arguments $\vec{x}$ produces the output $\vec{y}$, it is not defined in \cite{1} but we added here for the purpose of this work.

The domain of a variable is the set of values that it can take. The domain of all the variables in a query expression can easily be computed recursively if some rules are respected. We will use through out the entire paper the notation of $\text{\dom{}}_{\vec x}(q)$ for the domain of a set of variables, where $q$ is the given query and $\vec x$ is a vector representing the variables(not necessarily present in the expression $q$). We will start by saying the $\vec x=\textless x_1,x_2,x_3,\cdots,x_n\textgreater$ will be the schema of all the variables 
and that $\vec c=\textless c_1,c_2,c_3,\cdots,c_n\textgreater$ will be the vector of all constants, that will match the schema presented by $\vec x$. It is not necessary that $\vec{x}$  has the same schema as the given expression. We will give the definition of $\dom{}_{\vec x}(R(\vec y))$:

\begin{equation}
\label{def:relation}
\dom{}_{\vec x}(R(\vec y))=\bigg\{\vec c\,\Big|\,\sigma_{\forall x_i\in(\vec{y}): x_{i}=c_{i}}R(\vec y)\not= \const{NULL}\bigg\}
\end{equation}

Thus, we can evaluate $\text{\dom}_{\vec{x}}$ for a broader range of $\vec{x}$ and it is not restricted by the schema of the input query expression. In such cases the \dom{} is infinite as the not presenting variables in the query can take any value.

For the comparison operator ($v_{1}\theta v_{2}$), where $v_1$ and $v_2$ are variables, we can compute the domain as follows:

\begin{equation}
\text{\dom{}}_{\vec{x}}(v_{1}\theta v_{2})=\bigg\{\vec{c}\,\Big|\,\forall i,j:(v_{1}=x_{i}\land v_{2}=x_{j})\Rightarrow c_{i}\theta c_{j}\bigg\}
\end{equation}

The domain of a comparison is infinite.

For the join operator we can write:
\begin{equation}
\label{def:join}
\text{\dom{}}_{\vec{x}}(q_{1}\cdot q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation}
while for the union operator the domain definition is very similar:
\begin{equation}
\label{def:plus}
\text{\dom{}}_{\vec{x}}(q_{1}+ q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\lor\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation}
\begin{eqnarray}
\dom{}_{\vec x}(constant)=\Big\{\vec c\Big\}\label{def:const}\\
\dom{}_{\vec x}(variable)=\Big\{\vec c\Big\}\label{def:var}
\end{eqnarray}
In \eqref{def:const} and \eqref{def:var}  $\vec{c}$ stands for all possible tuples match schema of $\vec{x}$, so the domains in these two cases are infinite. 
Finally, we can give a formalism for expressing the domain of a variable that will participate in an assignment operation:

\begin{equation}
\label{assign2}
\text{\dom{}}_{\vec{x}}(v\gets q_{1})=\Big\{\vec{c}\Big|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land \big(\forall i,j: (x_{i}=v=x_{j})\Rightarrow(c_{i}=c_{j}=q_{1})\big)\Big\}
\end{equation}
In fact using implication operator in the above definition allows us to extend the $\vec{x}$ to whatever vector we want, as we already said the schema of $\vec{x}$ is not necessarily the same as the schema of $q$. %Here is a mathematical reformulation of \eqref{assign1}:
We can define the domain of a map(for map's definition refer to \cite{1}, \cite{2}) as follow:
\begin{equation}
\label{def:map}
\text{\dom}_{\vec{w}}(map[\vec{x}][\vec{y}])=\{\vec{c}|\vec{c}\in\text{\dom}_{\vec{w}}(\vec{x}\cup\vec{y})\}
\end{equation}

As presented in the papers \cite{1} and \cite{2}, maps are functions that are defined on a set of values and that will produce a result for each value of that set. The set of values will represent the domains, which were computed using the definitions presented so far. We can make a distinction between a complete map and an incomplete map. A complete map will be characterized by the fact that each value of its domain will have assigned a result, whilst an incomplete map will be a map that will not have all the values of the domain and therefore neither the result for those values, on each insertion the incomplete map must compute the exact value of the tuple added to the domain.

In other words we can consider a complete map as a total function and an incomplete one as a partial function. A total function is a function that assigns a value to every element of its domain. But a partial function has some elements in its domain which have not been assigned to any value in its codomain. \par

We can express every expression of AGCA in a parse tree with EBNF~\ref{def:agca}. The root of parse tree represents the whole expression and its leaves are relations or comparisons. Each node can be regarded as a map and thus it has a domain. Any modification to the relations, the leaves are modified and this modification should be propagated upward through the parse tree. During the propagation process the domains of intermediate nodes may be changed. 

\section{Equijoins}

We will start talking about map initialization in the simplest of cases: queries represented by relations that are joined only by equalities.
\begin{align}
\mbox{SELECT sum(}\cdots\mbox{) FROM }&R_1,R_2,\cdots,R_n\mbox{ WHERE }R_i.x_{ik}=R_j.x_{jt} \label{query1}\\
&(\forall i,j\in\{1..n\}\land i\not=j\land (x_{ik}\in Sch(R_i))\nonumber\\
&\land(x_{jt}\in Sch(R_j))\nonumber
\end{align}

When having only equality joins, then the maps defined over expressions consisting of simple relations will have only output variables. Every variable will be bounded to the relations and therefore their domains will depend on the values provided by these relations.

For a the given query \ref{query1}, the compilation algorithm will replace it with a map $q[][]$. When computing the delta regarding to a relation $R_k$, $\Delta_{R_k}$, we are going to have a map assigned to the delta. $m_{R_k}[][x_i,\cdots,x_j]$, where $x_i,\cdots,x_j$ will be exactly as mentioned up, the variables that will have to be replaced by values when an event $onR_k$ will appear. The map can easily be compared with a query, which will be simpler and will also have a group by clause.

\begin{align}
\text{SELECT}\cdots&\text{ FROM }R_1,R_2,\cdots,R_{k-1},R_{k+1},\cdots,R_n\label{querygen}\\
&\text{ WHERE }R_l.x_{lt}=R_m.x_{ms}\nonumber\\
&(\forall l,m\in\{1\cdots n\}-\{k\}\land l\not=m)\nonumber\\
&\text{GROUP BY } x_i,\cdots,x_j\nonumber
\end{align}
	
Relation $R_k$ will have the following schema: $Sch(R_k)={x_1,x_2,x_3,\cdots,x_n}$, but only some variables are going to be used for the communication with the other relations: $x_i,\cdots,x_j$. We will have the trigger $+onR_k(x_1,\cdots,x_n)$, and when such an event appears we will test if the variables $x_i,\cdots,x_j$ from the arguments of $+onR$ are in the domain of the map or not. 
	
We assume that the tuple is not in the domain of the map $m_{R_k}$ and the initial value for the map regarding to that tuple will be different from 0.
$$m_{R_k}[][x_i,\cdots,x_j]\not= 0$$
If this is true then the query that can be generated for the map $m_{R_k}$, exactly like \ref{querygen},
will produce a table, that will have a record with the specified tuple, therefore the tuple will be in the domain of the map, $\{x_i,\cdots,x_j\in domain(m_{R_k}) \}$. This contradicts the sentence we assumed at first. Furthermore, when invoking the query for the given values the result of the query will not be $NULL$, and therefore contradicting the fact the that tuple is not defined in the table and the query result should be $NULL$. And therefore any time, a new tuple that is not in the domain will only provoke a zero initialization of the map for that tuple.

Taking into account the definitions of the AGCA expressions in \ref{def:agca}, the following theorem will work with a subset of those definitions, namely with:
$$q\text{ ::- }q\cdot q | q + q|R(\vec{y})|(M[\vec{x}][\vec{y}]\text{::-}q)$$

\begin{theorem}
The value of a map for a specific tuple, which is not in the domain of the map, will always be 0.
\end{theorem}
$$\vec{y}\notin\dom{}_{\vec{x}}(q)\Rightarrow m_q[][\vec{y}]=0$$

\begin{proof}
We will give a proof based on induction on the parse tree.

We presume that the map will be defined over a simple relation: $m_R[][\vec{y}]::R(\vec{y})$. The vector $\vec{y}$ from the output variables of the maps will correspond to the $\vec{y}$ from the simple relation. Therefore the following statement is true: $\dom{}_{\vec{x}}(m_R[][\vec{y}])=\dom{}_{\vec{x}}(R(\vec{y}))$.

If we add tuple $\vec{y_1}=\textless y_1,y_2,\cdots,y_n\textgreater$ to the relation $R$, we are going to have two situations:
\begin{enumerate}
\item $\vec{y_1}\in\dom{}_{\vec{x}}(R(\vec{y}))$, therefore the domain of the relation will remain the same and the map is already instantiated
\item $\vec{y_1}\notin\dom{}_{\vec{x}}(R(\vec{y}))$. If the tuple is not in the domain then: $$\dom{}_{\vec x}(R(\vec y))\cup=\vec{y_1}\mbox{ and }m_{R}[][\vec{y_1}]=0$$ because the order of multiplicity of that tuple in $R$ will be zero and thus any operation (sum, count) will produce a NULL result.
\end{enumerate}

$\vec{y_1}\notin\dom{}_{\vec{x}}(R(\vec{y}))\Rightarrow m_R[][\vec{y_1}]=0$ and therefore the base case is true.

First we will talk about join relations and maps defined over a join of expressions: $m_q[][\vec{y}]::q_1\cdot q_2$. Definition \ref{def:join} says that the domain of a join expression is the intersection between the domains of $q_1$ and $q_2$. If $\vec{y_1}\notin\dom{}_{\vec{x}}(q_1\cdot q_2)$ then we will have the following cases:
\begin{enumerate}
\item $\vec{y_1}\notin\dom{}_{\vec{x}}(q_1)$ which means that the map defined over the relation $q_1$ will be 0 for that tuple.
$$m_{q_1}[][\vec{y_1}]=0\land m_q[][\vec{y_1}]: m_{q_1}[][\vec{y_1}]*m_{q_2}[][\vec{y_1}]\Rightarrow m_{q}[][\vec{y_1}]=0*m_{q_2}[][\vec{y_1}]=0$$
where $m_{q_1}[][\vec{y_1}]::q_1$ and $m_{q_2}[][\vec{y_1}]::q_2$.
\item $\vec{y}\notin\dom{}_{\vec{x}}(q_2)$ the same proof as in the first case, but now for the expression $q_2$.
\end{enumerate}

Secondly we will talk about union expressions and maps defined over union expressions: $m_q[][\vec{y}]::q_1+q_2$. Definition \ref{def:plus} says that the domain of a union expression is the union between the domains of $q_1$ and $q_2$. Therefore, if $\vec{y}\notin\dom{}_{\vec{x}}(q_1+q_2)$ then: $\vec{y}\notin\dom{}_{\vec{x}}(q_1)\land \vec{y}\notin\dom{}_{\vec{x}}(q_2)$.

$$m_{q_1}[][\vec{y_1}]=0\land m_{q_2}[][\vec{y_1}]=0\land m_q[][\vec{y_1}]: m_{q_1}[][\vec{y_1}]+m_{q_2}[][\vec{y_1}]\Rightarrow m_q[][\vec{y_1}]=0$$
where $m_{q_1}[][\vec{y_1}]::q_1$ and $m_{q_2}[][\vec{y_1}]::q_2$.
\end{proof}

Another problem of initial value computation, besides the problem of with which value should a map be initialized, is the problem of how fast to do the initialization. We have two different sort of initializations: an eager one and a lazy one. The eager one will initialize the right side of a trigger expression, when the left side of the expression will be initialized. The right side will be initialized if and only if it needs initialization. And the lazy one is based on the fact that only the left side will be initialized, and the right side no, leaving the rest side of the initialization to be done when the appropriate trigger is called.

\section{Simple inequalities}

Joins between relations can be easily made also by using inequalities between the variables of those relations. For example, if we have the following query:
\begin{align*}
\mbox{SELECT }sum(a*d)\\
\mbox{FROM } R(a,b),S(c,d)\\
\mbox{WHERE } b\textless c 
\end{align*}
the result will depend on the evaluation of the inequality $b\textless c$, where $b$ comes from relation $R$ and $c$ comes from relation $S$.

The delta regarding to the relation $R$ will be: 
\begin{align*}
a*\mbox{SELECT }sum(d)\\
\mbox{FROM }S(c,d)\\
\mbox{WHERE } b\textless c 
\end{align*}
where the new query will be replaced by a map which will have an input variable $m_R[b][]$. The domain of the map be will given by the values offered by relation R, however the result of the map will be influenced by the value of $c$ from the relation $S$.

The initial value of the map $m_R[b][]$ will be influenced by the relation $S$. Therefore we will have the following situations:
\begin{enumerate}
\item the relation $S$ is empty and therefore no value of $c$ can be produced and thus the initialization of the map $m_R[b][]$ will always be 0, because b cannot be compared with any value of $c$
\item if relation $S$ is not empty then every update to relation $R$ will need a check with every value c from $S$. Therefore we can say that the initial value of map $m_R[b][]=\sum_{\forall c>b} S(c,d)*d$
\end{enumerate}

When relation $S$ is not empty, the initialization of map $m_R[b][]$ can easily be maintained incrementally, because knowing a value of the map for a specific $b$, the other one can be easily deduced. We will have $sum=m_R[b_{1}][]$, where $b_{1}$ is a value that we had to compute the result of the map from scratch. When adding a value $b_{2}$ to the relation $R$, we will have the following cases:

\begin{enumerate}
\item $b_{1}>b_{2}$ then $m_R[b_{2}][]=sum + \sum_{\forall\mbox{c where }b_{2}<c\leq b_{1}} S(c,d)*d$
\item $b_{1}<b_{2}$ then $m_R[b_{2}][]=sum - \sum_{\forall\mbox{c where }b_{1}\leq c<b_{2}} S(c,d)*d$
\end{enumerate}

Starting from this example we will offer a generalization and a proof that the initial value of maps, when talking about joins done by inequalities, are going to be exactly like in the example.

\begin{thebibliography}{9}
\bibitem{1} C. Koch, \emph{Incremental Query Evaluation in a Ring of Databases},  preprint (2011).
\bibitem{2} O. Kennedy, Y. Ahmad, C. Koch. \emph{DBToaster: Agile views for a dynamic data management system}. In CIDR, 2011.
\end{thebibliography}
\end{document}