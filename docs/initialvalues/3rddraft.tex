\documentclass[12pt]{article}

\usepackage{tikz}
\usetikzlibrary{shapes,snakes}
\usetikzlibrary{arrows,automata}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx} 
\usepackage{fancybox}
\usepackage{setspace}  
\usepackage[colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{enumerate} 
\usepackage{amsthm,amssymb,amsmath}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{alltt}
\usepackage{clrscode}
\usepackage{float}
\renewcommand{\algorithmiccomment}[1]{// #1}
\floatstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newfloat{program}{h}{lop}[section]
\floatname{program}{}

\newcommand{\dom}{\textsf{dom}}
\newcommand{\arity}{\textsf{arity}}
\newcommand{\InputVars}{\textsf{InputVars}}
\newcommand{\OutputVars}{\textsf{OutputVars}}
\newcommand{\Rel}{\textsf{Rel}}
\newcommand{\Ext}{\textsf{Ext}}
\title{Map Initializations}
\date{\today}

\begin{document}
\maketitle
\section{Introduction}
In this section we would want to discuss the matter of map initialization. From $\cite{1}$ we know that the compilation algorithm takes an aggregate query and defines a map for it, which represents the materialized view of the query. The algorithm creates a trigger for each possible update on an event, that will specify how to update the main query. To this operation, the algorithm computes the delta query, and creates a new map that will represent the materialized view of the delta. For example, if we have the following query q:
\begin{equation}
\mbox{SELECT sum(}a\cdot c\mbox{) FROM R(a,b), S(b,c) WHERE } R.b=S.b
\end{equation}
The compilation algorithm will take this query and replaces it with a map $q[][]$ and computes its deltas. We will have two events: $onR$, $onS$. For simplicity we will take for now only the inserting operation, the trigger code will look like, :
\begin{align*}
+onR(a,b)&:\\
&q[][]+=a*m_R[][b]\\
&m_S[][b]+=a\\
\end{align*}\vspace{-40pt}
\begin{align*}
+onS&(b,c):\\
&q[][]+=c*m_S[][b]\\
&m_R[][b]+=c\\
\end{align*}
In \cite{1} a map is defined by as function which takes input values and produces output values. With this definition, we can consider the initialization as a process of computing the function's output values for some new input values without computing the function body.
The main goal of this section is to study how two maps $m_R[][b]$ and $m_S[][b]$ will be initialized when an insertion is triggered either from $+onR(a,b)$ and also $+onS(b,c)$. \\\par
\section{Definitions}
DBToaster uses query language AGCA(which is stands for AGgregation CAlculus). 
AGCA expressions are built from constants, variables, relational atoms, aggregate sums (Sum), conditions, and variable assignments ($\gets$) using ``+''  and ``$\cdot$''. The abstract syntax can be given by the EBNF:
\begin{equation}
\label{def:agca}
q\text{ ::- }q\cdot q | q + q|v \gets q |v_{1}\theta v_{2}|R(\vec{y})|\text{c}|\text{v}|(M[\vec{x}][\vec{y}]\text{::-}q)
\end{equation}
The above definition can express all SQL statements. Here $v$ denotes variables, $\vec{x},\vec{y}$ tuples of variables, $R$ relation names, $c$ constants, and $\theta$ denotes comparison operations $(=,\neq, >, \geq, <, \text{ and }\leq)$.
 ``+'' represents unions and ``$\cdot$'' represents joins. Assignment operator($\gets$) takes an query and assigns its result to a variable($v$). A map $M[\vec{x}][\vec{y}]$ is a subquery with some input($\vec{x}$) and output($\vec{y}$) variables. It can be seen as a nested query that for the arguments $\vec{x}$ produces the output $\vec{y}$, it is not defined in \cite{1} but we added here for the purpose of this work.

The domain of a variable is the set of values that it can take. The domain of all the variables in a query expression can easily be computed recursively if some rules are respected. We will use through out the entire paper the notation of $\text{\dom{}}_{\vec x}(q)$ for the domain of a set of variables, where $q$ is the given query and $\vec x$ is a vector representing the variables(not necessarily present in the expression $q$). We will start by saying the $\vec x=\textless x_1,x_2,x_3,\cdots,x_n\textgreater$ will be the schema of all the variables 
and that $\vec c=\textless c_1,c_2,c_3,\cdots,c_n\textgreater$ will be the vector of all constants, that will match the schema presented by $\vec x$. It is not necessary that $\vec{x}$  has the same schema as the given expression. We will give the definition of $\dom{}_{\vec x}(R(\vec y))$:

%\begin{equation}
%\label{def:relation}
%\dom{}_{\vec x}(R(\vec y))=\bigg\{\vec %c\,\Big|\,(\prod_{i:x_{i}\in \vec y}^{}(x_{i}\gets %c_{i})\cdot R(\vec y))\not= 0\bigg\}
%\end{equation}

\begin{equation}
\label{def:relation}
\dom{}_{\vec x}(R(\vec y))=\bigg\{\vec c\,\Big|\,\sigma_{\forall x_i\in(\vec{y}): x_{i}=c_{i}}R(\vec y)\not= \const{NULL}\bigg\}
\end{equation}

Thus, we can evaluate $\text{\dom}_{\vec{x}}$ for a broader range of $\vec{x}$ and it is not restricted by the schema of the input query expression. In such cases the \dom{} is infinite as the not presenting variables in the query can take any value.

For the comparison operator ($v_{1}\theta v_{2}$), where $v_1$ and $v_2$ are variables, we can compute the domain as follows:
%\begin{equation}
%\text{\dom{}}_{\vec{x}}(v_{1}\theta v_{2})=\bigg\{\vec{c}\,\Big|\,\Big(\big(\prod_{i}(x_{i}\gets c_{i})\big)(v_{1}\theta v_{2})\Big)\not= 0\bigg\}
%\end{equation}

\begin{equation}
\text{\dom{}}_{\vec{x}}(v_{1}\theta v_{2})=\bigg\{\vec{c}\,\Big|\,\forall i,j:(v_{1}=x_{i}\land v_{2}=x_{j})\Rightarrow c_{i}\theta c_{j}\bigg\}
\end{equation}

The domain of a comparison is infinite.

For the join operator we can write:
\begin{equation}
\label{def:join}
\text{\dom{}}_{\vec{x}}(q_{1}\cdot q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation}
while for the union operator the domain definition is very similar:
\begin{equation}
\label{def:plus}
\text{\dom{}}_{\vec{x}}(q_{1}+ q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\lor\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation}
\begin{eqnarray}
\dom{}_{\vec x}(constant)=\Big\{\vec c\Big\}\label{def:const}\\
\dom{}_{\vec x}(variable)=\Big\{\vec c\Big\}\label{def:var}
\end{eqnarray}
In \eqref{def:const} and \eqref{def:var}  $\vec{c}$ stands for all possible tuples match schema of $\vec{x}$, so the domains in these two cases are infinite. 
Finally, we can give a formalism for expressing the domain of a variable that will participate in an assignment operation:
%\begin{equation}
%\label{assign1}
%\text{\dom{}}_{\vec{x}}(v\gets q_{1})=\bigg\{\vec{c}\,\Big|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land \bigg(\forall i:(x_{i}=v)\Rightarrow\Big(\big(q_{1}\cdot\prod_{j:x_{j}\neq v } (x_{j}=c_{j})\big)=c_{i}\Big)\bigg)\bigg\}
%\end{equation}
\begin{equation}
\label{assign2}
\text{\dom{}}_{\vec{x}}(v\gets q_{1})=\Big\{\vec{c}\Big|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land \big(\forall i,j: (x_{i}=v=x_{j})\Rightarrow(c_{i}=c_{j}=q_{1})\big)\Big\}
\end{equation}
In fact using implication operator in the above definition allows us to extend the $\vec{x}$ to whatever vector we want, as we already said the schema of $\vec{x}$ is not necessarily the same as the schema of $q$. %Here is a mathematical reformulation of \eqref{assign1}:
We can define the domain of a map(for map's definition refer to \cite{1}, \cite{2}) as follow:
\begin{equation}
\label{def:map}
\text{\dom}_{\vec{w}}(map[\vec{x}][\vec{y}])=\{\vec{c}|\vec{c}\in\text{\dom}_{\vec{w}}(\vec{x}\cup\vec{y})\}
\end{equation}

We can say that domains can be grouped into two categories, Complete and Incomplete.These definitions form the complete domains.
 %Having these two notions we should offer a definition for each, and some notions that might help us when demonstrating the initialization of maps. 

We show the incomplete domains with $D_{incomplete}$ and complete domains by $D_{complete}$ and we can say that every time a value is added to a complete domain, it will remain complete. Incomplete domains are subsets of complete domains. In other words some elements are not covered in the incomplete domains. If we modify the relations, the domains of all expressions will be changed. If we follow the definitions as we had in this section we will have the complete domains again. Thus, the complete domains are closed under the modifications of the relations. Complete domains will always have a straight forward connection with the underlying relations.

\begin{theorem}
If we have a complete domain of a map it will remain complete with any modifications of its underlying relations.
\end{theorem}

\begin{proof}
Suppose we have a map $m$ and its complete domain as $D$. If we modify a relation, there are two cases:
\begin{enumerate}
\item This modification does not modify the domain of $m$. So The domain of $m$ remains complete after the modification.
\item The modification does change the domain of the relation and it will propagate upward on the parse tree, therefore provoking a change to the domain of the map. The change done to a relation will update all the other relations before reaching the domain of the map and therefore maintaining the completeness of each domain.
\end{enumerate}
\end{proof}
When talking about incomplete domains, the theorem presented for the complete domains will not hold. Incomplete domains will not have a direct mapping to all the values from the relations. We will not want to use the entire domain, we want to create it as we go. This will imply that every time a new value is added to an incomplete domain, then that value should be tested if it appears in the complete domain, that we did not want to compute. We will have the following relation between complete and incomplete domains of the same variable: $$D_{incomplete}\subset D_{complete}$$
Every time a new variable $x$ is added to the incomplete domain we are going to have three situations: 
\begin{enumerate}
\item $x\in D_{incomplete}$
\item $(x\notin D_{incomplete})\land(x\in D_{complete})$
\item $(x\notin D_{incomplete})\land(x\notin D_{complete})$
\end{enumerate}
The first case is exactly as with complete domains, therefore the new value is in the domain and nothing will be changed, the second case means that the new value is not in the incomplete domain however there is such a value in its underlaying relations, and therefore computation is necessary for determining the correct value for the newly added one, and in the third case the new value is quit new and therefore all the initialization for that one should be zero because nothing is dependent on it.

After giving these definitions, we can say that we can easily construct a complete domain starting from an incomplete domain, by adding values to the incomplete one. 

\section{Equijoins}

We will start talking about map initialization in the simplest of cases: queries represented by relations that are joined only by equalities.
\begin{align*}
\mbox{SELECT sum(}\cdots\mbox{) FROM }&R_1,R_2,\cdots,R_n\mbox{ WHERE }R_i.a=R_j.a \\
&(\forall i,j\in\{1..n\}\land i\not=j)
\end{align*}

When having only equality joins, then the maps defined over expressions consisting of simple relations will have only output variables. Every variable will be bounded to the relations and therefore their domains will depend on the values provided from the relations. If we have $$\mbox{SELECT }\cdots\mbox{ FROM }R_1,R_2,\cdots,R_n\mbox{ WHERE }R_i.a=R_j.a$$ the compiler will assign a map to the main query $q[][]$ and each delta query will be replaced by the materialized view. If we have $\Delta_{R_1}$, the relation $R_1$ will disappear from the main query and the new expression will be replace by a map $m_{R_1}[][x_i,\cdots,x_j]$, where $x_i,\cdots,x_j$ represent the communication variables between $R_1$ and the rest of the expression.

The map $m_{R_{1}}[][x_i,\cdots,x_j]$ can also be defined using a simpler query with only $n-1$ relations:
\begin{align*}
\mbox{SELECT}\cdots&\mbox{ FROM }R_2,\cdots,R_n\\
&\mbox{ WHERE }R_l.a=R_m.a\\
&(\forall l,m\in\{2\cdots,n\}\land l\not=m)\\
&\mbox{GROUP BY } x_i,\cdots,x_j
\end{align*}

In a general case when computing the $\Delta_{R_k}$, we are going to have a map assigned to the delta. $m_{R_k}[][x_i,\cdots,x_j]$, where $x_i,\cdots,x_j$ will be exactly as mentioned up, the variables that will have to be replaced by values when an event $onR_k$ will appear. The map can easily be compared with a query, which will be simpler and will also have a group by clause.

\begin{align*}
\text{SELECT}\cdots&\text{ FROM }R_1,R_2,\cdots,R_{k-1},R_{k+1},\cdots,R_n\\
&\text{ WHERE }R_l.a=R_m.a\\
&(\forall l,m\in\{1\cdots n\}-\{k\}\land l\not=m)\\
&\text{GROUP BY } x_i,\cdots,x_j
\end{align*}

\begin{theorem}
The initial value of a map for a specific tuple, which is not in the domain of the map, will always be 0.
\end{theorem}

\begin{proof}
	If the tuple that has been added is in the complete domain then the map has already been initialized.
	
	We will apply reduction to the absurd to prove that whenever we add a new tuple that is not in the domain of a map, then that map should be initialized by 0.
	
	Relation $R_k$ will have the following schema: $Sch(R_k)={x_1,x_2,x_3,\cdots,x_n}$, but only some variables are going to be used for the communication with the other relations: $x_i,\cdots,x_j$. We will have the trigger $+onR_k(x_1,\cdots,x_n)$, and when such an event appears we will test if the variables $x_i,\cdots,x_j$ from the arguments of $+onR$ are in the domain of the map or not. 
	
	We assume that the tuple is not in the domain of the map $m_{R_k}$ and the initial value for the map regarding to that tuple will be different from 0.
	$$m_{R_k}[][x_i,\cdots,x_j]\not= 0$$
	If this is true then the query that can be generated for the map $m_{R_k}$:
	\begin{align*}
	\mbox{SELECT}\cdots&\mbox{ FROM }R_1,R_2,\cdots,R_{k-1},R_{k+1},\cdots,R_n\\
	&\mbox{ WHERE }R_l.a=R_m.a\\
	&(\forall l,m\in\{1\cdots n\}-\{k\}\land l\not=m)\\
	&\mbox{GROUP BY } x_i,\cdots,x_j
	\end{align*}
	will produce a table, that will have a record with the specified tuple, therefore the tuple will be in the domain of the map, $\{x_i,\cdots,x_j\in domain(m_{R_k}) \}$. This contradicts the sentence we assumed at first. Furthermore, when invoking the query for the given values the result of the query will not be $NULL$, and therefore contradicting the fact the that tuple is not defined in the table and the query result should be $NULL$. And therefore any time, a new tuple that is not in the domain will only provoke a zero initialization of the map for that tuple.
\end{proof}

The theorem will stand only if we are talking about having a complete domain. Otherwise, if the domain is incomplete, then for every tuple that we add with a trigger, we would have to check if that tuple exists in the table (the complete domain). If the domain is incomplete, then we could have a different value for the initial value of a map, this value would be produced from the tables performing a query, even a simpler one.

Another problem of initial value computation, besides the problem of with which value should a map be initialized, is the problem of how fast to do the initialization. We have two different sort of initializations: an eager one and a lazy one. The eager one will initialize the right side of a trigger expression, when the left side of the expression will be initialized. The right side will be initialized if and only if it needs initialization. And the lazy one is based on the fact that only the left side will be initialized, and the right side no, leaving the rest side of the initialization to be done when the appropriate trigger is called.

\begin{thebibliography}{9}
\bibitem{1} C. Koch, \emph{Incremental Query Evaluation in a Ring of Databases},  preprint (2011).
\bibitem{2} O. Kennedy, Y. Ahmad, C. Koch. \emph{DBToaster: Agile views for a dynamic data management system}. In CIDR, 2011.
\end{thebibliography}
\end{document}