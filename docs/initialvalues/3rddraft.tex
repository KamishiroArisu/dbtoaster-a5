\documentclass[12pt]{article}

\usepackage{tikz}
\usetikzlibrary{shapes,snakes}
\usetikzlibrary{arrows,automata}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{graphicx} 
\usepackage{fancybox}
\usepackage{setspace}  
\usepackage[colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{enumerate} 
\usepackage{amsthm,amssymb,amsmath}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{alltt}
\usepackage{clrscode}
\usepackage{float}
\renewcommand{\algorithmiccomment}[1]{// #1}
\floatstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newfloat{program}{h}{lop}[section]
\floatname{program}{}

\newcommand{\dom}{\textsf{dom}}
\newcommand{\arity}{\textsf{arity}}
\newcommand{\InputVars}{\textsf{InputVars}}
\newcommand{\OutputVars}{\textsf{OutputVars}}
\newcommand{\Rel}{\textsf{Rel}}
\newcommand{\Ext}{\textsf{Ext}}
\title{Map Initializations}
\date{\today}

\begin{document}
\maketitle
\section{Introduction}
In this section we would want to discuss the matter of map initialization. From $\cite{1}$ we know that the compilation algorithm takes an aggregate query and defines a map for it, which represents the materialized view of the query. The algorithm creates a trigger for each possible update on an event, that will specify how to update the main query. To this operation, the algorithm computes the delta query, and creates a new map that will represent the materialized view of the delta. For example, if we have the following query q:
\begin{equation}
\mbox{SELECT sum(}a\cdot c\mbox{) FROM R(a,b), S(b,c) WHERE } R.b=S.b
\end{equation}
The compilation algorithm will take this query and replaces it with a map $q[][]$ and computes its deltas. We will have two events: $onR$, $onS$. For simplicity we will take for now only the inserting operation, the trigger code will look like, :
\begin{align*}
+onR(a,b)&:\\
&q[][]+=a*m_R[][b]\\
&m_S[][b]+=a\\
\end{align*}\vspace{-40pt}
\begin{align*}
+onS&(b,c):\\
&q[][]+=c*m_S[][b]\\
&m_R[][b]+=c\\
\end{align*}
In \cite{1} a map is defined by as function which takes input values and produces output values. With this definition, we can consider the initialization as a process of computing the function's output values for some new input values without computing the function body.

\section{Definitions}
DBToaster uses query language AGCA(which is stands for AGgregation CAlculus). 
AGCA expressions are built from constants, variables, relational atoms, aggregate sums (Sum), conditions, and variable assignments ($\gets$) using ``+''  and ``$\cdot$''. The abstract syntax can be given by the EBNF:
\begin{equation}
\label{def:agca}
q\text{ ::- }q\cdot q | q + q|v \gets q |v_{1}\theta v_{2}|R(\vec{y})|\text{c}|\text{v}|(M[\vec{x}][\vec{y}]\text{::-}q)
\end{equation}
The above definition can express all SQL statements. Here $v$ denotes variables, $\vec{x},\vec{y}$ tuples of variables, $R$ relation names, $c$ constants, and $\theta$ denotes comparison operations $(=,\neq, >, \geq, <, \text{ and }\leq)$.
 ``+'' represents unions and ``$\cdot$'' represents joins. Assignment operator($\gets$) takes an query and assigns its result to a variable($v$). A map $M[\vec{x}][\vec{y}]$ is a subquery with some input($\vec{x}$) and output($\vec{y}$) variables. It can be seen as a nested query that for the arguments $\vec{x}$ produces the output $\vec{y}$, it is not defined in \cite{1} but we added here for the purpose of this work.

The domain of a variable is the set of values that it can take. The domain of all the variables in a query expression can easily be computed recursively if some rules are respected. We will use through out the entire paper the notation of $\text{\dom{}}_{\vec x}(q)$ for the domain of a set of variables, where $q$ is the given query and $\vec x$ is a vector representing the variables(not necessarily present in the expression $q$). We will start by saying the $\vec x=\textless x_1,x_2,x_3,\cdots,x_n\textgreater$ will be the schema of all the variables 
and that $\vec c=\textless c_1,c_2,c_3,\cdots,c_n\textgreater$ will be the vector of all constants, that will match the schema presented by $\vec x$. It is not necessary that $\vec{x}$  has the same schema as the given expression. We will give the definition of $\dom{}_{\vec x}(R(\vec y))$:

%\begin{equation}
%\label{def:relation}
%\dom{}_{\vec x}(R(\vec y))=\bigg\{\vec %c\,\Big|\,(\prod_{i:x_{i}\in \vec y}^{}(x_{i}\gets %c_{i})\cdot R(\vec y))\not= 0\bigg\}
%\end{equation}

\begin{equation}
\label{def:relation}
\dom{}_{\vec x}(R(\vec y))=\bigg\{\vec c\,\Big|\,\sigma_{\forall x_i\in(\vec{y}): x_{i}=c_{i}}R(\vec y)\not= \const{NULL}\bigg\}
\end{equation}

Thus, we can evaluate $\text{\dom}_{\vec{x}}$ for a broader range of $\vec{x}$ and it is not restricted by the schema of the input query expression. In such cases the \dom{} is infinite as the not presenting variables in the query can take any value.

For the comparison operator ($v_{1}\theta v_{2}$), where $v_1$ and $v_2$ are variables, we can compute the domain as follows:
%\begin{equation}
%\text{\dom{}}_{\vec{x}}(v_{1}\theta v_{2})=\bigg\{\vec{c}\,\Big|\,\Big(\big(\prod_{i}(x_{i}\gets c_{i})\big)(v_{1}\theta v_{2})\Big)\not= 0\bigg\}
%\end{equation}

\begin{equation}
\text{\dom{}}_{\vec{x}}(v_{1}\theta v_{2})=\bigg\{\vec{c}\,\Big|\,\forall i,j:(v_{1}=x_{i}\land v_{2}=x_{j})\Rightarrow c_{i}\theta c_{j}\bigg\}
\end{equation}

The domain of a comparison is infinite.

For the join operator we can write:
\begin{equation}
\label{def:join}
\text{\dom{}}_{\vec{x}}(q_{1}\cdot q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation}
while for the union operator the domain definition is very similar:
\begin{equation}
\label{def:plus}
\text{\dom{}}_{\vec{x}}(q_{1}+ q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\lor\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation}
\begin{eqnarray}
\dom{}_{\vec x}(constant)=\Big\{\vec c\Big\}\label{def:const}\\
\dom{}_{\vec x}(variable)=\Big\{\vec c\Big\}\label{def:var}
\end{eqnarray}
In \eqref{def:const} and \eqref{def:var}  $\vec{c}$ stands for all possible tuples match schema of $\vec{x}$, so the domains in these two cases are infinite. 
Finally, we can give a formalism for expressing the domain of a variable that will participate in an assignment operation:
%\begin{equation}
%\label{assign1}
%\text{\dom{}}_{\vec{x}}(v\gets q_{1})=\bigg\{\vec{c}\,\Big|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land \bigg(\forall i:(x_{i}=v)\Rightarrow\Big(\big(q_{1}\cdot\prod_{j:x_{j}\neq v } (x_{j}=c_{j})\big)=c_{i}\Big)\bigg)\bigg\}
%\end{equation}
\begin{equation}
\label{assign2}
\text{\dom{}}_{\vec{x}}(v\gets q_{1})=\Big\{\vec{c}\Big|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land \big(\forall i,j: (x_{i}=v=x_{j})\Rightarrow(c_{i}=c_{j}=q_{1})\big)\Big\}
\end{equation}
In fact using implication operator in the above definition allows us to extend the $\vec{x}$ to whatever vector we want, as we already said the schema of $\vec{x}$ is not necessarily the same as the schema of $q$. %Here is a mathematical reformulation of \eqref{assign1}:
We can define the domain of a map(for map's definition refer to \cite{1}, \cite{2}) as follow:
\begin{equation}
\label{def:map}
\text{\dom}_{\vec{w}}(map[\vec{x}][\vec{y}])=\{\vec{c}|\vec{c}\in\text{\dom}_{\vec{w}}(\vec{x}\cup\vec{y})\}
\end{equation}

As presented in the papers \cite{1} and \cite{2}, maps are functions that are defined on a set of values and that will produce a result for each value of that set. The set of values will represent the domains, which were computed using the definitions presented so far. We can make a distinction between a complete map and an incomplete map. A complete map will be characterized by the fact that each value of its domain will have assigned a result, whilst an incomplete map will be a map that will not have all the values of the domain and therefore neither the result for those values, on each insertion the incomplete map must compute the exact value of the tuple added to the domain.\\ \par
In other words we can consider a complete map as a total function and an incomplete one as a partial function. A total function is a function that assigns a value to every element of its domain. But a partial function has some elements in its domain which have not been assigned to any value in its codomain. \par

According to \ref{def:agca} we can express every expression of AGCA in a parse tree. The root of parse tree represents the whole expression and its leaves are relations or comparisons. Each node can be regarded as a map and thus it has a domain. Any modification to the relations, the leaves are modified and this modification should be propagated upward through the parse tree. During the propagation process the domains of intermediate nodes may be changed. In Theorem~\ref{theorem:completemap} we prove that if all maps in the parse tree are complete, then with any modification the maps will remain complete as well. 

\begin{theorem}
\label{theorem:completemap}
A complete map will remain complete, after provoking a modification to the underlying expression of the map.
\end{theorem}

\begin{proof}
We will give a proof based on induction.

In the first step we presume that the map will be defined over a simple relation: $$m[][\vec{y}]::R(\vec{y})$$ The vector $\vec{y}$ from the output variables of the maps will correspond to the $\vec{y}$ from the simple relation. Therefore there will be a direct connection between the domain of the map and the values offered by the relation. Therefore we will have: 
$$\dom{}_{\vec{x}}(m[][\vec{y}])=\dom{}_{\vec{x}}(R(\vec{y}))$$ 

If we add tuple $\textless y_1,y_2,\cdots,y_n\textgreater$ to the relation $R$, we are going to have to situations:
\begin{enumerate}
\item $\textless y_1,y_2,\cdots,y_n\textgreater\in\dom{}_{\vec{x}}(R(\vec{y}))$ and therefore the map remains complete
\item $\textless y_1,y_2,\cdots,y_n\textgreater\notin\dom{}_{\vec{x}}(R(\vec{y}))$ and therefore the tuple should be added to domain of the relation, however due to the fact that there is a direct connection between the domain of the relation and the domain of the map, the domain of the map will change and the map will remain complete
\end{enumerate}

Secondly if we have a map defined on a join expression: $$m[][\vec{y1}]::R(\vec{y2})\cdot q$$ The domain of the map will be determined by the domain of the join expression: $$\dom{}_{\vec{x}}(m[][\vec{y1}])=\dom{}_{\vec{x}}(R(\vec{y2})\cdot q)$$ and therefore using the definition for the join expression the map will be a complete map. 

When adding a new tuple into relation $R$ we will have exactly the same possibilities as in the previous case, however in the second case there must be added something: the domain of the map will be influenced by the join operator, therefore taking only the common tuples between $R(\vec{y})$ and $q$. If the tuple that we are adding is also in the domain of expression $q$, then it will be added to the maps domain, otherwise no. However in both cases the map completion will stand.

Thirdly if we have a map defined on a union expression: $$m[][\vec{y1}]::R(\vec{y2})+ q$$ Exactly like in the previous case the domain of the map will be given by the union relation: $$\dom{}_{\vec{x}}(m[][\vec{y1}])=\dom{}_{\vec{x}}(R(\vec{y2})+ q)$$ When talking about union expressions,we will not have communication over between this operator, furthermore the domain of a such expression will be the union of the two domains. Therefore if we change add a tuple $\textless y_1,y_2,\cdots,y_n\textgreater\in\dom{}_{\vec{x}}(R(\vec{y}))$ to relation $R$, the cases from the first step will remain, regardless if the tuple is or not in the expression $q$. 

Finally if we have a map defined on a join or union expression $$m[][\vec{y1}]::q1\alpha q$$ where $\alpha=\{\cdot,+\}$, the relation will hold for q1 and for q2 due to the induction steps and  therefore it will also hold for the $q1\alpha q2$.
\end{proof}

\section{Equijoins}

We will start talking about map initialization in the simplest of cases: queries represented by relations that are joined only by equalities.
\begin{align*}
\mbox{SELECT sum(}\cdots\mbox{) FROM }&R_1,R_2,\cdots,R_n\mbox{ WHERE }R_i.a=R_j.a \\
&(\forall i,j\in\{1..n\}\land i\not=j)
\end{align*}

When having only equality joins, then the maps defined over expressions consisting of simple relations will have only output variables. Every variable will be bounded to the relations and therefore their domains will depend on the values provided from the relations. If we have $$\mbox{SELECT }\cdots\mbox{ FROM }R_1,R_2,\cdots,R_n\mbox{ WHERE }R_i.a=R_j.a$$ the compiler will assign a map to the main query $q[][]$ and each delta query will be replaced by the materialized view. If we have $\Delta_{R_1}$, the relation $R_1$ will disappear from the main query and the new expression will be replace by a map $m_{R_1}[][x_i,\cdots,x_j]$, where $x_i,\cdots,x_j$ represent the communication variables between $R_1$ and the rest of the expression.

The map $m_{R_{1}}[][x_i,\cdots,x_j]$ can also be defined using a simpler query with only $n-1$ relations:
\begin{align*}
\mbox{SELECT}\cdots&\mbox{ FROM }R_2,\cdots,R_n\\
&\mbox{ WHERE }R_l.a=R_m.a\\
&(\forall l,m\in\{2\cdots,n\}\land l\not=m)\\
&\mbox{GROUP BY } x_i,\cdots,x_j
\end{align*}

In a general case when computing the $\Delta_{R_k}$, we are going to have a map assigned to the delta. $m_{R_k}[][x_i,\cdots,x_j]$, where $x_i,\cdots,x_j$ will be exactly as mentioned up, the variables that will have to be replaced by values when an event $onR_k$ will appear. The map can easily be compared with a query, which will be simpler and will also have a group by clause.

\begin{align*}
\text{SELECT}\cdots&\text{ FROM }R_1,R_2,\cdots,R_{k-1},R_{k+1},\cdots,R_n\\
&\text{ WHERE }R_l.a=R_m.a\\
&(\forall l,m\in\{1\cdots n\}-\{k\}\land l\not=m)\\
&\text{GROUP BY } x_i,\cdots,x_j
\end{align*}

\begin{theorem}
The initial value of a map for a specific tuple, which is not in the domain of the map, will always be 0.
\end{theorem}

\begin{proof}
	If the tuple that has been added is in the complete domain then the map has already been initialized.
	
	We will apply reduction to the absurd to prove that whenever we add a new tuple that is not in the domain of a map, then that map should be initialized by 0.
	
	Relation $R_k$ will have the following schema: $Sch(R_k)={x_1,x_2,x_3,\cdots,x_n}$, but only some variables are going to be used for the communication with the other relations: $x_i,\cdots,x_j$. We will have the trigger $+onR_k(x_1,\cdots,x_n)$, and when such an event appears we will test if the variables $x_i,\cdots,x_j$ from the arguments of $+onR$ are in the domain of the map or not. 
	
	We assume that the tuple is not in the domain of the map $m_{R_k}$ and the initial value for the map regarding to that tuple will be different from 0.
	$$m_{R_k}[][x_i,\cdots,x_j]\not= 0$$
	If this is true then the query that can be generated for the map $m_{R_k}$:
	\begin{align*}
	\mbox{SELECT}\cdots&\mbox{ FROM }R_1,R_2,\cdots,R_{k-1},R_{k+1},\cdots,R_n\\
	&\mbox{ WHERE }R_l.a=R_m.a\\
	&(\forall l,m\in\{1\cdots n\}-\{k\}\land l\not=m)\\
	&\mbox{GROUP BY } x_i,\cdots,x_j
	\end{align*}
	will produce a table, that will have a record with the specified tuple, therefore the tuple will be in the domain of the map, $\{x_i,\cdots,x_j\in domain(m_{R_k}) \}$. This contradicts the sentence we assumed at first. Furthermore, when invoking the query for the given values the result of the query will not be $NULL$, and therefore contradicting the fact the that tuple is not defined in the table and the query result should be $NULL$. And therefore any time, a new tuple that is not in the domain will only provoke a zero initialization of the map for that tuple.
\end{proof}

The theorem will stand only if we are talking about having a complete domain. Otherwise, if the domain is incomplete, then for every tuple that we add with a trigger, we would have to check if that tuple exists in the table (the complete domain). If the domain is incomplete, then we could have a different value for the initial value of a map, this value would be produced from the tables performing a query, even a simpler one.

Another problem of initial value computation, besides the problem of with which value should a map be initialized, is the problem of how fast to do the initialization. We have two different sort of initializations: an eager one and a lazy one. The eager one will initialize the right side of a trigger expression, when the left side of the expression will be initialized. The right side will be initialized if and only if it needs initialization. And the lazy one is based on the fact that only the left side will be initialized, and the right side no, leaving the rest side of the initialization to be done when the appropriate trigger is called.

\begin{thebibliography}{9}
\bibitem{1} C. Koch, \emph{Incremental Query Evaluation in a Ring of Databases},  preprint (2011).
\bibitem{2} O. Kennedy, Y. Ahmad, C. Koch. \emph{DBToaster: Agile views for a dynamic data management system}. In CIDR, 2011.
\end{thebibliography}
\end{document}