\documentclass[12pt]{article}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes}
\usetikzlibrary{arrows,automata}
\usepackage{algorithm}
\usepackage{algorithmic}%\usepackage[pagebackref=true,colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{graphicx} 
\usepackage{fancybox}
\usepackage{setspace}  
\usepackage[colorlinks,linkcolor=blue,citecolor=magenta]{hyperref}
\usepackage{enumerate} 
%\usepackage{auto-pst-pdf} 
\usepackage{amsthm,amssymb,amsmath}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{alltt}

\begin{document}

\title{Initial Value Computation}
\author{}
\date{\today}
\maketitle
\newcommand{\dom}{\textsf{dom}}

\section{Definitions}
In this draft we want to explain the notion of domain. The domain of a variable is the set of values that a variable can take. The domain of all the variables in a query expression can easily be created recursively if some rules will be respected. We will use through out the entire paper the notation of $\text{\dom{}}_{\vec x}(q)$ for the domain of a set of variables, where $\vec x$ is a vector representing the variables present in the expression $q$. Taking into account the expressions from the AGCA (Aggregate Calculus\cite{1}) the definition of an expression will be: 
$$q\text{ ::- }q\cdot q | q + q|v \gets q |v_{1}\theta v_{2}|R(\vec{y})|\text{constant}|\text{variable}$$

We will start with the definition of $\dom{}_{\vec x}(R(\vec y))$:
$$\dom{}_{\vec x}(R(\vec y))=\bigg\{\vec c\,|\,(\pi_{\forall i:x_{i}\in \vec y}^{}(x_{i}\gets c_{i})\cdot R(\vec y))\not= 0\bigg\} $$where $\vec x=<x_1,x_2,x_3,\cdots,x_i,\cdots>$, $\vec c=<c_1,c_2,c_3,\cdots,c_i,\cdots>$.  $\vec{x}$ defines the schema of $\vec{c}$, Specifically, $\vec{x}$ is the vector of names of each element of the tuple $\vec{c}$. \par

For the comparison operator ($v_{1}\theta v_{2}$), where $v_1$ and $v_2$ are variables, we can compute the domain as follows:
\begin{equation*}
\text{\dom{}}_{\vec{x}}(v_{1}\theta v_{2})=\bigg\{\vec{c}\,|\,\forall i:((\pi_{i}(x_{i}\gets c_{i}))(v_{1}\theta v_{2}))\not= 0\bigg\}
\end{equation*}
The domain of a comparison is infinite. 
In fact using implication operator in the above definition allows us to extend the $\vec{x}$ to whatever vector we want. It is not necessary that $\vec{x}$  has the same schema as the given expression. Thus, we can evaluate $\text{\dom}_{\vec{x}}$ for a broader range of $\vec{x}$ and it is not delimited by the schema of the expression. In such cases the \dom{} is infinite as the other variables can take any value.
For the join operator we can write:
\begin{equation*}
\text{\dom{}}_{\vec{x}}(q_{1}\cdot q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation*}
while for the union operator the domain definition is very similar:
\begin{equation*}
\text{\dom{}}_{\vec{x}}(q_{1}+ q_{2})=\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\lor\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{2})\}
\end{equation*}
$$\dom{}_{\vec x}(constant)=\Big\{\vec c\Big\}$$
$$\dom{}_{\vec x}(variable)=\Big\{\vec c\Big\}$$

Finally, we can give a formalism for expressing the domain of a variable that will participate in an assignment operation:
\begin{equation*}
\text{\dom{}}_{\vec{x}}(v\gets q_{1})=\bigg\{\vec{c}\,|\vec{c}\in\text{\dom{}}_{\vec{x}}(q_{1})\land \big(\forall i:(x_{i}=v)\Rightarrow(q_{1}\cdot\prod_{j:x_{j}\neq v } (x_{j}=c_{j})=c_{i})\big)\bigg\}
\end{equation*}
%The \dom{} of a map is defined by all the values of both the input and output variables(which are represented as vectors). 
%\begin{equation*}
%\text{\dom}_{i}=  \big\{x\in map_{i}[\vec{x}][\vec{y}]| (x\in \vec{x})\lor(x\in \vec{y})\big\}
%\end{equation*}
%We need to compute the dependences between the domains of maps.The domains of input variables will always depend on the domains of output variables from maps that are on the left side of the map with input variables. Without loose of generality  we always need to work with two maps when we want to compute their \dom s. For this we define function $F$ recursively as follow:
%\begin{equation*}
%F=\text{\dom}_{i}|F\cap F|F\cup F
%\end{equation*}
%Function $F$ takes two sets(two \dom s) and returns their unions or intersections. We can apply this function recursively to compute any set of unions or intersections between the \dom s. Also we can achieve this by giving a set of sets to $F$ to compute the desirable set.
%So we can compute the dependencies between the \dom s like this:
%\begin{equation*}
%\text{\dom}_{i}(x\in m_{i}[\vec{x}][\vec{y}])\gets F(\text{\dom}_{i}(x'\gets m_{j}[\vec{x'}][\vec{y'}]))
%\end{equation*}
%Where $j$ is all the maps which occurs on the left hand of phrase for computing $m_{i}$ as we have in \ref{fig1} since the information can only be passed from left to right.\\ 
%\par
%We call the arity of a schema as the number of its input variables. 
Having the definitions for the domains, we will try to give some insight regarding to the notion of arity. We will start with an example relation: $$q=R(a,b)\cdot S(b,c)$$ the schema for q will have three variables $(a,b,c)$ The arity of a tuple will be the number of occurrences in the relation, in other words the order of multiplicity of that tuple. The arity of a tuple will increase or decrease if insertions or respectively deletions will be made to a relation. For example:
\begin{table}[ht]
\centering
\begin{tabular}{c c c c}
	R & a & b & arity\\ [0.2ex]
	%heading
	\hline
	  & $<$1 & 2$>$ & 1 \\
	  & $<$1 & 3$>$ & 2 \\
	  & $<$3 & 4$>$ & 1 \\
\end{tabular}
\caption{Relation $R$}
\end{table}
\begin{table}[ht]
\centering
\begin{tabular}{c c c c}
	S & b & c & arity\\ [0.2ex]
	%heading
	\hline
	  & $<$1 & 1$>$ & 1 \\
	  & $<$2 & 2$>$ & 2 \\
	  & $<$3 & 5$>$ & 2 \\
\end{tabular}
\caption{Relation $S$}
\end{table}
\begin{table}[ht]
\centering
\begin{tabular}{c c c c c}
	$R\cdot S$ & a & b & c & arity\\ [0.2ex]
	%heading
	\hline
	  & $<$1 & 2 & 2$>$ & 2 \\
	  & $<$1 & 3 & 5$>$ & 4 \\
	  & $<$3 & 4 & $*>$ & 0 \\
	  & $<*$ & 1 & 1$>$ & 0 \\
\end{tabular}
\caption{Relation $R\cdot S$}
\end{table}

We need to maintain the maps for certain values as long as the arity of a tuple is greater then 0. If the arity  of the tuple drops to 0 then the tuple will not be taken into consideration and therefore it can be eliminated from the domains of the maps.

We need to store the arities inside each map. We need a way to compute the arity of an AGCA expression. Since we substitute the subexpressions with maps, we can easily consider the maps without input variables as some relations. Also a map with input variables can be seen as a relation with a group-by clause. Input variable of a map bind some variables. Thus if we compute the map values by all different combinations of these variables, we will look up into these values and return the appropriate value according to the input variables.  
\section{Computing the arities of the AGCA expression}

We define the function arity which will be used to compute the arity of a tuple in a certain relation. The function will be defined on the relation and the tuple for which the multiplicity order is desired to be computed. $$arity(Relation\text{ q},Tuple\text{ t})=\text{multiplicity order of tuple }t\text{ in the relation } q$$ $$arity(q,t)=\pi_{t}(q)$$ where $\pi_{t}(q)$ means the projection of relation $q$ for the tuple $t$. This function can be used for the computation of the arity of the expressions from the AGCA: $q\text{ ::- }q\cdot q\text{ }|\text{ }q+q\text{ }|\text{ }q \theta t\text{ }|\text{ }t\gets q\text{ }|\text{ }constant\text{ }|\text{ }variable$. However constants and variables can be eliminated from the computation because relations are of interest.

$$arity(q_{1}\cdot q_{2},t)=\sum\limits_{\{t_{1}\}\Join \{t_{2}\}={t}}^{}arity(q_{1},t_{1})*arity(q_{2},t_{2})$$
$$arity(q_{1} + q_{2},t)=arity(q_{1},t)+arity(q_{2},t)\text{, where Schema}(q_{1})=\text{Schema}(q_{2}) $$
$$arity(v_1\text{ } \theta \text{ } v_2,t=<\cdots,v_1,\cdots,v_2,\cdots>)=\begin{cases}0,& \mbox{if } v_1\theta v_2 \mbox{ is false}\\ 1,& \mbox{if } v_1\theta v_2 \mbox{ is true} \end{cases}$$
$$arity(v\gets q,t)=\begin{cases}0, \mbox{ if $\forall \vec{x}: \text{\dom}_{\vec{x}}(q)$ is empty}\\ 1, \mbox{ otherwise} \end{cases}$$

\section{Graph representation of maps}
For computing the domains of input variables of maps we can use graph modeling. In such a way that, given the expression we can compute the domain of each expression with this modeling in $O(m\cdot p)$ where $m$ is the number of occurrences of all input variables and $p$ is the cost of evaluating the domains according to the mentioned rules. \\
\par
In this section firstly we talk about the the graph modeling(dependency graph), then we will give an algorithm for computing this dependency graph from the parse tree of expressions. 
From the parse tree of an expression we can construct a directed graph $G(V,E)$. For each map $m[.][.]$ there is a vertex in $V$ and edges represent the variable. We have an edge between $m_{1}$ and $m_{2}$ with label $a$, if and only if $a$ is in the input variables of $m_{2}$ and output variables of $m_{1}$ and there is an information flow from $m_{1}$ to $m_{2}$. \\
\par
Obviously this graph does not have any cycle. To prove it, suppose it has a cycle with at least two vertices, call the first two vertices as $m_{1},m_{2}$. In the cycle there is an edge between $m_{1}$ and $m_{2}$. Since this is a cycle then there is a path between $m_{2}$ and $m_{1}$ also. But it is not possible because having an edge between $m_{1}$ and $m_{2}$ means that $m_{2}$ occurs after $m_{1}$ and according to information flow rule we can not have a path again between $m_{2}$ and $m_{1}$. \\
\par
In this graph vertices without any incoming edge are always the relations. If we evaluate the nodes with a topological traversal we can guarantee that the input variables of each maps is computed in order. The cost of domain computations is $O(m\cdot p)$, where $m$ is the number of edges in the graph and $p$ is the cost of using any of mentioned rules for computing the domain of subexpressions as we had in the aforementioned way. \\
\par
We can construct the graph from the given parse tree in $O(m)$ where $m$ is the number of edges. We start from the root of the parse tree and recursively compute the subgraph of the left child and right child, then we add the edges between the maps with some input variables on the right child to the appropriate vertices on the left child's graph. Since we consider each edge just one time in the algorithm, the overall order is $O(m)$. 
\section{Domain computation}

We are trying to compute the domains for each variable that appears in a query. This computation will be performed on the query decomposition tree. We can traverse the tree in post order, first visiting the leaves that are represented by some relations and afterwards visiting the parent nodes and combining the relations of the children nodes. Using this technique we are trying to compute the domains, but also the vector $\vec x$ of all the variables defined in that query. 

The algorithm will need as inputs the root of the tree and a structure that must be previously defined and will return a structure that will contain the vector of variables and the domains for each variable defined in the vector. The structure will look like:

\begin{alltt}
struct\{
x: the vector of all the variables 
dom: the domain of all the variables
\}
\end{alltt}

\begin{algorithm}[H]
\caption{Computing the domains} 
\label{alg}
\textbf{Input:} the root of the tree \textbf{node}, a structure \textbf{s} that will be null \\
\textbf{Output:} a structure \textbf{s1} that will contain the vector of variables \textbf{$\vec x$} and the domains of each variable \textbf{$\dom{}_{\vec x}(query)$}
\begin{algorithmic}[1]
\IF{$node$ has children}
\IF{+ is between node.Left and node.Right}
\STATE struct $s1\gets$ computeDomain(node.Left,struct s)
\STATE struct $s2\gets$ computeDomain(node.Right,sturct s)
\STATE struct $s3.\vec{x}\gets s1.\vec{x} \cup s2.\vec{x}$ \COMMENT{this will compute the vector for all the variables, both from the right and left node}
\STATE struct $s3.dom\gets \dom{}_{s3.\vec x}(node.Left + node.Right)$
\STATE return s3
\ELSE
\STATE struct $s1 \gets$ computeDomain(node.Left,struct s)
\STATE struct $s2 \gets$ computeDomain(node.Right,struct s1)
\STATE return $s2$
\ENDIF
\ELSE
\IF{struct s=null}
\STATE $s1.\vec{x} \gets \text{all the variables of the leaf}$
\STATE $s1.dom \gets \dom{}_{s1.\vec{x}}(\text{relation from the leaf})$
\ELSE
\STATE $s1.\vec{x}\gets s.\vec{x} \cup \text{all the variables of the leaf}$
\STATE $s1.dom$ will be the new domain, computing the domain of the leaf relation, but also taking into account the structure $s$
\STATE return $s1$
\ENDIF
\STATE return $s1$
\ENDIF
\end{algorithmic}
\end{algorithm}

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}%[level/.style={sibling distance=40mm,level distance=15mm}]
[level 1/.style={circle, draw,scale=1.0, fill=red,
    level distance=30pt, sibling distance=100pt},
    level 2/.style={circle, draw, scale=1.0,
    level distance=50pt, sibling distance=60pt}]
    \tikzstyle{every node}=[circle,draw,fill=red]
    \node[] (a){}
        child { 
            node [](b){}
            child{node(d){}}
            child{node(e){}} 
        }
        child { 
        		node[] (c){}
		child{node[](f){}}
		child{node(g){}}
	};
	\draw[->] (a) to [bend right=25](b);
	\draw[->] (b) to [bend right=25](a);
	
	\draw[->] (a) to [bend right=25](c);
	\draw[->] (c) to [bend right=25](a);
	
	\draw[->] (b) to [bend right=25](d);
	\draw[->] (d) to [bend right=25](b);
	\draw[->] (b) to [bend right=25](e);
	\draw[->] (e) to [bend right=25](b);
	\draw[->] (c) to [bend right=25](f);
	\draw[->] (f) to [bend right=25](c);
	\draw[->] (c) to [bend right=25](g);
	\draw[->] (g) to [bend right=25](c);
	
\end{tikzpicture}
\end{center}
\caption{Tree traversal}
\label{fig1}
\end{figure}
\end{document}




