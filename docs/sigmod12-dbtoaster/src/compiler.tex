Figure \ref{} illustrates the DBToaster compilation pipeline.  Before describing each stage in detail, we provide a high-level overview of the entire pipeline by means of a simple example:

\begin{example}
\label{ex:compiler:rst}
We have a database with the schema: 
\begin{verbatim}
CREATE TABLE R(a int, b int); 
CREATE TABLE S(b int, c int);
CREATE TABLE T(d int, e int);
\end{verbatim}

We wish to maintain a view over the query:
\begin{verbatim}
q := SELECT SUM(R.a  * T.e)
     FROM R, S, T
     WHERE R.b = S.b AND S.c < T.d;
\end{verbatim}
\end{example}

Prior to compilation, the SQL query is translated verbatim into the compiler's internal query representation.  This representation is closely related to the AGCA language presented in \cite{koch-pods:10}.  For brevity, the internal representation is omitted from this paper, and query expressions in DBToaster's internal representation are presented in the form of an equivalent expression in SQL.  \todo{present Calculus in the appendix?  Is there an appendix?}

\subsection{Building the Materialization Plan}
The first stage in the compilation pipeline is a recursive compilation process that establishes a strategy for incrementally maintaining the query results -- a {\em materialization plan}.  This process is similar to the recursive compilation of \cite{kennedy-ahmad-koch-cidr:11,koch-pods:10}, and is described in detail in Section \ref{}.  The first step in the recursive compilation is the computation of the {\em delta of the query with respect an update to one of its relations}.  The delta expresses how the results of the query change when the delta's relation is updated.  

\begin{example}
For example, consider the delta of {\tt q} with respect to the insertion of tuple $\left< \alpha, \beta\right>$ into relation {\tt R}.  We write this as $\Delta_{{\tt R}(\alpha, \beta)}{\tt q :=}$
\\ \\
\noindent{\tt SELECT SUM(}$\alpha${\tt\ * T.e)\\
FROM\ \ \ S, T\\
WHERE\ \ }$\beta${\tt\ = S.b AND S.c < T.d;}
\\ \\
In this expression, the two parameters $\alpha$ and $\beta$ are assigned values from the tuple being inserted.  Note that the delta expression may be further simplified (using the distributivity of addition and multiplication) to: 
\\ \\
\noindent $\alpha${\tt\ * (SELECT SUM(T.e)\\
\hspace*{8.8mm}FROM\ \ \ S, T\\
\hspace*{8.8mm}WHERE\ \ }$\beta${\tt\ = S.b AND S.c < T.d);
}
\end{example}

At runtime, an update to one of the base relations in the query triggers an update to a datastructure maintaining the query result.  The value of the update is computed by using the appropriate delta query; This process is virtually identical to the behavior of incremental view maintenance techniques\cite{cite?}.  

However, the delta queries are queries in their own right -- the delta operation is closed under the compiler's internal representation.  As a consequence, it is possible to incrementally maintain the delta queries in the same way that the original query is incrementally maintained.  The compiler analyzes the delta query and identifies an incrementally maintainable datastructure that can be used to efficiently answer the query



The compiler analyzes the delta query and identifies one or more strategies for instantiating a 

 datastructures to incrementally maintain, or {\em materialize} it.


 {\em materializing} it: 

Because 



The compiler takes advantage of the delta queries being in the same language by incre


 by incrementally maintaining the delta queries as well as the original query.  The compiler analyzes the delta query and identifies one or more ways of {\em materializing}


The first stage in the compilation pipeline is the construction of a {\em materialization plan}, a representation of the operations and data structures required to maintain the query being compiled.  


 \cite{kennedy-ahmad-koch-cidr:11}, 


The materialization plan is constructed using two fundamental operations: {\bf delta} and {\bf extract}.  Delta identifies the set of query expressions required to incrementally maintain a data structure when one of the base relations changes.  Extract identifies the set of data structures required to evaluate a query expression.  We document these operations more extensively in Section \ref{sec:iprogram:mplan}. 

A materialization plan is constructed by invoking delta to produce a series of maintenance queries, extract to produce a series of data structures required to evaluate those queries, delta to produce maintenance queries for those data structures, and so forth recursively\footnote{As discussed in \cite{dbtoaster-pods}, the delta operation can be constructed in such a way that guarantees termination of this recursive process.}.  

Figure \ref{} shows the materialization plan for Example \ref{ex:compiler:rst}.  As illustrated in this figure, the structure of a materialization plan is a tree which mirrors the recursive invocation of delta and extract -- nodes correspond to data structures identified by extract, while edges correspond to maintenance operations identified by delta.  The materialization plan corresponds fundamentally to the operations that will be evaluated by the binary output by the compiler.  Also note that each data structure corresponds to a query -- data structures are effectively materialized views.  

In some cases, it may be beneficial to evaluate a query using multiple data structures (as in Figure \ref{}.a).  As a consequence, note that each edge is tagged not only with the maintenance query, but also an expression describing how to use the data structure(s) involved.

Furthermore, for some query expressions, there may be several different options for which data structures to use in evaluating the expression (as in Figure \ref{}.b).  To handle such cases, extract can emit (and correspondingly, each edge in the graph can have) several distinct {\em implementation} options for a given query expression.  

After the materialization plan is constructed, a {\em Materialization Optimizer} analyzes the plan and identifies 

\subsection{Building the Incremental Program}
The second stage in the 
