\documentclass{sig-alternate}

\usepackage{subfigure}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{color}
\usepackage{rotating}
\usepackage{hyperref}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\newtheorem{theorem}{Theorem}[section]

\newcommand{\longversion}[1]{}
\newcommand{\comment}[1]{}
\newcommand{\tinysection}[1]{\vspace{0.5mm}\noindent{\bf #1.}}
\newcommand{\tuple}[1]{{\langle#1\rangle}}
\newcommand{\todo}[1]{[\textcolor{red}{#1}]}
\newcommand{\note}[1]{[\textcolor{blue}{#1}]}
\newcommand{\dbtoaster}[0]{[ANONYMIZED]}

\newtheorem{example}{Example}[section]

\toappear{}

\title{Multilevel Incremental View Maintenance}
% and the Confluence of Compilers and Query Optimizers

%\numberofauthors{3}
\numberofauthors{1}
\author{
%\alignauthor
%Yanif Ahmad\\
%    \affaddr{Johns Hopkins University}
%    %\affaddr{Baltimore, MD}
%    \email{yanif@cs.jhu.edu}
%\alignauthor
%Oliver Kennedy\\
%    %\affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    \affaddr{EPFL}
%    %\affaddr{Lausanne, Switzerland}
%    \email{oliver.kennedy@epfl.ch}
%\alignauthor
%Christoph Koch\\
%    \affaddr{EPFL}
%    % \affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    %\affaddr{Lausanne, Switzerland}
%    \email{christoph.koch@epfl.ch}
}


\begin{document}
\maketitle


\begin{abstract}
This paper introduces and studies multilevel incremental view maintenance,
a general-purpose incremental
evaluation framework that allows a query optimizer to extend the use of
materialized views from answering user queries to also answer the delta
queries present under the hood of a DBMS to refresh views on updates. The
aggressive recursive use of this idea can eliminate all joins from certain
queries, resulting in mutation-intensive query processing that refreshes
multiple views without classical query operators. This calls for compilation of
queries to highly efficient low-level imperative code, and a compiler
architecture that bridges the gap between query optimizers and compilers for
general-purpose programming languages.


\comment{
Multilevel incremental view maintenance generalizes the idea of using
materialized views for query answering by allowing a query optimizer to use
materialized views for also answering delta queries, which are the auxiliary
queries that are used in incremental view maintenance to refresh materialized
views when updates happen. Aggressive recursive use of this idea allows to
eliminate all joins from certain queries and to generate highly efficient
low-level code without classical query operators that performs all query
evaluation and view refreshment work. This calls for the compilation of queries.

In this paper, we present a general compiler architecture for languages such as
SQL. To realize such a compiler, we overcome the challenges of materializing
views with binding patterns (parameters) to support arbitrarily nested queries
with aggregates, complex patterns of side effects that may arise, and the need
to perform sophisticated forms of deforestation and fusion frequently employed
in compilers but almost unknown in the database literature.
}

Aggressive multilevel incremental view maintenance bears the potential to be, by
several orders of magnitude, faster than classical incremental view
maintenance and to have substantially greater expressive power compared to the query
languages supported in stream engines.
%
%This may lead to a new breed of data
%management systems that can drive sophisticated streaming, online, and real-time
%analytics that are not supported by current data management systems.
%
We confirm this expectation through extensive experimentation with different
parameterizations of our compiler as well as existing DBMS and stream engines
on an analytics workload consisting of monitoring, algorithmic trading, and ETL
queries. We observe that multilevel incremental view maintenance dominates
previous continuous querying approaches, frequently by multiple orders of
magnitude, for queries involving many joins or nested aggregation. However,
managing domains of parameters in auxiliary views can be costly, which turns out
to be a problem for certain queries with inequalities.
\end{abstract}


\section{Introduction}
\label{sec:introduction}
\input{introduction.tex}

\section{Motivating Applications and\\State-of-the-Art Systems}
\label{sec:sota}
%\input{related.tex}
%\input{dbfail.tex}
\input{tscomparison.tex}

\input{compiler_recursive.tex}
\input{compiler_multilevel.tex}
\input{compiler_backend.tex}

\section{Experimental Results}
\label{sec:experiments}
\input{experiments.tex}

\section{Conclusion}

\footnotesize{
\bibliographystyle{abbrv}%{plain}
\bibliography{sigmod12-dbtoaster,bibtex}
}

\appendix
\section{Queries}
\label{app:queries}
\vspace{-4mm}
\input{queries.tex}

\end{document}

