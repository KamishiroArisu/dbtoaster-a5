\documentclass{sig-alternate}

\usepackage{subfigure}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{color}
\usepackage{rotating}
\usepackage{hyperref}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}


\leftmargini 2.9ex
\renewcommand{\baselinestretch}{0.975}

\newtheorem{theorem}{Theorem}[section]

\newcommand{\longversion}[1]{}
\newcommand{\comment}[1]{}
\newcommand{\tinysection}[1]{\vspace{0.5mm}\noindent{\bf #1.}}
\newcommand{\tuple}[1]{{\langle#1\rangle}}
\newcommand{\todo}[1]{[\textcolor{red}{#1}]}
\newcommand{\note}[1]{[\textcolor{blue}{#1}]}
\newcommand{\dbtoaster}[0]{[ANONYMIZED]}

\newtheorem{example}{Example}[section]

\toappear{}

\title{Multilevel Incremental View Maintenance}
% and the Confluence of Compilers and Query Optimizers

%\numberofauthors{3}
\numberofauthors{1}
\author{
Submission \#74
%\alignauthor
%Yanif Ahmad\\
%    \affaddr{Johns Hopkins University}
%    %\affaddr{Baltimore, MD}
%    \email{yanif@cs.jhu.edu}
%\alignauthor
%Oliver Kennedy\\
%    %\affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    \affaddr{EPFL}
%    %\affaddr{Lausanne, Switzerland}
%    \email{oliver.kennedy@epfl.ch}
%\alignauthor
%Christoph Koch\\
%    \affaddr{EPFL}
%    % \affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    %\affaddr{Lausanne, Switzerland}
%    \email{christoph.koch@epfl.ch}
}


\begin{document}

\maketitle


\begin{abstract}
This paper introduces and studies multilevel incremental view maintenance,
an incremental
evaluation framework that allows a query optimizer to extend the use of
materialized views from answering user queries to also \textit{answering the delta
queries} used by a DBMS to refresh views on updates.
The aggressive recursive use of this idea can eliminate all joins from certain
queries, resulting in query processing with fine-grained in-place updates that
refreshes multiple views without classical query operators. This calls for
compilation of queries to highly efficient low-level imperative code.

Multilevel incremental view maintenance bears the potential to be
faster than classical incremental view maintenance, admitting very high view refresh rates,
and to have greater expressive power than query
languages supported in stream engines.
%
Extensive experimentation with
our compiler as well as existing DBMS and stream engines confirms this.
Multilevel incremental view maintenance usually dominates
previous continuous querying approaches, frequently by multiple orders of
magnitude, for queries involving many joins or nested aggregation. However,
managing domains of parameters in auxiliary views can be costly, which turns out
to be a problem for certain queries with inequalities.
\end{abstract}


\section{Introduction}
\label{sec:introduction}
\input{introduction.tex}

\section{Motivating Applications and\\State-of-the-Art Systems}
\label{sec:sota}
%\input{related.tex}
%\input{dbfail.tex}
\input{tscomparison.tex}

\input{compiler_recursive.tex}
\input{compiler_multilevel.tex}
\input{compiler_backend.tex}

\section{Experimental Results}
\label{sec:experiments}
\input{experiments.tex}


\section{Conclusion}
\label{sec:conclusion}
We presented multilevel IVM, motivated the need to compile its maintenance work based on aggressive simplification of recursive delta queries, and presented the design of a compiler framework that incorporates a plethora of optimization techniques to make recursive IVM viable.

Our compilation technique is effective on select-project-join-aggregate queries involving equi-joins and nested subqueries which are uncorrelated, correlated through an equality comparison, or correlated on a variable (or variables) with a small domain.  It is especially good on queries with small result sets (but large inputs).
%
Our technique is less effective on inequality joins and nested aggregates correlated through an inequality -- although both are still handled efficiently if the domain of the values being compared is small.  In a similar vein, we do not optimize to take advantage of, or avoid problems caused by data-dependent characteristics (e.g., foreign keys, large domains). 

We have presented guidelines for addressing these issues in future work by applying both heuristics and cost-based optimizers to the space of possible materialization plans.  With these optimizations in place, our compilation technique has the potential to dominate existing systems in this space, and to enable a broad new class of monitoring applications.

\footnotesize{
\bibliographystyle{abbrv}%{plain}
\bibliography{sigmod12-dbtoaster,bibtex}
}

\appendix
\vspace{-1mm}
\section{Queries}
\label{app:queries}
\vspace{-4mm}
\input{queries.tex}
\end{document}

