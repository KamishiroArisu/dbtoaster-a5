\documentclass{sig-alternate}

\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{color}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\newcommand{\longversion}[1]{}
\newcommand{\comment}[1]{}
\newcommand{\tinysection}[1]{\vspace{0.5mm}\noindent{\bf #1.}}
\newcommand{\tuple}[1]{{\langle#1\rangle}}
\newcommand{\todo}[1]{[\textcolor{red}{#1}]}
\newcommand{\note}[1]{[\textcolor{blue}{#1}]}
\newcommand{\dbtoaster}[0]{[ANONYMIZED]}

\newtheorem{example}{Example}[section]

\toappear{}

\title{Multilevel Incremental View Maintenance and the Confluence of
Compilers and Query Optimizers}
%\numberofauthors{3}
\numberofauthors{1}
\author{
%\alignauthor
%Yanif Ahmad\\
%    \affaddr{Johns Hopkins University}
%    %\affaddr{Baltimore, MD}
%    \email{yanif@cs.jhu.edu}
%\alignauthor
%Oliver Kennedy\\
%    %\affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    \affaddr{EPFL}
%    %\affaddr{Lausanne, Switzerland}
%    \email{oliver.kennedy@epfl.ch}
%\alignauthor
%Christoph Koch\\
%    \affaddr{EPFL}
%    % \affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    %\affaddr{Lausanne, Switzerland}
%    \email{christoph.koch@epfl.ch}
}


\begin{document}
\maketitle


\begin{abstract}
Multilevel incremental view maintenance generalizes the idea of using materialized views for query answering by allowing a query optimizer to also use materialized views for answering delta queries, that is, the auxiliary queries that are used to refresh materialized views when updates happen. Aggressive recursive use of this idea can allow to eliminate all joins from certain queries, yielding the option of generating highly efficient low-level code without classical query operators that performs all query evaluation and view refreshment work. This calls for the compilation of queries.

In this paper, we present a general compiler architecture for database queries and multi-level incremental view maintenance which is applicable to languages such as SQL. To realize such a compiler, we overcome the challenges of materializing views with binding patterns (parameters) to support arbitrarily nested queries with aggregates, complex patterns of side effects that may arise, and the need to perform sophisticated forms of deforestation and fusion popular and essential in compilers but almost unknown in the database literature.

Aggressive multilevel incremental view maintenance bears the potential to be, by many degrees of magnitude, faster than classical incremental view maintenance and to have substantially greater expressive power compared to the query languages supported in stream engines; this may lead to a new breed of data management systems that can drive sophisticated streaming, online, and real-time analytics that are not supported by current data management systems.
We illustrate this through extensive experimentation with different parameterizations of our compiler as well as existing DBMS and stream engines, on an analytics workload composed of monitoring, algorithmic trading, and ETL queries. 
\end{abstract}


\section{Introduction}
\label{sec:introduction}
\input{introduction.tex}

\section{Motivation and Related Work}
\label{sec:dbfail}
\input{dbfail.tex}

\section{Compiler Overview}
\label{sec:compiler}
\input{compiler.tex}

\section{Incremental Programs}
\label{sec:iprogram}
\input{iprogram.tex}

\section{Functional Optimization}
\label{sec:functional}
\input{functional.tex}

\section{Experimental Results}
\label{sec:experiments}
\input{experiments.tex}

\section{Conclusion}

%\footnotesize{
\bibliographystyle{abbrv}%{plain}
\bibliography{sigmod12-dbtoaster,ref-long}
%}

\end{document}  

