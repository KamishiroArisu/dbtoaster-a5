\documentclass{sig-alternate}

\usepackage{subfigure}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amsmath,amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{color}
\usepackage{rotating}
\usepackage{hyperref}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}


\leftmargini 2.9ex


\newtheorem{theorem}{Theorem}[section]

\newcommand{\longversion}[1]{}
\newcommand{\comment}[1]{}
\newcommand{\tinysection}[1]{\vspace{0.5mm}\noindent{\bf #1.}}
\newcommand{\tuple}[1]{{\langle#1\rangle}}
\newcommand{\todo}[1]{[\textcolor{red}{#1}]}
\newcommand{\note}[1]{[\textcolor{blue}{#1}]}
\newcommand{\dbtoaster}[0]{[ANONYMIZED]}

\newtheorem{example}{Example}[section]

\toappear{}

\title{Multilevel Incremental View Maintenance}
% and the Confluence of Compilers and Query Optimizers

%\numberofauthors{3}
\numberofauthors{1}
\author{
Submission \#74
%\alignauthor
%Yanif Ahmad\\
%    \affaddr{Johns Hopkins University}
%    %\affaddr{Baltimore, MD}
%    \email{yanif@cs.jhu.edu}
%\alignauthor
%Oliver Kennedy\\
%    %\affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    \affaddr{EPFL}
%    %\affaddr{Lausanne, Switzerland}
%    \email{oliver.kennedy@epfl.ch}
%\alignauthor
%Christoph Koch\\
%    \affaddr{EPFL}
%    % \affaddr{\'Ecole Polytechnique F\'ed\'erale de Lausanne} \\
%    %\affaddr{Lausanne, Switzerland}
%    \email{christoph.koch@epfl.ch}
}


\begin{document}
\maketitle


\begin{abstract}
This paper introduces and studies multilevel incremental view maintenance,
a general-purpose incremental
evaluation framework that allows a query optimizer to extend the use of
materialized views from answering user queries to also \textit{answer the delta
queries} used by a DBMS to refresh views on updates.
The aggressive recursive use of this idea can eliminate all joins from certain
queries, resulting in query processing with fine-grained in-place updates that
refreshes multiple views without classical query operators. This calls for
compilation of queries to highly efficient low-level imperative code, and a
compiler architecture that bridges the gap between query optimizers and
compilers for general-purpose programming languages.


\comment{
Multilevel incremental view maintenance generalizes the idea of using
materialized views for query answering by allowing a query optimizer to use
materialized views for also answering delta queries, which are the auxiliary
queries that are used in incremental view maintenance to refresh materialized
views when updates happen. Aggressive recursive use of this idea allows to
eliminate all joins from certain queries and to generate highly efficient
low-level code without classical query operators that performs all query
evaluation and view refreshment work. This calls for the compilation of queries.

In this paper, we present a general compiler architecture for languages such as
SQL. To realize such a compiler, we overcome the challenges of materializing
views with binding patterns (parameters) to support arbitrarily nested queries
with aggregates, complex patterns of side effects that may arise, and the need
to perform sophisticated forms of deforestation and fusion frequently employed
in compilers but almost unknown in the database literature.
}

Multilevel incremental view maintenance bears the potential to be
faster than classical incremental view
maintenance and to have greater expressive power than query
languages supported in stream engines.
%
We confirm this through extensive experimentation with
our compiler as well as existing DBMS and stream engines
on a workload consisting of monitoring, algorithmic trading, and ETL
queries. Multilevel incremental view maintenance dominates
previous continuous querying approaches, frequently by multiple orders of
magnitude, for queries involving many joins or nested aggregation. However,
managing domains of parameters in auxiliary views can be costly, which turns out
to be a problem for certain queries with inequalities.
\end{abstract}


\section{Introduction}
\label{sec:introduction}
\input{introduction.tex}

\section{Motivating Applications and\\State-of-the-Art Systems}
\label{sec:sota}
%\input{related.tex}
%\input{dbfail.tex}
\input{tscomparison.tex}

\input{compiler_recursive.tex}
\input{compiler_multilevel.tex}
\input{compiler_backend.tex}

\section{Experimental Results}
\label{sec:experiments}
\input{experiments.tex}


\section{Conclusion}
\label{sec:conclusion}
Our compilation technique is effective on select-project-join-aggregate queries involving equi-joins and nested subqueries which are uncorrelated, correlated through an equality comparison, or correlated on a variable (or variables) with a small domain.  It is especially good on queries with small result sets (but large inputs).

Our technique is less effective on inequality joins and nested aggregates correlated through an inequality -- although both are still handled efficiently if the domain of the values being compared is small.  In a similar vein, we do not optimize to take advantage of, or avoid problems caused by data-dependent characteristics (e.g., foreign keys, large domains, etc\ldots). 

We have presented guidelines for addressing these issues in future work by applying both heuristics and cost-based optimizers to the space of possible materialization plans.  With these optimizations in place, our compilation technique has the potential to dominate existing systems in this space, and to enable a broad new class of monitoring applications.

\footnotesize{
\bibliographystyle{abbrv}%{plain}
\bibliography{sigmod12-dbtoaster,bibtex}
}

\appendix
\section{Queries}
\label{app:queries}
\vspace{-4mm}
\input{queries.tex}

\end{document}

