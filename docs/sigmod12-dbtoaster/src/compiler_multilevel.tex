\subsection{Materialization Heuristics}
\label{sec:advanced-rewriting}

We have observed experimentally (see Section~\ref{sec:experiments}) that under certain conditions, a less-aggressive maintenance strategy is beneficial.
\comment{The choice of what to materialize applies to both entire delta expressions as well for individual subexpressions.}
In this subsection, we describe challenges that we have encountered while implementing aggressive materialization, and provide heuristics for addressing them.

\tinysection{Nested aggregate queries}
Aggregate subqueries appearing as arguments to comparison operators cannot be recursively materialized by aggressively maintaining the entire delta of the comparison expression -- the delta expression is not strictly simpler than the original expression.  Materializing the nested subquery rather than the delta of the comparison expression eliminates this issue.  We illustrate the idea with a simple example.

\begin{example} \em
%SELECT COUNT(*) FROM R WHERE R.A<(SELECT COUNT(*) FROM S)
%(SELECT 1 FROM R WHERE (R.A>=(SELECT COUNT(*) FROM S) 
%                   AND (R.A< (SELECT COUNT(*) FROM S)+1))
%  - 
%(SELECT 1 FROM R WHERE (R.A< (SELECT COUNT(*) FROM S) 
%                   AND (R.A>=(SELECT COUNT(*) FROM S)+1))
Consider the following query $Q$ over relations $R(A)$ and $S()$, and a nested aggregate query $\Sum(S)$
\vspace*{-0.05in}
{\small $$Q = R \bowtie (A < \Sum(S))$$}
Applying the rules of~\cite{koch-pods:10} yields the delta query with respect to $S$:
{\small \begin{eqnarray*}
\Delta_SQ & =  & (R \bowtie (A \geq \Sum(S)) \bowtie (A < (\Sum(S) +1)))\\
&-& (R \bowtie (A <  \Sum(S)) \bowtie (A \geq (\Sum(S) + 1)))
\end{eqnarray*}}
The aggregate appears in the delta expression, and so $\Delta_SQ$ is not structurally simpler than $Q$ -- maintaining $\Delta_S Q$ requires more work than evaluating the original query.  

Instead, we subdivide this expression into three components: (a) the part of $\Delta_S Q$ independent of the nested aggregate ($R$), (b) the nested aggregate ($\Sum(S)$), and (c) the delta of the nested aggregate ($\Delta_S\Sum(S) \equiv 1$).  Each component is individually simpler, and thus safe to materialize independently.  An iteration over component (a) is required for every insertion into $S$ in order to apply the inequality predicate, but is less expensive than the original query.

This three-way subdivision can be applied to {\it any} nested aggregate delta to create a safe materialization strategy.
\end{example}

\tinysection{Input Variables}
Maintaining a view with input variables can be expensive -- the domain of the variable is generally infinite.  When a value of this variable is encountered for the first time, the view expression must be evaluated as discussed in Section \ref{sec:compiler_calc}.  The materialized view acts as a cache that incrementally maintains cached values rather than invalidating them.

As with caches, there is a tradeoff between the utility of caching values and the cost of doing so.  In the case of materialized views, this is not only the memory cost, but also the cost of maintaining stored values -- each of which is a materialized view in its own right.  The amount of maintenance work required is proportional to both the domain of the input variable (the size of the cache), and the amount of work required to maintain any individual currying of the materialized view.  Instead, terms where the variable appears can be pulled out of the materialization and applied as filters when the expression is evaluated.

\begin{example} \em
The expression $Q = Sum_A(R \bowtie (B~<~D))$ over relation $R(A,B,C)$ can be materialized in two ways\footnote{This simple, illustrative example, can also be materialized as a range tree.}:
{\small \begin{eqnarray*}
M_{full}[D][A] & = & \Sum_A(R \bowtie (B < D)) \\
M_{part}[][A,B] & = & \Sum_{A,B}(R)
\end{eqnarray*}}
\end{example}

Maintaining $M_{part}$ requires only one operation per insertion, while maintaining $M_{full}$ involves one operation per value of $D$ currently being maintained.  

  If $M_{full}$ already contains the cached result for a given $D$, then evaluating $Q(D)$ only requires a lookup.  If not, the expression must be computed in its entirety.  Using $M_{part}$ to evaluate $Q(D)$ requires first applying the predicate $(B < D)$ to all $\left<A,B\right> \in M_{part}$.  Note that in lieu of the base relations, $M_{part}$ can be used to compute initial values for $M_{full}$.

We can compute the relative costs of these two approaches in terms of the following variables:

\vspace*{0.07in}
{\small
\begin{tabular}{rcl}
$rate_X$ & : & The rate of updates or evaluations of $X$\\
$p(\exists X)$ & : & The chance of $X$ already being cached.\\
$dom_R(X)$ & : & The domain of values of $X$ in $R$\\
\end{tabular}
\vspace*{-0.09in}
\begin{eqnarray*}
cost_{full} & = & rate_{Q} \left[p(\exists D) + (1-p(\exists D))\cdot|dom_R(AB)|\right] \\
 &  & + rate_{+R} \left[|dom_Q(D)|\cdot|dom_R(A)| + 1\right]\\
cost_{part} & = & rate_{Q} |dom_R(AB)| + rate_{+R}
\end{eqnarray*}
}
The cost of maintaining $M_{full}$ is based on the cartesian product of the domains of $A$ and $D$, while the cost of maintaining $M_{part}$ is based on only those pairs $\left<A,B\right>$ that actually appear in $R$.  Assuming comparable rates and domain sizes, it is better not to materialize the full view.

\comment{
\tinysection{Storage Considerations}
Full compilation can actually reduce the space consumed by a base relation, as the materialized form of the relation has filters, projections, and aggregates applied as aggressively as possible.  However, additional intermediate materialized views introduce storage overheads.

In situations where storage is limited, it is necessary to limit how many views are materialized.  This is essentially a constrained optimization problem on the expected storage requirements and performance.  A full optimizer is beyond the scope of this paper, but we consider one particular heuristic.

Certain base relations are changed infrequently (e.g., a table of census data).  We refer to such relations as being {\em static}.  When compiling query, views used for computing deltas with respect to {\em static} relations are not materialized -- these deltas are instead computed using traditional IVM techniques.   The same idea can be generalized to append-heavy workloads by using foreign-key constraints.
}
