\subsection{Extraction Heuristics}
\label{sec:advanced-rewriting}

This subsection gives heuristics for choosing which subexpressions of
a query expression to extract and materialize for incremental view maintenance.  These heuristics apply to user-provided queries, as well as delta queries created by the compilation algorithm of Section~\ref{sec:compiler_calc} -- we have observed experimentally (see Section~\ref{sec:experiments}) that under certain conditions, less aggressive incremental maintenance can be beneficial.

\tinysection{Nested aggregate queries}
Aggregate subqueries, in particular those nested inside comparison operators can not be handled directly by the delta operator -- the delta of an expression containing a nested aggregate is not strictly simpler than the original expression, and recursive delta compilation does not bottom out.

\begin{example}
Consider the query:
\begin{verbatim}
SELECT COUNT(*) FROM R WHERE 
  R.A < (SELECT COUNT(*) FROM S)
\end{verbatim}
The delta of this query with respect to S is as follows:
\begin{verbatim}
(SELECT 1 FROM R WHERE 
  (R.A >= (SELECT COUNT(*) FROM S) AND
   R.A <  (SELECT COUNT(*) FROM S) + 1 ) ) + 
(SELECT -1 FROM R WHERE
  (R.A <  (SELECT COUNT(*) FROM S) AND
   R.A >= (SELECT COUNT(*) FROM S) + 1 ) )
\end{verbatim}
\end{example} 

Note the occurrences of the original nested aggregate expression in the delta term.  The delta of the aggregate expression is strictly simpler (+1 in this case), and thus the nested aggregate can itself be maintained efficiently.  By extracting the original aggregate expression from the delta of the outer expression, the delta becomes simpler and can be efficiently maintained incrementally.

\tinysection{Input Variables}
Maintaining a view with input variables can be expensive -- the domain of the variable is generally infinite (e.g., in the case of input variables correlated on an inequality).  When a value of this variable is encountered for the first time, the view expression must be evaluated as discussed in Section \ref{sec:compiler_calc}.  The materialized view acts as a sort of function cache, albeit one that incrementally maintains cached values rather than invalidating them.

As with caches, there is a tradeoff between the utility of storing values and the cost of doing so.  In the case of materialized views, this is not only the memory cost, but also the cost of maintaining stored values -- each of which is a materialized view in its own right.  The amount of maintenance work required is proportional to both the domain of the input variable (the size of the cache), and the amount of work required to maintain any individual currying of the materialized view.  

Instead of materializing a map with input variables, we can separate out terms that the input variable appears in and materialize the remainder of the expression.  The terms with the input variable are then applied as filtering predicates when the expression is evaluated -- note that the cost of doing so is  affected not only by the selectivity of the predicates, but by the reduced ability to aggressively aggregate within the portion of the expression that is materialized.

\begin{example}
The expression $Q = Sum_A(R \bowtie (B~<~D))$ over relation $R(A,B,C)$ can be materialized in two ways\footnote{This simple, illustrative example, can also be materialized as a range tree, as discussed below.}:
$$M_{full}[D][A] = Sum_A(R \bowtie (B < D))$$
$$M_{part}[][A,B] = Sum_{A,B}(R)$$
\end{example}

Maintaining $M_{part}$ requires only one operation per insertion, while maintaining $M_{full}$ involves one operation per value of $D$ currently being maintained.  

Using $M_{part}$ to evaluate $Q(D)$ requires first applying the predicate $(B < D)$ to all $\left<A,B\right> \in M_{part}$.  If $D$ is already in the domain of $M_{full}$, evaluating $Q(D)$ only requires a lookup.  If not, the expression must be computed in its entirety -- in lieu of the base relations, $M_{part}$ can be maintained for this purpose.

We can compute the relative costs of these two approaches in terms of the following variables:

\vspace*{0.07in}
{\small
\begin{tabular}{rcl}
$rate_X$ & : & The rate of updates or evaluations of $X$\\
$p(X \in Q)$ & : & The probability of duplicate values of $X$\\
$dom_R(X)$ & : & The domain of values of $X$ in $R$\\
\end{tabular}
\vspace*{-0.09in}
\begin{eqnarray*}
cost_{full} & = & rate_{Q} \left[(1-p(D \in Q))\cdot|dom_R(AB)|+p(D \in Q)\right] \\
 &  & + rate_{+R} \left[|dom_Q(D)|\cdot|dom_R(A)| + 1\right]\\
cost_{part} & = & rate_{Q} |dom_R(AB)| + rate_{+R}
\end{eqnarray*}
}
The cost of maintaining $M_{full}$ is based on the cartesian product of the domains of $A$ and $D$, while the cost of evaluating the partial expression is based on only those pairs $\left<A,B\right>$ that actually appear in $R$.  Assuming the rates of evaluation and maintenance are comparable, and that the domain sizes of all variables are uniform, it is better not to materialize views with both input and output variables, even if the probability of encountering duplicate values of $D$ is high.

