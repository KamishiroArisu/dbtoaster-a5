require 'util.rb'
$:.push("/usr/lib/ruby/user-gems/1.8/gems/gnuplot-2.3.6/")
require 'lib/gnuplot.rb'

$num_threads = 16;
$queries = {
  "clusteravailable" => {
    :datafile      => "clusteravailable.sql",
    :max_plot_rate => 2000
  },
  "axfinder" => {
    :datafile      => "finance/axfinder.sql",
    :max_plot_rate => 2000
  },
  "brokerspread" => {
    :datafile      => "finance/brokerspread.sql",
    :max_plot_rate => 5000
  },
  "missedtrades" => {
    :datafile      => "finance/missedtrades.sql",
    :max_plot_rate => 100
  },
  "pricespread" => {
    :datafile      => "finance/pricespread.sql",
    :max_plot_rate => 500
  },
  "vwap" => {
    :datafile      => "finance/vwap.sql",
    :max_plot_rate => 6000
  },
  "ssb4" => {
    :datafile      => "tpch/ssb4.sql -d disable-deletes",
    :max_plot_rate => 1,
    :representatives => ["depth_infty", "depth_1"],
    :tuple_mult    => 1000,
    :timescale     => :minutes
  },
  "tpch3" => {
    :datafile      => "tpch/query3.sql",
    :max_plot_rate => 40,
    :representatives => ["depth_infty", "depth_1"],
    :tuple_mult    => 1000
  },
  "tpch11" => { 
    :datafile      => "tpch/query11.sql",
    :max_plot_rate => 70,
    :representatives => ["depth_infty", "depth_1"],
    :tuple_mult    => 1000
  },
  "tpch17" => { 
    :datafile      => "tpch/query17.sql",
    :max_plot_rate => 500
  },
  "tpch18" => { 
    :datafile      => "tpch/query18.sql",
    :max_plot_rate => 100
  },
  "tpch22" => { 
    :datafile      => "tpch/query22.sql",
    :max_plot_rate => 500
  }
};
$configurations = [
  ["Full Compilation", "depth_infty"],
  ["Depth 1 (IVC)",        "depth_1"],
  ["Depth 1 (IVC)", "depth_1_nohash"],
  ["Depth 0",              "depth_0"],
]
$conf_titles = $configurations.map {|t,c| [c,t]}.to_h;

def get_mem(bin,heap_file,map)
#  puts "Getting memory usage for #{map} from #{heap_file}";
  m_fn = "#{map}_value_update"
  `pprof --text #{bin} #{heap_file} --focus=#{m_fn} 2>/dev/null`.
    split(/\n/).
    map { |l| if /Total: (.*)$/ =~ l then $1 else nil end }.
    compact[0].gsub(/ /, "")
end

def get_maps(q)
  File.open("bin/#{q}.maps") { |f| f.readlines }.map { |m| m.chomp }
end

def query_maps(testfile) 
  File.open(testfile){ |f| f.readlines }.
  map { |t| t.chomp.sub(/\t/, "_").split(/\t/) }.
  map do |q, tuples, id, heap_f| 
    get_maps(q).map do |m|
       [  q, tuples, 
          "bin/#{q}", 
          "#{File.dirname testfile}/#{heap_f}",
          m
        ]
    end
  end.flatten(1)
end

def get_mem_threaded(testfile)
  query_maps(testfile).subdivide($num_threads).map do |workload|
    Thread.new do
      Thread.current[:ret] = 
        workload.map do |q, tuples, bin, heap, map|
          mem = get_mem(bin,heap,map);
          raise "Invalid memory value #{mem}" unless 
            /([0-9.]*)([a-zA-Z]+)/ =~ mem;
          mem = $1.to_f * (case $2
            when "MB" then 1024 * 1024
            when "KB" then 1024
            when "B" then 1
            else raise "Unknown memory suffix '#{$2}' in #{mem}"
            end)
          puts "#{q} @ #{tuples} #{map}=#{mem.to_i}B";
          [q,tuples,map,mem];
        end
    end
  end.map { |t| t.join[:ret]; }.flatten(1)
end

def get_filename args
  case args
    when Hash then args.keys[0]
    else           args
  end
end

def intermediate_data title
  File.open(title) do |f|
    f.readlines.map { |l| l.chomp.split(/\t/) }
  end
end

def intermediate args
  title = get_filename args;
  file args do
    data = yield.map { |l| l.join("\t") }.join("\n");
    File.open(intermediate_file(title), "w+") { |f| f.write(data) }
  end
end

def plot(args = {})
  file args do
    filename = get_filename args;
    fmt = case filename
        when /\.pdf$/ then "pdf enhanced size 2.2,1.6"
        when /\.ps$/ then "postscript eps enhanced"
        when /\.tex$/ then "epslatex"
        else raise "Unknown plot format"
      end
    puts "gnuplot > #{filename} (#{fmt})"
    
    Gnuplot.open do |gp|
      Gnuplot::Plot.new(gp) do |plot|
        plot.terminal fmt
        plot.output filename;
        if fmt == "pdf enhanced" then
          (1..5).each { |i| plot.style "line #{i} lt 5" }
        end
        $gp_rake_plot = plot;
        yield plot;
      end
    end
  end
end

def dataset(title, with="lines")
  $gp_rake_plot.data << 
    Gnuplot::DataSet.new(yield.unzip) do |ds|
      ds.title = title
      ds.with = with;
    end
end

def tuples_processed(file)
  data =
    File.open(file) do |f|
      f.readlines.
        grep(/([0-9]+) tuples processed at ([0-9]+)s\+([0-9]+)us/) do |l| 
          [l[1].to_i, l[2].to_i, l[3].to_i] 
        end
    end
  start_s  = data[0][1];
  start_us = data[0][2];
  data.map {|tuples,s,us| [(s - start_s)+(us-start_us)*0.000001, tuples] }
end

def tuple_rate(datafile)
  data = tuples_processed(datafile)
  last_t, last_tuples = *(data.shift); rate = 0;
  data.map do |t, tuples|
    rate = (tuples-last_tuples)/(t - last_t) unless (t - last_t) == 0;
    last_t = t
    last_tuples = tuples;
    [tuples, rate]
  end
end

def draw_clustered_bar_plot plot, args
  data = args.fetch(:data).unzip;
  base_offset       = args.fetch(:base_offset,       0);
  interbar_offset   = args.fetch(:interbar_offset,   10);
  intergroup_offset = args.fetch(:intergroup_offset, interbar_offset);
  margins           = args.fetch(:intergroup_offset, intergroup_offset);
  bar_width         = args.fetch(:bar_width,         30);
  tic_commands      = args.fetch(:tic_commands,      "");
  
  group_offset = base_offset + margins
  group_size = interbar_offset * data.length + intergroup_offset;
  data.zip(args[:dataset_labels]).each do |dataset, dataset_title|
    offset = group_offset - group_size;
    group_offset += interbar_offset;
    
    indices = dataset.map { |i| offset += group_size; }
    
    plot.data << Gnuplot::DataSet.new([indices,dataset]) do |ds|
      ds.title = dataset_title
      ds.with  = "impulses lw #{bar_width}";
    end
  end
  
  label_offset = (group_size+intergroup_offset-margins)/2
  group_offset = base_offset - label_offset;
  plot.xtics "(#{args[:group_labels].map do |label|
    "\"#{label}\" #{group_offset += group_size}";
  end.join(", ")}) #{tic_commands}";
  
  plot.xrange "[0:#{group_offset+label_offset+margins-intergroup_offset}]"
end

plot "graphs/test.pdf" => "rakefile" do |plot|
  plot.yrange "[0:6]"
  draw_clustered_bar_plot plot, 
    :group_labels => ["A", "B", "C"],
    :dataset_labels => ["X", "Y", "Z", "D"],
    :data => [ [1, 2, 3], [2, 3, 4], [3, 4, 5], [5, 6, 7] ];
end

["pdf", "tex", "ps"].each do |fmt|
  plot "graphs/bakeoff.#{fmt}" => "rakefile" do |plot|
    depths = ["0", "1", "infty"];
    
    plot.term "pdf enhanced size 4,2.7" if fmt == "pdf"
    plot.logscale "y"
    plot.key "top center"
    
    labels, data = $queries.keys.sort.map do |q|
      args = $queries[q]
      data = depths.map do |d|
        chosen_conf = "depth_#{d}";
        args.fetch(:representatives, []).
          each { |r| chosen_conf = r if /depth_#{d}/ =~ r; }
        time, tuples =
          tuples_processed("data/time_#{q}_#{chosen_conf}_0")[-1];
        
        if time == 0 then 0 else tuples / time end;
      end
      
      [ q, data.map { |rate| rate / data[1] } ]
    end.unzip
    
    draw_clustered_bar_plot plot, 
      :group_labels => labels,
      :dataset_labels => depths.map { |d| $conf_titles["depth_#{d}"] },
      :data => data,
      :tic_commands => "rotate by -45",
      :bar_width => 15
  end

#  clustered_bar_plot "graphs/bakeoff.#{fmt}" do |plot|
#    ["depth_0", "depth_1", "depth_infty"]
#    $queries.to_a.map do |q,args|
#      [ 
#        args.fetch(:representatives, $conf_titles.keys).map do |conf_code|
#          time, tuples = tuples_processed("data/time_#{q}_#{conf_code}_0")[-1];
#          rate = if time == 0 then 0 else tuples / time;
#          ["#{q} #{$conf_titles[conf_code]}", rate];
#        end
#      ]
#    end
#  end

  $queries.each do |q,args|
    q_graphs = [];
    
    alldata = $configurations.map { |title,code| "data/time_#{q}_#{code}_0" }
    
    tuple_mult, tuple_mult_txt = 
      if args.has_key? :tuple_mult 
        then [args[:tuple_mult], " (x#{args[:tuple_mult]})"] 
        else [1,""] 
      end;
    time_mult, time_scale = 
      case args.fetch(:timescale, :seconds)
        when :seconds then [1, "s"]
        when :minutes then [60, "min"]
        else [1, "s"]
      end
    
    plot "graphs/time_#{q}.#{fmt}" => alldata do |plot|
      plot.xlabel "Time (#{time_scale})"
      plot.ylabel "Tuples Processed#{tuple_mult_txt}"
      cap_time = false;
      args.fetch(:representatives, $configurations.unzip[0]).each do |conf_code|
        datafile = "data/time_#{q}_#{conf_code}_0";
        dataset($conf_titles[conf_code]) do
          tuples_processed(datafile).map do |t,tuples| 
            cap_time = cap_time || t > 3600
            [ t / time_mult,
              tuples / tuple_mult
            ]
          end
        end
      end
      plot.xrange "[0:#{3600/time_mult}]" if cap_time
    end
    q_graphs.push "graphs/time_#{q}.#{fmt}"
  
    $configurations.each do |conf_title, conf_code|
      datafile = "data/time_#{q}_#{conf_code}_0";
      plot "graphs/rate_#{q}_#{conf_code}.#{fmt}" => datafile do |plot|
        plot.xlabel "Tuples Processed"
        plot.ylabel "Rate (tuples/s)"
        dataset(conf_title) { tuple_rate(datafile) }
      end
      q_graphs.push "graphs/rate_#{q}_#{conf_code}.#{fmt}"
    end
    
    plot "graphs/windowedrate_#{q}.#{fmt}" => alldata do |plot|
      plot.xlabel "Tuples Processed#{tuple_mult_txt}"
      rate_mult_txt = "#{tuple_mult} " if tuple_mult != 1;
      plot.ylabel "Rate (#{rate_mult_txt}tuples/s)"
      plot.yrange "[0:#{args[:max_plot_rate]}]" if args.has_key? :max_plot_rate;

      i = 0;
      args.fetch(:representatives, $configurations.unzip[0]).each do |conf_code|
        datafile = "data/time_#{q}_#{conf_code}_0";
        dataset($conf_titles[conf_code]) do 
          tuple_rate(datafile).
            map { |tuples, rate| [tuples / tuple_mult, rate / tuple_mult] }
          #.window(5) do |w| 
  #          tuples, rate = w.unzip
  #          [tuples[-1], rate.avg]
  #        end
        end
      end
    end
    q_graphs.push "graphs/windowedrate_#{q}.#{fmt}"
    
    task "#{q}_all" => q_graphs
    
    task fmt => q_graphs
    
  end
  task :all_graphs => fmt;
end

task :default => :pdf;

file "graphs.tgz" => :all_graphs do
  sh "tar -zcvvf graphs.tgz graphs"
end

loc_configurations = 
  [ ["Infinite Depth", ""],
    ["Depth 1 with Hash Joins", "--depth 1 -f cse -f breduce -f hashds"],
    ["Depth 1 without Hash Joins", "--depth 1"],
    ["Depth 0 with Hash Joins", "--depth 0 -f cse -f breduce -f hashds"],
    ["Depth 0 without Hash Joins", "--depth 0"] ];

file "loc_table.tex" do
  File.open "loc_table.tex", "w+" do |f|
    f.puts("\\begin{tabular}{|l|#{loc_configurations.map { |x| "c|"}}}\\hline");
    f.puts("\\ & #{loc_configurations.unzip[0].join(" & ")} \\\\\\hline");
    $queries.keys.map do |q|
      q_file = $queries[q][:datafile];
      f.puts("#{q} & #{
        loc_configurations.map do |title, args|
          cmd = "../../../dbtoaster/compiler/alpha4/dbtoaster";
          script = "../../../dbtoaster/compiler/alpha4/test/sql/#{q_file}";
          ret = `#{cmd} #{args} #{script} | wc -l`.to_i
          puts "#{q} : #{title} : #{ret}"
          ret
        end.join(" & ")
        } \\\\\\hline"
      );
    end
    f.puts("\\end{tabular}");
  end
end