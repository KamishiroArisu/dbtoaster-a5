The goal of PIP is to evaluate queries on variables sampled from both discrete and continuous distributions as well as to provide tools to aid in the statistical analysis of those results.  Uncertainty in PIP is represented via the pVar datatype.  Every instance of this datatype represents a random variable.  When instantiating a pVar, users specify both a distribution for the variable to be sampled from, and a parameter set for that distribution.  

In addition to representing uncertainty in values for individual cells in a table, PIP represents per-tuple uncertainty with c-tables.  Each tuple is tagged with a condition that must hold for the variable to be present in the table.  C-table conditions are expressed as a boolean equation of \textit{atoms}, arbitrary inequalities of pVars.  The independent probability, or \textit{confidence} of the tuple is the probability of the condition being satisfied.  

\subsection{Random Variables}
  A pVar, or probabilistic variable, represents a nondeterministic value in the database.  Every pVar is created from by specifying a distribution and a set of parameters for that distribution.  For example, we write $[X=>Normal(\mu,\sigma^2)]$ to represent a pVar named X that follows a Normal distribution with a mean of $\mu$ and a standard deviation of $\sigma^2$.  In this way, PIP is agnostic to the distribution which a variable is sampled from; arbitrary problem-specific distributions may be created and seamlessly integrated into PIP's infrastructure.  

When defining a distribution, programmers need only include a mechanism for sampling from that distribution.  However, if it is possible to efficiently compute or estimate the distribution's probability density function ($PDF$), cumulative distribution function ($CDF$), or inverse cumulative distribution function ($CDF^{-1}$), these may be included to increase PIP's efficiency.  The process of defining a variable distribution is described further in Section \ref{sec:implementation}.  

Though PIP abstracts the details of the distribution from its query evaluation, it distinguishes between discrete and continuous distributions.  As described in Section \ref{sec:background}, existing research into c-tables has demonstrated efficient ways of querying variables sampled from discrete distributions.  PIP employs similar techniques when it is possible to do so.

Multiple pVars may be combined into an algebraic formula to create a composite pVar.  Composite pVars may be used to define joint distributions, to build more complex distributions, or may be created as a side effect of query evaluation.  Though composite pVars are interchangeable with regular pVars in general, there are several instances where they receive special treatment.  In particular, it is necessary to ensure that within a given sample all instances of a given pVar assume the same value; the value of a composite pVar is obtained only after its component pVars have been sampled.

Finally, constraint atoms are conditional formulas of pVars.  Such formulas may be equalities if all variables in the fomula are discrete, otherwise they must be an inequality; the probability of a continuous variable adopting an exact value is zero.  Given a constraint atom $C$, its probability $P[C]$ is the probability of selecting variable assignments that satisfy the formula.  Constraint atoms are used to express a tuple's condition.  By adding constraint atom columns to a table, a tuple's presence in the table becomes dependent on the constraint atom being true.  

Multiple atoms may be joined by boolean operators to create a constraint formula.  PIP expresses constraint formulas as DNF equations.  Multiple atoms in a tuple are evaluated conjunctively; the tuple is present if and only if all the atoms are true.  Multiple tuples sharing the same key value or values are used to express disjunctions; the key value is present in the output if any one tuple with that key is present.

\subsection{Variable Definition}
Before evaluating a query on random variables, the variables must first be defined.  This process takes one of two forms.  PIP uses a repair-key operator similar to that used in \cite{KochMayBMS2008} to define discrete distributions.  Conceptually, this operator identifies tuples that share key values and ensures that only one of the two tuples is present in the database at any given moment.  

Mutual exclusion is ensured by adding a constraint atom of the form $Var = Val$, where each key is assigned its own discrete variable, and all tuples sharing a key have distinct values.  Repair-key may be parametrized with an initial probability value for each tuple.  The sum of these probabilities may not exceed one for a given key.  If the sum is less than one, the remainder indicates the probability that none of the tuples are in the table.

Continuous variables may be created inline with the create-variable operation.  This function takes a distribution class and parameters, and outputs a new variable.  For example, the following query outputs a variable delivery time for a given order.

\begin{verbatim}
select orders.order_id, orders.item_id,
       create variable (`Normal', params.mean,
         params.std_dev) AS delivery_time
from   orders, params
where  orders.item_id = params.item_id;
\end{verbatim}

\subsection{Query Evaluation}
Query evaluation proceeds in two phases: Query and Sampling.  During the query phase, PIP evaluates a query rewritten to employ the c-tables relational algebra extensions described in Section \ref{sec:background}.  Selection clauses not involving pVars are handled traditionally, while those involving one or more pVars instead tag the output tuple with an equivalent condition clause.  For example, the query:

\begin{verbatim}
select *
from   input_table
where  fixed_column = 3
 and   4 > variable_column;
\end{verbatim}
%
is rewritten to
%
\begin{verbatim}
select *, constraint(`4 > variable_column')
from   input_table
where  fixed_column = 3;
\end{verbatim}

Queries are also modified to ensure that these newly created constraint columns are not projected away.

All selections that generate composite columns including at least one pVar are replaced by composite pVars; evaluation of these columns is effectively delayed until the sampling phase.  For example, the query:

\begin{verbatim}
select fixed_column + variable_column
from   input_table
\end{verbatim}
%
is rewritten to
%
\begin{verbatim}
select composite(+, fixed_column, variable_column)
from   input_table
\end{verbatim}

The rewritten query is evaluated by a deterministic database engine and produces a \textit{nondeterministic table}; the query's output contains constant values, pVars and condition atoms.   Note that discrete variable assignments are expressed entirely through constraint atoms; discrete variables are stored in the database as constants.  Because of this, the complexity of evaluating queries over discrete values is pushed entirely into the underlying deterministic database engine.  Thus, in the query phase deterministic variables are treated as constants with respect to continuous variables.

It is also important to note that the nondeterministic table is a \textbf{lossless} encoding of the relationship between the variables used in the query and the output table.  There is no bias to be perpetuated in further queries on the output table.  Consequently, the output of one query phase may be saved as a materialized view and used for arbitrary further computation.
