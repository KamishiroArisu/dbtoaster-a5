(**
   A simple (and currently unused) set of tools for obtaining provenance 
   information about a given calculus expression and/or the domains of variables 
   in this expression.
*)

open Types
open Calculus

let bug = Debug.Logger.bug "CALCULUSPROVENANCE"

type lf_t = 
   | RelSource of string
   | InlineSource
   | NoSource
   | AnySource

module ProvenanceBase = struct
   type t = lf_t
   let zero = AnySource
   let one  = NoSource
end

module ProvenanceRing = Ring.Make(ProvenanceBase)

type t = ProvenanceRing.expr_t

let union         : t list -> t = ProvenanceRing.mk_sum
let join          : t list -> t = ProvenanceRing.mk_prod
let rel_source rel: t           = ProvenanceRing.mk_val (RelSource(rel))
let inline_source : t           = ProvenanceRing.mk_val InlineSource
let no_source     : t           = ProvenanceRing.mk_val NoSource
let fold                        = ProvenanceRing.fold

(**
   Compute the full provenance information for the domain of a specified 
   variable in a specified expression
*)
let rec provenance_of_var (expr:expr_t) (var:var_t): t =
   let rcr e = provenance_of_var e var in
   CalcRing.fold union join (fun x->x)
      (function
         | Value(_) | Cmp(_,_,_)                            -> no_source

         | AggSum(gb_vars,subexp) when List.mem var gb_vars -> rcr subexp
         | AggSum(_,_)                                      -> no_source
         
         | Rel(rn,rv) when List.mem var rv                  -> rel_source rn
         | Rel(_,_)                                         -> no_source
         
         | External(e) ->
            bug ~detail:(fun () -> Calculus.string_of_leaf (External(e)))
                "Provenance for a materialized expression"; no_source

         | Lift(lv,_) when lv = var                         -> inline_source
         | Lift(_,subexp)                                   -> rcr subexp)
      expr

(**
   Compute the full provenance information for the value generated by a
   specified expression.
*)
let rec provenance_of_val (expr:expr_t): t =
   let rcr e = provenance_of_val e in
   CalcRing.fold union join (fun x->x)
      (function
         | Value(_) | Cmp(_,_,_) -> inline_source

         | AggSum(_,subexp)      -> rcr subexp
         
         | Rel(rn,_)             -> rel_source rn
         
         | External(e) ->
            bug ~detail:(fun () -> Calculus.string_of_leaf (External(e)))
                "Provenance for a materialized expression"; no_source

         | Lift(lv,_)            -> inline_source)
      expr

(**
   Compute the full provenance information for all output variables, and the
   value generated by a specified expression
*)
let provenance_of_expr (expr:expr_t): ((var_t * t) list * t) = 
   (  List.map (fun x -> (x, provenance_of_var expr x)) 
               (snd (schema_of_expr expr)),
      provenance_of_val expr )


