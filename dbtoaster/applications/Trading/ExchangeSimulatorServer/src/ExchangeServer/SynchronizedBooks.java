package ExchangeServer;


import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

/**
 * SynchronizedBook stores asks and bids books
 * 
 * Manages both books by adding and removing appropriate tuples
 * @author antonmorozov
 *
 */
public class SynchronizedBooks {
	
	//order books for historic data
	SortedBook ask_orders; 
	SortedBook bid_orders;
	
	//order books for current algorithms
	SortedBook live_ask_orders;
	SortedBook live_bid_orders;
	
	HashMap<Integer, Integer> old_ids;
	
	int order_id;
	long currentTime;
	boolean DEBUG;
	
	int numberOfMatchings;
	long numberOfBrought;
	long numberOfSold;
	long totalB;
	long totalS;
	
	FileWriter OUTFile;
	BufferedWriter fileOut;
	
	boolean doSkips; //check if to use drop or skip strategy
	
	/**
	 * sets order_id to the current order_id of a historic data
	 * @param id order_id
	 * @return current order_id
	 */
	public int setOrderId(int id){
		return order_id=id;
	}
	
	/**
	 * Creates order books and initializes parameters 
	 * @param d if true use debugger mode
	 * @param skips if true use skip strategy else use drop
	 */
	public SynchronizedBooks(boolean d, boolean skips){
		
		order_id=0;
		currentTime=0;
		numberOfMatchings=0;
		numberOfBrought=0;
		numberOfSold=0;
		totalB=0;
		totalS=0;
		DEBUG=d;
		doSkips=skips;
		ask_orders=new SortedBook(new ComparatorOrderTuples());
		bid_orders=new SortedBook(new ComparatorOrderTuples());
		live_ask_orders=new SortedBook(new ComparatorOrderTuples());
		live_bid_orders=new SortedBook(new ComparatorOrderTuples());
		
		old_ids=new HashMap<Integer, Integer>();
		
		//used for cleaning current input streams (used on historic stream)
		try {
			OUTFile = new FileWriter("cleanedData.csv");
	        fileOut = new BufferedWriter(OUTFile);
	    } catch (IOException e) {
	    	System.out.println(e);
	    }
		
	}

	/**
	 * Adds a message indicating addition of a sell order
	 * and checks if there is a match in bids order book
	 * @param t ask order
	 * @return messages to be sent to readers (the first message also sent back to writer)
	 */
	public LinkedList<Stream_tuple> add_Ask_order(Order_tuple t){
		
		//for historical data cleaning
		try {
			fileOut.write(t.time+","+t.id+",S,"+t.volume+","+t.price+"\n");
			fileOut.flush();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//if not historical data
		//add id and time
		if (t.id == 0)
		{
			order_id++;
			t.id=order_id;
			t.time=currentTime;
		}
		//if from historical file
		else
		{
			Integer old_id;
			if ((old_id = old_ids.get(new Integer(t.id))) != null)
			{
				t.id=old_id.intValue();
			}
			else
			{
				old_ids.put(new Integer(t.id), ++order_id);
				t.id=order_id;
			}
			
			currentTime=t.time;
		}
		
		
		//TODO: check if order IDs in the datafile actually consistent.
		
		
		//creates outgoing message
		LinkedList<Stream_tuple> messages=new LinkedList<Stream_tuple>();
		
		Stream_tuple msg=new Stream_tuple();
		msg.time=t.time;
		msg.order_id=t.id;
		msg.action="S";
		msg.price=t.price;
		msg.volume=t.volume;
		msg.company_id=t.c_id;
		messages.addLast(msg);
		
		totalS+=t.volume;
		
		//check if there is a match in bids book
		messages=match_ask(t, messages);
				
		return messages;
	}

	public LinkedList<Stream_tuple> add_Bid_order(Order_tuple t){
		
		//for historical file cleaning
		try {
			fileOut.write(t.time+","+t.id+",B,"+t.volume+","+t.price+"\n");
			fileOut.flush();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		//if order is coming from an algorithms
		if (t.id == 0)
		{
			order_id++;
			t.id=order_id;
			t.time=currentTime;
		}
		//order is coming from a historical file
		else
		{
			Integer old_id;
			if ((old_id = old_ids.get(new Integer(t.id))) != null)
			{
				t.id=old_id.intValue();
			}
			else
			{
				old_ids.put(new Integer(t.id), ++order_id);
				t.id=order_id;
			}
			
			currentTime=t.time;
		}
		
		//create an outgoing message
		LinkedList<Stream_tuple> messages=new LinkedList<Stream_tuple>();
		
		Stream_tuple msg=new Stream_tuple();
		msg.time=t.time;
		msg.order_id=t.id;
		msg.action="B";
		msg.price=t.price;
		msg.volume=t.volume;
		msg.company_id=t.c_id;
		messages.addLast(msg);
		
		totalB+=t.volume;
		
		//check for a match in a ask book
		messages=match_bid(t, messages);
				
		return messages;
	}

	/**
	 * Checks if there is an update order coming updates current books.
	 * For exchanges in historical file.
	 * @param tuple
	 * @param delta
	 * @param live
	 * @return
	 */
	public boolean update_order(Stream_tuple tuple, int delta, boolean live){
		//The intention of this function to update in case of the exchange 
		// i.e. if we have an "E"
		Integer id=new Integer(tuple.order_id);
		
		//gets new order ID generated by the server if one exists
		Integer old_id;
		if ((old_id = old_ids.get(id)) != null)
		{
			id=old_id;
			tuple.order_id=id.intValue();
		}
		
		//if this is coming from a historical file
		//and we use a drop policy
		if ( !live || !doSkips){
			if (ask_orders.containsKey(id)){
				Order_tuple t=ask_orders.get(id);
				
				ask_orders.remove(id);
				
				t.volume=t.volume-delta;
				if (t.volume>0){
					ask_orders.put(id, t);
				}
				return true;
				
			}else if (bid_orders.containsKey(id)){
				
				Order_tuple t=bid_orders.get(id);
				
				bid_orders.remove(id);
				
				t.volume=t.volume-delta;
				
				if(t.volume>0){
					bid_orders.put(id, t);
				}
				return true;
			}
		}
		//if using a skip policy
		else
		{
			if (live_ask_orders.containsKey(id)){
				Order_tuple t=live_ask_orders.get(id);
				
				live_ask_orders.remove(id);
				
				t.volume=t.volume-delta;
				if (t.volume>0){
					live_ask_orders.put(id, t);
				}
				return true;
				
			}else if (live_bid_orders.containsKey(id)){
				
				Order_tuple t=live_bid_orders.get(id);
				
				live_bid_orders.remove(id);
				
				t.volume=t.volume-delta;
				
				if(t.volume>0){
					live_bid_orders.put(id, t);
				}
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * removes the order form all books
	 * @param tuple
	 * @return
	 */
	public boolean remove(Stream_tuple tuple){
		
		int returnID=tuple.order_id;
		
		Integer id=new Integer(tuple.order_id);
		
		//gets the order id assigned by this server
		Integer old_id;
		if ((old_id = old_ids.get(id)) != null)
		{
			id=old_id;
			tuple.order_id=id.intValue();
		}
		else
		{
			return false;
		}
		
		boolean returnVal=false;
		
		//removes from all possible order books
		if (ask_orders.containsKey(id)){
			ask_orders.remove(id);
			returnVal=true;
		}else if (bid_orders.containsKey(id)){
			bid_orders.remove(id);
			returnVal= true;
		}
		if (live_ask_orders.containsKey(id)){
			live_ask_orders.remove(id);
			returnVal= true;
		}else if (live_bid_orders.containsKey(id)){
			live_bid_orders.remove(id);
			returnVal= true;
		}	
		
		//if there was a removal add this tuple to cleaned version of the historical file
		if (returnVal)
		{
			try {
				fileOut.write(tuple.time+","+returnID+","+tuple.action+","+tuple.volume+","+tuple.price+"\n");
				fileOut.flush();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return returnVal;
	}
		
	/**
	 * Tries to match a sell order with one available in the bids book
	 * @param t ask tuple
	 * @param message return messages to be send to readers
	 * @return
	 */
	private LinkedList<Stream_tuple> match_ask(Order_tuple t, LinkedList<Stream_tuple> message){
		//got a sell order and we want to match it with the best bid (buy order)
		Stream_tuple msg;
		Stream_tuple msg2;
		
		//check for skip policy and a non-historic order
		boolean doLive=t.live && doSkips;
		
		//if bids is empty (special case)
		if (!doLive && bid_orders.isEmpty()){
			
			ask_orders.put(new Integer(t.id), t);
			
			return message;
			
		}else if (doLive && live_bid_orders.isEmpty()){
		
			live_ask_orders.put(new Integer(t.id), t);
			
			return message;
			
		}
				
		Order_tuple best_bid;
		//get the best bid from appropriate book
		if (doLive)
		{
			best_bid=live_bid_orders.last();
		}
		else
		{
			best_bid=bid_orders.last();
		}
		
		if (DEBUG){
			System.out.println("matching "+t);
			System.out.println("with bid "+best_bid);
		}
		
		//is the price isn't matching
		if (t.price>best_bid.price){
			
			if (doLive)
			{
				live_ask_orders.put(new Integer(t.id), t);
			}
			else
			{
				ask_orders.put(new Integer(t.id), t);
			}
			
			return message;
		
		//else the price does match 
		//Checking if there is enough volume to satisfy the request
		}else if (t.volume<best_bid.volume){
						
			//change in volume
			best_bid.volume=best_bid.volume-t.volume;
			
			numberOfMatchings++;
			numberOfSold+=t.volume;
			numberOfBrought+=(t.volume)*best_bid.price;
			
			//generating a message about change in bid order
			msg=new Stream_tuple();
			msg.time=best_bid.time;
			msg.order_id=best_bid.id;
			msg.action="U";
			msg.price=best_bid.price;
			msg.volume=t.volume;
			msg.company_id=best_bid.c_id;
			
			//generating completion message for a matched ask order
			msg2=new Stream_tuple();
			msg2.time=t.time;
			msg2.order_id=t.id;
			msg2.action="F";
			msg2.price=best_bid.price;
			msg2.volume=t.volume;
			msg2.company_id=t.c_id;

			message.addLast(msg);
			message.addLast(msg2);
			
			if (doLive)
			{
				live_bid_orders.pop_back();
				live_bid_orders.put(new Integer(best_bid.id), best_bid);
			}
			else
			{
				bid_orders.pop_back();
				bid_orders.put(new Integer(best_bid.id), best_bid);
			}
			
			return message;
			
		}else if (t.volume==best_bid.volume){
			//both messages are completed 
			
			numberOfMatchings++;
			
			numberOfSold+=t.volume;
			numberOfBrought+=(t.volume)*best_bid.price;
			
			msg=new Stream_tuple();
			msg.time=best_bid.time;
			msg.order_id=best_bid.id;
			msg.action="F";
			msg.price=best_bid.price;
			msg.volume=t.volume;
			msg.company_id=best_bid.c_id;
			message.addLast(msg);
			
			msg2=new Stream_tuple();
			msg2.time=t.time;
			msg2.order_id=t.id;
			msg2.action="F";
			msg2.price=best_bid.price;
			msg2.volume=t.volume;
			msg2.company_id=t.c_id;
			message.addLast(msg2);
			
			if (doLive)
			{
				live_bid_orders.pop_back();
			}
			else
			{
				bid_orders.pop_back();
			}
			
			return message;
			
		}else {

			//else generate message about completion of bid order and
			//change in ask order
			numberOfMatchings++;
			
			t.volume=t.volume-best_bid.volume;
			
			numberOfSold+=best_bid.volume;
			numberOfBrought+=(best_bid.volume)*best_bid.price;
			
			msg=new Stream_tuple();
			msg.time=t.time;
			msg.order_id=t.id;
			msg.action="U";
			msg.price=best_bid.price;
			msg.volume=best_bid.volume;
			msg.company_id=t.c_id;
			message.addLast(msg);
										
			msg=new Stream_tuple();
			msg.time=best_bid.time;
			msg.order_id=best_bid.id;
			msg.action="F";
			msg.price=best_bid.price;
			msg.volume=best_bid.volume;
			msg.company_id=best_bid.c_id;
			message.addLast(msg);
			
			if (doLive)
			{
				live_bid_orders.pop_back();
			}
			else
			{
				bid_orders.pop_back();
			}
			
			//continue to try matching the remainder of ask order
			return match_ask(t, message);
		}
		
		
//		return message;
	}
	
	/**
	 * similar to match_ask
	 * @param t bid order to match
	 * @param message
	 * @return
	 */
	private LinkedList<Stream_tuple> match_bid(Order_tuple t, LinkedList<Stream_tuple> message){
		//got a new buy request want to check if there is a matching sell request 
		
		Stream_tuple msg;
		Stream_tuple msg2;
		
		boolean doLive=t.live && doSkips;

		//no ask orders
		if (!doLive && ask_orders.isEmpty()){
		
			bid_orders.put(new Integer(t.id), t);
			
			return message;
		}else if (doLive && live_ask_orders.isEmpty()){
			
			live_bid_orders.put(new Integer(t.id), t);
			
			return message;
		}
		
		Order_tuple best_ask;
		//best ask order
		if (doLive)
		{
			best_ask=live_ask_orders.first();
		}
		else
		{
			best_ask=ask_orders.first();
		}
		
		if (DEBUG){
			System.out.println("matching "+t);
			System.out.println("with ask "+best_ask);
		}
		
		
		if (t.price<best_ask.price){
			//no match

			if (doLive)
			{
				live_bid_orders.put(new Integer(t.id), t);
			}
			else
			{
				bid_orders.put(new Integer(t.id), t);
			}
			
		}else if (t.volume<best_ask.volume){
			
			//ask bid is matched completely 
						
			numberOfMatchings++;
			numberOfSold+=t.volume;
			numberOfBrought+=(t.volume)*best_ask.price;
			
			msg=new Stream_tuple();
			msg.time=best_ask.time;
			msg.order_id=best_ask.id;
			msg.action="U";
			msg.price=best_ask.price;
			msg.volume=t.volume;
			msg.company_id=best_ask.c_id;
			message.addLast(msg);
			
			msg2=new Stream_tuple();
			msg2.time=t.time;
			msg2.order_id=t.id;
			msg2.action="F";
			msg2.price=best_ask.price;
			msg2.volume=t.volume;
			msg2.company_id=t.c_id;
			message.addLast(msg2);
			
			best_ask.volume=best_ask.volume-t.volume;
			
			if (doLive)
			{
				live_ask_orders.pop_front();
				live_ask_orders.put(new Integer(best_ask.id), best_ask);
			}
			else
			{
				ask_orders.pop_front();
				ask_orders.put(new Integer(best_ask.id), best_ask);
			}
			
			
		}else if (t.volume==best_ask.volume){
			//both orders are matched
			
			numberOfMatchings++;
			
			numberOfSold+=t.volume;
			numberOfBrought+=(t.volume)*best_ask.price;
			
			msg=new Stream_tuple();
			msg.time=best_ask.time;
			msg.order_id=best_ask.id;
			msg.action="F";
			msg.price=best_ask.price;
			msg.volume=t.volume;
			msg.company_id=best_ask.c_id;
			message.addLast(msg);
			
			msg=new Stream_tuple();
			msg.time=t.time;
			msg.order_id=t.id;
			msg.action="F";
			msg.price=t.price;
			msg.volume=t.volume;
			msg.company_id=t.c_id;
			message.addLast(msg);
			
			if (doLive)
			{
				live_ask_orders.pop_front();
			}
			else
			{
				ask_orders.pop_front();
			}
			
			

		}else{

			//match ask order partially and bid order completely 
			
			numberOfMatchings++;
			
			t.volume=t.volume-best_ask.volume;
			
			numberOfSold+=best_ask.volume;
			numberOfBrought+=(best_ask.volume)*best_ask.price;
			
			msg=new Stream_tuple();
			msg.time=t.time;
			msg.order_id=t.id;
			msg.action="U";
			msg.price=best_ask.price;
			msg.volume=best_ask.volume;
			msg.company_id=t.c_id;
			message.addLast(msg);
										
			msg=new Stream_tuple();
			msg.time=best_ask.time;
			msg.order_id=best_ask.id;
			msg.action="F";
			msg.price=best_ask.price;
			msg.volume=best_ask.volume;
			msg.company_id=best_ask.c_id;
			message.addLast(msg);
			
			if (doLive)
			{
				live_ask_orders.pop_front();
			}
			else
			{
				ask_orders.pop_front();
			}
			
			//continue with matching bid order
			return match_bid(t, message);
						
		}
		return message;
	}
	
	//number of helper statistics collecting functions
	
	/**
	 * total number of matchings
	 */
	int getNumMatchings()
	{
		return numberOfMatchings;
	}
	
	/**
	 * volume of stocks brought
	 * @return
	 */
	long getNumBought()
	{
		return numberOfBrought;
	}
	
	/**
	 * volume of stocks sold
	 * @return
	 */
	long getNumSold()
	{
		return numberOfSold;
	}
	
	/** 
	 * number of asks
	 * @return
	 */
	long getTotalS()
	{
		return totalS;
	}
	
	/**
	 * number of bids
	 * @return
	 */
	long getTotalB()
	{
		return totalB;
	}

}
