/*
CREATE SCHEMA LineitemSchema (
  orderkey       int,
  partkey        int,
  suppkey        int,
  linenumber     int,
  quantity       double,
  extendedprice  double,
  discount       double,
  tax            double,
  returnflag     string, -- text(1)
  linestatus     string, -- text(1)
  shipdate       timestamp, -- date
  commitdate     timestamp, -- date
  receiptdate    timestamp, -- date
  shipinstruct   string, -- text
  shipmode       string, -- text
  comment        string  -- text
);

CREATE SCHEMA PartSchema (
  partkey      int,
  name         string, -- text
  mfgr         string, -- text
  brand        string, -- text
  type         string, -- text
  p_size         int,
  container    string, -- text
  retailprice  double,
  comment      string  -- text
);
*/

CREATE SCHEMA LineitemSchema (
  orderkey       int,
  partkey        int,
  suppkey        int,
  linenumber     int,
  quantity       double,
  extendedprice  double,
  discount       double,
  tax            double,
  returnflag     int, -- text(1)
  linestatus     int, -- text(1)
  shipdate       int, -- date
  commitdate     int, -- date
  receiptdate    int, -- date
  shipinstruct   int, -- text
  shipmode       int, -- text
  comment        int  -- text
);

CREATE SCHEMA PartSchema (
  partkey      int,
  name         int, -- text
  mfgr         int, -- text
  brand        int, -- text
  type         int, -- text
  p_size       int,
  container    int, -- text
  retailprice  double,
  comment      int  -- text
);


/* Main memory TPCH tables */
CREATE MEMORY TABLE Lineitem LineitemSchema PRIMARY KEY (orderkey, linenumber);
CREATE MEMORY TABLE Part     PartSchema     PRIMARY KEY (partkey);

CREATE INDEX LineitemByPart ON Lineitem (partkey);

/* Tuple identification across union of input streams */
CREATE SCHEMA TaggedInputs
  (stream_name string, evt int, l LineitemSchema, p PartSchema);

CREATE STREAM MultiplexedInputs TaggedInputs;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET InputLock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK InputLock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
CREATE OUTPUT STREAM UpdateCounter (i int);
UPDATE Counter FROM (SELECT i FROM UpdateCounter);
SELECT Counter+1 as i FROM InputLocked INTO UpdateCounter;

/*
 * Table change notification streams
 */
CREATE SCHEMA SLineitemSchema (tid int, l  LineitemSchema);
CREATE SCHEMA SPartSchema     (tid int, p  PartSchema);
 
/* Pre-update serialized streams */ 
CREATE STREAM SInsertLineitem SLineitemSchema;
CREATE STREAM SInsertPart     SPartSchema;

CREATE STREAM SDeleteLineitem SLineitemSchema;
CREATE STREAM SDeletePart     SPartSchema;

/* Post-update serialized streams */
CREATE STREAM LineitemInserted SLineitemSchema;
CREATE STREAM PartInserted     SPartSchema;

CREATE STREAM LineitemDeleted  SLineitemSchema;
CREATE STREAM PartDeleted      SPartSchema;

/* Partition into serialized streams after locking */
/* Partition into serialized streams after locking */
SELECT Counter as tid, l  FROM InputLocked
WHERE stream_name = "lineitem" AND evt = 1 INTO SInsertLineitem;

SELECT Counter as tid, p  FROM InputLocked
WHERE stream_name = "part" AND evt = 1 INTO SInsertPart;

SELECT Counter as tid, l  FROM InputLocked
WHERE stream_name = "lineitem" AND evt = 0 INTO SDeleteLineitem;

SELECT Counter as tid, p  FROM InputLocked
WHERE stream_name = "part" AND evt = 0 INTO SDeletePart;


/* Maintain TPCH tables */
INSERT INTO Lineitem SELECT l.* FROM SInsertLineitem
RETURNING SInsertLineitem.* INTO LineitemInserted;

INSERT INTO Part SELECT p.* FROM SInsertPart
RETURNING SInsertPart.* INTO PartInserted;

DELETE FROM Lineitem USING SDeleteLineitem
WHERE SDeleteLineitem.l.orderkey = Lineitem.orderkey
  AND SDeleteLineitem.l.linenumber = Lineitem.linenumber
RETURNING SDeleteLineitem.* INTO LineitemDeleted;

DELETE FROM Part USING SDeletePart
WHERE SDeletePart.p.partkey = Part.partkey
RETURNING SDeletePart.* INTO PartDeleted;


/* Query body */
CREATE STREAM TableChanged AS
SELECT tid FROM  LineitemInserted UNION LineitemDeleted
           UNION PartInserted UNION PartDeleted;

/* Table to stream replays */

CREATE STREAM CountLineitem AS
  SELECT TC.*, count() as numL FROM TableChanged AS TC OUTER JOIN Lineitem;

CREATE STREAM CountPart AS
  SELECT CL.*, count() as numP FROM CountLineitem AS CL OUTER JOIN Part;

CREATE STREAM ValidCounts AS
  SELECT tid, 
         ((if isnull(numL) then 1 else numL)*
          (if isnull(numP) then 1 else numP)) as expected
  FROM CountPart;

CREATE STREAM ReplayLineitem AS
  SELECT S.*, L.partkey as l_partkey, L.quantity, L.extendedprice
  FROM ValidCounts AS S OUTER JOIN Lineitem AS L;

CREATE STREAM ReplayPart AS
  SELECT S.*, P.partkey as p_partkey
  FROM ReplayLineitem AS S OUTER JOIN Part AS P;

/* Subquery */
CREATE STREAM Subquery AS
  SELECT S.*, sum(L2.quantity) as sumQ
  FROM ReplayPart as S OUTER JOIN Lineitem AS L2
  WHERE S.p_partkey = L2.partkey;


/* Keep a counter to determine when we're done scanning from in-memory tables,
 * to unlock and begin processing the next update
 */
DECLARE CBCounter int DEFAULT 0;
CREATE STREAM UpdateCBCounter (i int, tid int, total int);
UPDATE CBCounter FROM (SELECT i FROM UpdateCBCounter);
SELECT CBCounter+1 as i, tid, expected as total
FROM Subquery INTO UpdateCBCounter;

CREATE STREAM ScanDone AS
SELECT tid, total FROM UpdateCBCounter
WHERE total = CBCounter;

/* Reset counter and unlock the next input as soon as we're done scanning.
 * At this point all tuples from the materialized window for this update
 * are active in the stream graph
 */
UPDATE CBCounter FROM (SELECT 0 as i FROM ScanDone);
CREATE OUTPUT STREAM Unlocked (tid int, total int);
UNLOCK InputLock on 0 FROM ScanDone INTO Unlocked;


/* Outer query */
CREATE STREAM FilteredReplay AS
  SELECT tid, extendedprice FROM Subquery AS S
  WHERE l_partkey = p_partkey
  AND   quantity < 0.005 * sumQ;

CREATE STREAM Result AS
  SELECT now() as t, sum(extendedprice) as result
  FROM FilteredReplay[SIZE 1 ADVANCE 1 ON tid] AS S;
