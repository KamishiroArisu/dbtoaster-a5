CREATE SCHEMA LineitemSchema (
  orderkey       int,
  partkey        int,
  suppkey        int,
  linenumber     int,
  quantity       double,
  extendedprice  double,
  discount       double,
  tax            double,
  returnflag     string, -- text(1)
  linestatus     string, -- text(1)
  shipdate       string, -- date
  commitdate     string, -- date
  receiptdate    string, -- date
  shipinstruct   string, -- text
  shipmode       string, -- text
  comment        string  -- text
);

CREATE SCHEMA PartSchema (
  partkey      int,
  name         string, -- text
  mfgr         string, -- text
  brand        string, -- text
  type         string, -- text
  size         int,
  container    string, -- text
  retailprice  double,
  comment      string  -- text
);


/* All possible TPCH input streams. Trim to your query. */

CREATE INPUT STREAM InsertLineitem LineitemSchema;
CREATE INPUT STREAM InsertPart     PartSchema;

CREATE INPUT STREAM DeleteLineitem LineitemSchema;
CREATE INPUT STREAM DeletePart     PartSchema;


/* Main memory TPCH tables */
CREATE MEMORY TABLE Lineitem LineitemSchema PRIMARY KEY (orderkey, linenumber);
CREATE MEMORY TABLE Part     PartSchema     PRIMARY KEY (partkey);


/*
 * Table change notification streams
 */
CREATE SCHEMA SLineitemSchema (tid int, l  LineitemSchema);
CREATE SCHEMA SPartSchema     (tid int, p  PartSchema);
 
/* Pre-update serialized streams */ 
CREATE STREAM SInsertLineitem SLineitemSchema;
CREATE STREAM SInsertPart     SPartSchema;

CREATE STREAM SDeleteLineitem SLineitemSchema;
CREATE STREAM SDeletePart     SPartSchema;

/* Post-update serialized streams */
CREATE STREAM LineitemInserted SLineitemSchema;
CREATE STREAM PartInserted     SPartSchema;

CREATE STREAM LineitemDeleted  SLineitemSchema;
CREATE STREAM PartDeleted      SPartSchema;


/* Tuple identification across union of input streams */
CREATE SCHEMA TaggedInputs (evt int, tag int, l Lineitem, p Part);
CREATE STREAM MultiplexedInputs TaggedInputs AS
      SELECT 0 as evt, 1 as tag, Lineitem as l  FROM InsertLineitem
UNION SELECT 1 as evt, 1 as tag, Lineitem as l  FROM DeleteLineitem
UNION SELECT 0 as evt, 5 as tag, Part as p      FROM InsertPart
UNION SELECT 1 as evt, 5 as tag, Part as p      FROM DeletePart;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET InputLock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK InputLock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
CREATE STREAM UpdateCounter (i int);
UPDATE Counter FROM (SELECT i FROM UpdateCounter);
SELECT Counter+1 as i FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT i as tid, l  FROM InputLocked WHERE evt = 0 AND tag = 1 INTO SInsertLineitem;
SELECT i as tid, p  FROM InputLocked WHERE evt = 0 AND tag = 5 INTO SInsertPart;

SELECT i as tid, l  FROM InputLocked WHERE evt = 1 AND tag = 1 INTO SDeleteLineitem;
SELECT i as tid, p  FROM InputLocked WHERE evt = 1 AND tag = 5 INTO SDeletePart;


/* Maintain TPCH tables */
INSERT INTO Lineitem SELECT l.* FROM SInsertLineitem
RETURNING SInsertLineitem.* INTO LineitemInserted;

INSERT INTO Part SELECT p.* FROM SInsertPart
RETURNING SInsertPart.* INTO PartInserted;

DELETE FROM Lineitem USING SDeleteLineitem
WHERE SDeleteLineitem.l.orderkey = Lineitem.orderkey
  AND SDeleteLineitem.l.brokerId = Lineitem.linenumber
RETURNING SDeleteLineitem.* INTO LineitemDeleted;

DELETE FROM Part USING SDeletePart
WHERE SDeletePart.p.partkey = Part.partkey
RETURNING SDeletePart.* INTO PartDeleted;


/* Query body */
CREATE STREAM TableChanged AS
SELECT tid FROM  LineitemInserted UNION LineitemDeleted
           UNION PartInserted UNION PartDeleted;

/* Replay part */
CREATE STREAM ReplayPart AS
SELECT T.tid, P.partkey FROM TableChanged AS T, Part AS P;

/* Subquery */
CREATE STREAM Subquery1 AS
SELECT P.tid, P.partkey, sum(L2.quantity) as sumQ
FROM ReplayPart as P, Lineitem AS L2
WHERE P.partkey = L2.partkey;

CREATE STREAM ReplayOuter AS
SELECT P.tid, sum(L.extendedprice) as sumep
FROM Subquery1 AS P, Lineitem AS L
WHERE P.partkey = L.partkey
AND   L.quantity < (0.005 * P.sumQ);

CREATE METRONOME OuterClock (t, 5);
CREATE STREAM OuterFlusher AS ReplayOuter UNION OuterClock;

CREATE STREAM ValidOuter AS
SELECT (if isnull(tid) then Counter+1 else tid) as tid,
       (if isnull(sumep) then 0 else sumep) as sumep
FROM OuterFlusher;
 
/* Outer query */
CREATE STREAM LockedResult AS
SELECT now() as t, sum(sumep) as result
FROM OuterFlusher[SIZE 1 ADVANCE 1 ON tid] AS S;

CREATE STREAM Result (t timestamp, result double);
UNLOCK InputLock ON 0 FROM LockedResult INTO Result;
 

/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="lineitem.tbl", Delimiter="|", StartEventPort="true", Schema=Lineitem)
  INTO InsertLineitem, FileEvents;
  
APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="part.tbl", Delimiter="|", StartEventPort="true", Schema=Part)
  INTO InsertPart, FileEvents;

/* TODO: deletions */

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Query17.csv", IfFileDoesntExist="Create new file")
  FROM Result;


/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
