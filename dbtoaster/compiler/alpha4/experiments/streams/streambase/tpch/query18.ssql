CREATE SCHEMA LineitemSchema (
  orderkey       int,
  partkey        int,
  suppkey        int,
  linenumber     int,
  quantity       double,
  extendedprice  double,
  discount       double,
  tax            double,
  returnflag     string, -- text(1)
  linestatus     string, -- text(1)
  shipdate       string, -- date
  commitdate     string, -- date
  receiptdate    string, -- date
  shipinstruct   string, -- text
  shipmode       string, -- text
  comment        string  -- text
);

CREATE SCHEMA OrdersSchema (
  orderkey       int,
  custkey        int,
  orderstatus    string, -- text(1)
  totalprice     double,
  orderdate      string, -- date
  orderpriority  string, -- text
  clerk          string, -- text
  shippriority   int,
  comment        string  -- text
);

CREATE SCHEMA CustomerSchema (
  custkey      int,
  name         string, -- text
  address      string, -- text
  nationkey    int,
  phone        string, -- text
  acctbal      double,
  mktsegment   string, -- text
  comment      string  -- text
);


/* All possible TPCH input streams. Trim to your query. */

CREATE INPUT STREAM InsertLineitem LineitemSchema;
CREATE INPUT STREAM InsertOrders   OrdersSchema;
CREATE INPUT STREAM InsertCustomer CustomerSchema;

CREATE INPUT STREAM DeleteLineitem LineitemSchema;
CREATE INPUT STREAM DeleteOrders   OrdersSchema;
CREATE INPUT STREAM DeleteCustomer CustomerSchema;


/* Main memory TPCH tables */
CREATE MEMORY TABLE Lineitem LineitemSchema PRIMARY KEY (orderkey, linenumber);
CREATE MEMORY TABLE Orders   OrdersSchema   PRIMARY KEY (orderkey);
CREATE MEMORY TABLE Customer CustomerSchema PRIMARY KEY (custkey);


/*
 * Table change notification streams
 */
CREATE SCHEMA SLineitemSchema (tid int, l  LineitemSchema);
CREATE SCHEMA SOrdersSchema   (tid int, o  OrdersSchema);
CREATE SCHEMA SCustomerSchema (tid int, c  CustomerSchema);
 
/* Pre-update serialized streams */ 
CREATE STREAM SInsertLineitem SLineitemSchema;
CREATE STREAM SInsertOrders   SOrdersSchema;
CREATE STREAM SInsertCustomer SCustomerSchema;

CREATE STREAM SDeleteLineitem SLineitemSchema;
CREATE STREAM SDeleteOrders   SOrdersSchema;
CREATE STREAM SDeleteCustomer SCustomerSchema;

/* Post-update serialized streams */
CREATE STREAM LineitemInserted SLineitemSchema;
CREATE STREAM OrdersInserted   SOrdersSchema;
CREATE STREAM CustomerInserted SCustomerSchema;

CREATE STREAM LineitemDeleted  SLineitemSchema;
CREATE STREAM OrdersDeleted    SOrdersSchema;
CREATE STREAM CustomerDeleted  SCustomerSchema;


/* Tuple identification across union of input streams */
CREATE SCHEMA TaggedInputs (evt int, tag int, l Lineitem, o Orders, c Customer);

CREATE STREAM MultiplexedInputs TaggedInputs AS
      SELECT 0 as evt, 1 as tag, Lineitem as l  FROM InsertLineitem
UNION SELECT 1 as evt, 1 as tag, Lineitem as l  FROM DeleteLineitem
UNION SELECT 0 as evt, 2 as tag, Orders as o    FROM InsertOrders
UNION SELECT 1 as evt, 2 as tag, Orders as o    FROM DeleteOrders
UNION SELECT 0 as evt, 3 as tag, Customer as c  FROM InsertCustomer
UNION SELECT 1 as evt, 3 as tag, Customer as c  FROM DeleteCustomer;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET Lock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK Lock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
UPDATE Counter FROM (SELECT i FROM UpdateCounter) AS S
RETURNING S.* => CREATE STREAM CounterUpdated;
SELECT Counter+1 as i, InputLocked.* FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT i as tid, l  FROM InputLocked WHERE evt = 0 AND tag = 1 INTO SInsertLineitem;
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 2 INTO SInsertOrders;
SELECT i as tid, c  FROM InputLocked WHERE evt = 0 AND tag = 3 INTO SInsertCustomer;

SELECT i as tid, l  FROM InputLocked WHERE evt = 1 AND tag = 1 INTO SDeleteLineitem;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 2 INTO SDeleteOrders;
SELECT i as tid, c  FROM InputLocked WHERE evt = 1 AND tag = 3 INTO SDeleteCustomer;


/* Maintain TPCH tables */
INSERT INTO Lineitem SELECT l.* FROM SInsertLineitem
RETURNING SInsertLineitem.* INTO LineitemInserted;

INSERT INTO Orders SELECT o.* FROM SInsertOrders
RETURNING SInsertOrders.* INTO OrdersInserted;

INSERT INTO Customer SELECT c.* FROM SInsertCustomer
RETURNING SInsertCustomer.* INTO CustomerInserted;

DELETE FROM Lineitem USING SDeleteLineitem
WHERE SDeleteLineitem.l.orderkey = Lineitem.orderkey
  AND SDeleteLineitem.l.brokerId = Lineitem.linenumber
RETURNING SDeleteLineitem.* INTO LineitemDeleted;

DELETE FROM Orders USING SDeleteOrders
WHERE SDeleteOrders.o.orderkey = Orders.orderkey
RETURNING SDeleteOrders.* INTO OrdersDeleted;

DELETE FROM Customer USING SDeleteCustomer
WHERE SDeleteCustomer.c.custkey = Customer.custkey
RETURNING SDeleteCustomer.* INTO CustomerDeleted;


/* Query body. */

CREATE STREAM TableChanged AS
SELECT tid FROM  LineitemInserted UNION LineitemDeleted
           UNION OrdersInserted   UNION OrdersDeleted 
           UNION CustomerInserted UNION CustomerDeleted;

CREATE STREAM ReplayL3 AS
SELECT tid, L3.orderkey, sum(L3.quantity) as sumQ
FROM TableChanged, Lineitem AS L3;

CREATE STREAM ReplayL2 AS
SELECT L3.tid, L3.orderkey, count() as cnt
FROM  ReplayL3 AS L3, Lineitem AS L2
WHERE L3.orderkey = L2.orderkey
AND   100 < L3.sumQ;

CREATE STREAM ReplayL1 AS
SELECT L2.tid, L1.orderkey, sum(L1.quantity) as sumQ
FROM ReplayL2 AS L2, Lineitem AS L1
WHERE L2.orderkey = L1.orderkey
AND   1 <= L2.cnt
GROUP BY L1.orderkey;

-- stream L join O join C
CREATE STREAM LjoinO AS
SELECT L1.tid, O.custkey, L1.sumQ*count() as sumQ
FROM ReplayL1 AS L1, Orders as O
WHERE L1.orderkey = O.orderkey
GROUP BY O.custkey;

CREATE STREAM LockedResult AS
SELECT now() as t, custkey, sum(sumQ) as result FROM
(SELECT LO.tid, C.custkey, LO.sumQ*count() as sumQ
 FROM LjoinO AS LO, Customer AS C
 WHERE LO.custkey = C.custkey
 GROUP BY C.custkey)[SIZE 1 ADVANCE 1 ON tid] AS S
GROUP BY custkey;

CREATE STREAM Result (t timestamp, custkey int, result double);
UNLOCK Lock ON 0 FROM LockedResult INTO Result;


/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="lineitem.tbl", Delimiter="|", StartEventPort="true", Schema=Lineitem)
  INTO InsertLineitem, FileEvents;
  
APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="orders.tbl", Delimiter="|", StartEventPort="true", Schema=Orders)
  INTO InsertOrders, FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="customer.tbl", Delimiter="|", StartEventPort="true", Schema=Customer)
  INTO InsertCustomer, FileEvents;


/* TODO: deletions */

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Query18.csv", IfFileDoesntExist="Create new file")
  FROM Result;


/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
