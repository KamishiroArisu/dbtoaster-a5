CREATE SCHEMA LineitemSchema (
  orderkey       int,
  partkey        int,
  suppkey        int,
  linenumber     int,
  quantity       double,
  extendedprice  double,
  discount       double,
  tax            double,
  returnflag     string, -- text(1)
  linestatus     string, -- text(1)
  shipdate       timestamp, -- date
  commitdate     timestamp, -- date
  receiptdate    timestamp, -- date
  shipinstruct   string, -- text
  shipmode       string, -- text
  comment        string  -- text
);

CREATE SCHEMA OrdersSchema (
  orderkey       int,
  custkey        int,
  orderstatus    string, -- text(1)
  totalprice     double,
  orderdate      timestamp, -- date
  orderpriority  string, -- text
  clerk          string, -- text
  shippriority   int,
  comment        string  -- text
);

CREATE SCHEMA CustomerSchema (
  custkey      int,
  name         string, -- text
  address      string, -- text
  nationkey    int,
  phone        string, -- text
  acctbal      double,
  mktsegment   string, -- text
  comment      string  -- text
);


/* Main memory TPCH tables */
CREATE MEMORY TABLE Lineitem LineitemSchema PRIMARY KEY (orderkey, linenumber);
CREATE MEMORY TABLE Orders   OrdersSchema   PRIMARY KEY (orderkey);
CREATE MEMORY TABLE Customer CustomerSchema PRIMARY KEY (custkey);


/* Tuple identification across union of input streams */
CREATE SCHEMA TaggedInputs
  (stream_name string, evt int,
   l LineitemSchema, o OrdersSchema, c CustomerSchema);

CREATE INPUT STREAM MultiplexedInputs TaggedInputs;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET InputLock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK InputLock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
CREATE OUTPUT STREAM UpdateCounter (i int);
UPDATE Counter FROM (SELECT i FROM UpdateCounter);
SELECT Counter+1 as i FROM InputLocked INTO UpdateCounter;


/* Table change notification streams */
CREATE SCHEMA SLineitemSchema (tid int, l  LineitemSchema);
CREATE SCHEMA SOrdersSchema   (tid int, o  OrdersSchema);
CREATE SCHEMA SCustomerSchema (tid int, c  CustomerSchema);
 
/* Pre-update serialized streams */ 
CREATE STREAM SInsertLineitem SLineitemSchema;
CREATE STREAM SInsertOrders   SOrdersSchema;
CREATE STREAM SInsertCustomer SCustomerSchema;

CREATE STREAM SDeleteLineitem SLineitemSchema;
CREATE STREAM SDeleteOrders   SOrdersSchema;
CREATE STREAM SDeleteCustomer SCustomerSchema;

/* Post-update serialized streams */
CREATE STREAM LineitemInserted SLineitemSchema;
CREATE STREAM OrdersInserted   SOrdersSchema;
CREATE STREAM CustomerInserted SCustomerSchema;

CREATE STREAM LineitemDeleted  SLineitemSchema;
CREATE STREAM OrdersDeleted    SOrdersSchema;
CREATE STREAM CustomerDeleted  SCustomerSchema;


/* Partition into serialized streams after locking */
SELECT Counter as tid, l  FROM InputLocked
WHERE stream_name = "Lineitem" AND evt = 1 INTO SInsertLineitem;

SELECT Counter as tid, o  FROM InputLocked
WHERE stream_name = "Orders" AND evt = 1 INTO SInsertOrders;

SELECT Counter as tid, c  FROM InputLocked
WHERE stream_name = "Customer" AND evt = 1 INTO SInsertCustomer;

SELECT Counter as tid, l  FROM InputLocked
WHERE stream_name = "Lineitem" AND evt = 0 INTO SDeleteLineitem;

SELECT Counter as tid, o  FROM InputLocked
WHERE stream_name = "Orders" AND evt = 0 INTO SDeleteOrders;

SELECT Counter as tid, c  FROM InputLocked
WHERE stream_name = "Customer" AND evt = 0 INTO SDeleteCustomer;


/* Maintain TPCH tables */
INSERT INTO Lineitem SELECT l.* FROM SInsertLineitem
RETURNING SInsertLineitem.* INTO LineitemInserted;

INSERT INTO Orders SELECT o.* FROM SInsertOrders
RETURNING SInsertOrders.* INTO OrdersInserted;

INSERT INTO Customer SELECT c.* FROM SInsertCustomer
RETURNING SInsertCustomer.* INTO CustomerInserted;

DELETE FROM Lineitem USING SDeleteLineitem
WHERE SDeleteLineitem.l.orderkey = Lineitem.orderkey
  AND SDeleteLineitem.l.linenumber = Lineitem.linenumber
RETURNING SDeleteLineitem.* INTO LineitemDeleted;

DELETE FROM Orders USING SDeleteOrders
WHERE SDeleteOrders.o.orderkey = Orders.orderkey
RETURNING SDeleteOrders.* INTO OrdersDeleted;

DELETE FROM Customer USING SDeleteCustomer
WHERE SDeleteCustomer.c.custkey = Customer.custkey
RETURNING SDeleteCustomer.* INTO CustomerDeleted;


/* Query body. */
CREATE STREAM TableChanged AS
SELECT tid FROM  LineitemInserted UNION LineitemDeleted
           UNION OrdersInserted   UNION OrdersDeleted
           UNION CustomerInserted UNION CustomerDeleted;


/* Table to stream replays */
CREATE STREAM CountLineitem AS
SELECT TC.*, count() as numL FROM TableChanged AS TC OUTER JOIN Lineitem;

CREATE STREAM CountOrders AS
SELECT CL.*, count() as numO FROM CountLineitem AS CL OUTER JOIN Orders;

CREATE STREAM CountCustomer AS
SELECT CO.*, count() as numC FROM CountOrders AS CO OUTER JOIN Customer;

CREATE STREAM ValidCounts AS
SELECT tid, 
       ((if isnull(numL) then 1 else numL)*
        (if isnull(numO) then 1 else numO)*
        (if isnull(numC) then 1 else numC)) as expected
FROM CountCustomer;

CREATE STREAM ReplayLineitem AS
SELECT S.*, L.orderkey as l_ordkey, L.extendedprice, L.discount, L.shipdate
FROM ValidCounts AS S OUTER JOIN Lineitem AS L;

CREATE STREAM ReplayLO AS
SELECT S.*, O.orderkey as o_ordkey, O.custkey as o_custkey,
            O.orderdate, O.shippriority
FROM ReplayLineitem AS S OUTER JOIN Orders AS O;

CREATE STREAM ReplayLOC AS
SELECT S.*, C.custkey as c_custkey, C.mktsegment
FROM ReplayLO AS S OUTER JOIN Customer AS C;


/* Keep a counter to determine when we're done scanning from in-memory tables,
 * to unlock and begin processing the next update
 */
DECLARE CBCounter int DEFAULT 0;
CREATE STREAM UpdateCBCounter (i int, tid int, total int);
UPDATE CBCounter FROM (SELECT i FROM UpdateCBCounter);
SELECT CBCounter+1 as i, tid, expected as total
FROM ReplayLOC INTO UpdateCBCounter;

CREATE STREAM ScanDone AS
SELECT tid, total FROM UpdateCBCounter
WHERE total = CBCounter;

/* Reset counter and unlock the next input as soon as we're done scanning.
 * At this point all tuples from the materialized window for this update
 * are active in the stream graph
 */
UPDATE CBCounter FROM (SELECT 0 as i FROM ScanDone);
CREATE OUTPUT STREAM Unlocked (tid int, total int);
UNLOCK InputLock on 0 FROM ScanDone INTO Unlocked;


/* Repetitive joins */

CREATE STREAM ValidReplay AS
SELECT * FROM ReplayLOC
WHERE not(isnull(l_ordkey)) AND not(isnull(o_ordkey))
AND   not(isnull(o_custkey)) AND not(isnull(c_custkey));

CREATE STREAM JoinLOC AS
SELECT tid, o_ordkey as orderkey, orderdate, shippriority,
       extendedprice*(1-discount) as etomd
FROM ValidReplay
WHERE l_ordkey  = o_ordkey
AND   o_custkey = c_custkey
AND   mktsegment = "BUILDING"
AND   orderdate < parse_time("1995-03-15", "yyyy-MM-dd")
AND   shipdate > parse_time("1995-03-15", "yyyy-MM-dd");

CREATE OUTPUT STREAM Result
  (orderkey int, orderdate timestamp, shippriority int, etomd double);

SELECT orderkey, orderdate, shippriority, sum(etomd) as etomd
FROM JoinLOC[SIZE 1 ADVANCE 1 ON tid] AS S
GROUP BY orderkey, orderdate, shippriority
INTO Result;
