CREATE SCHEMA PartsuppSchema (
  partkey      int,
  suppkey      int,
  availqty     int,
  supplycost   double,
  comment      string  -- text
);

CREATE SCHEMA SupplierSchema (
  suppkey      int,
  name         string, -- text
  address      string, -- text
  nationkey    int,
  phone        string, -- text
  acctbal      double,
  comment      string  -- text
);


/* All possible TPCH input streams. Trim to your query. */

CREATE INPUT STREAM InsertSupplier SupplierSchema;
CREATE INPUT STREAM InsertPartsupp PartsuppSchema;

CREATE INPUT STREAM DeleteSupplier SupplierSchema;
CREATE INPUT STREAM DeletePartsupp PartsuppSchema;


/* Main memory TPCH tables */
CREATE MEMORY TABLE Supplier SupplierSchema PRIMARY KEY (suppkey);
CREATE MEMORY TABLE Partsupp PartsuppSchema PRIMARY KEY (partkey, suppkey);


/*
 * Table change notification streams
 */
CREATE SCHEMA SSupplierSchema (tid int, s  SupplierSchema);
CREATE SCHEMA SPartsuppSchema (tid int, ps PartsuppSchema);
 
/* Pre-update serialized streams */ 
CREATE STREAM SInsertSupplier SSupplierSchema;
CREATE STREAM SInsertPartsupp SPartsuppSchema;

CREATE STREAM SDeleteSupplier SSupplierSchema;
CREATE STREAM SDeletePartsupp SPartsuppSchema;

/* Post-update serialized streams */
CREATE STREAM SupplierInserted SSupplierSchema;
CREATE STREAM PartsuppInserted SPartsuppSchema;

CREATE STREAM SupplierDeleted  SSupplierSchema;
CREATE STREAM PartsuppDeleted  SPartsuppSchema;


/* Tuple identification across union of input streams */
CREATE SCHEMA TaggedInputs (evt int, tag int, s Supplier, ps Partsupp);

CREATE STREAM MultiplexedInputs TaggedInputs AS
      SELECT 0 as evt, 4 as tag, Supplier as s  FROM InsertSupplier
UNION SELECT 1 as evt, 4 as tag, Supplier as s  FROM DeleteSupplier
UNION SELECT 0 as evt, 6 as tag, Partsupp as ps FROM InsertPartsupp
UNION SELECT 1 as evt, 6 as tag, Partsupp as ps FROM DeletePartsupp;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET InputLock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK InputLock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
CREATE STREAM UpdateCounter (i int);
UPDATE Counter FROM (SELECT i FROM UpdateCounter);
SELECT Counter+1 as i FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT i as tid, s  FROM InputLocked WHERE evt = 0 AND tag = 4 INTO SInsertSupplier;
SELECT i as tid, ps FROM InputLocked WHERE evt = 0 AND tag = 6 INTO SInsertPartsupp;

SELECT i as tid, s  FROM InputLocked WHERE evt = 1 AND tag = 4 INTO SDeleteSupplier;
SELECT i as tid, ps FROM InputLocked WHERE evt = 1 AND tag = 6 INTO SDeletePartsupp;


/* Maintain TPCH tables */
INSERT INTO Supplier SELECT s.* FROM SInsertSupplier
RETURNING SInsertSupplier.* INTO SupplierInserted;

INSERT INTO Partsupp SELECT ps.* FROM SInsertPartsupp
RETURNING SInsertPartsupp.* INTO PartsuppInserted;

DELETE FROM Supplier USING SDeleteSupplier
WHERE SDeleteSupplier.s.suppkey = Supplier.suppkey
RETURNING SDeleteSupplier.* INTO SupplierDeleted;

DELETE FROM Partsupp USING SDeletePartsupp
WHERE SDeletePartsupp.ps.partkey = Partsupp.partkey
  AND SDeletePartsupp.ps.suppkey = Partsupp.suppkey
RETURNING SDeletePartsupp.* INTO PartsuppDeleted;



/* Query body. */

CREATE STREAM TableChanged AS
SELECT tid FROM  SupplierInserted UNION SupplierDeleted
           UNION PartsuppInserted UNION PartsuppDeleted;

CREATE STREAM ReplayS AS
SELECT tid, S.suppkey, count() as cnt FROM TableChanged, Supplier AS S;

CREATE STREAM ReplaySPS AS
SELECT S.tid, S.cnt*sum(PS.supplycost*PS.availqty) as sumSA
FROM ReplayS AS S, Partsupp AS PS
WHERE S.suppkey = PS.suppkey;
   
CREATE METRONOME SPSClock (t, 5);
CREATE STREAM SPSFlusher AS ReplaySPS UNION SPSClock;

CREATE STREAM ValidSPS AS
SELECT (if isnull(tid) then Counter+1 else tid) as tid,
       (if isnull(sumSA) then 0 else sumSA) as sumSA
FROM SPSFlusher;

CREATE STREAM ReplayHaving AS
SELECT tid, sum(sumSA) as sumSA
FROM SPSFlusher[SIZE 1 ADVANCE 1 ON tid] AS S
GROUP BY tid;

CREATE STREAM ReplayOuterS AS
SELECT R.tid, R.sumSA, S.suppkey, count() as cnt
FROM ReplayHaving as R, Supplier S
GROUP BY S.suppkey;

CREATE STREAM ReplayJoin AS
SELECT S.tid, S.sumSA, PS.partkey,
       cnt*sum(PS.supplycost*ps.availqty) as sumSA2
FROM ReplayOuterS S, Partsupp PS
WHERE S.suppkey = PS.suppkey
GROUP BY PS.partkey;

/* TODO: check interaction with SPSClock */
CREATE METRONOME JoinClock (t, 5);

/* Note: 0 value of sumSA, which is used for a having clause below. */
CREATE STREAM ReplayGroups AS
SELECT Counter+1 as tid, 0 as sumSA, PS.partkey, 0 as sumSA2
FROM JoinClock, Partsupp PS
GROUP BY PS.partkey;

CREATE STREAM JoinFlusher AS ReplayJoin UNION ReplayGroups;

CREATE STREAM LockedResult AS
SELECT now() as t, partkey, sumSA2 as result FROM
  (SELECT partkey, sumSA, sum(sumSA2) as sumSA2 FROM
    JoinFlusher[SIZE 1 ADVANCE 1 on TID] AS S
  GROUP BY partkey, sumSA)
WHERE sumSA2 > sumSA; 

CREATE STREAM Result (t timestamp, partkey int, result double);
UNLOCK InputLock on 0 FROM LockedResult INTO Result; 


/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="supplier.tbl", Delimiter="|", StartEventPort="true", Schema=Supplier)
  INTO InsertSupplier, FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="partsupp.tbl", Delimiter="|", StartEventPort="true", Schema=Partsupp)
  INTO InsertPartsupp, FileEvents;

/* TODO: deletions */

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Query11.csv", IfFileDoesntExist="Create new file")
  FROM Result;


/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
