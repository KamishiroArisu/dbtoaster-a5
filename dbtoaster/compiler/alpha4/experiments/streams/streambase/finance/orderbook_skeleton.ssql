CREATE SCHEMA OrderbookEntry
(timestamp double, orderId int, brokerId int, volume double, price double);

/* Order book input streams. Trim to your needs */ 
CREATE INPUT STREAM InsertBids OrderbookEntry;
CREATE INPUT STREAM DeleteBids OrderbookEntry;
CREATE INPUT STREAM InsertAsks OrderbookEntry;
CREATE INPUT STREAM DeleteAsks OrderbookEntry;

/* Main memory order book tables */
CREATE MEMORY TABLE Bids OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);
CREATE MEMORY TABLE Asks OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);

/*
 * Table change notification streams
 */
CREATE SCHEMA SOrderbookEntry (tid int, o OrderbookEntry);

/* Pre-update serialized streams */
CREATE STREAM SInsertBids SOrderbookEntry;
CREATE STREAM SDeleteBids SOrderbookEntry;
CREATE STREAM SInsertAsks SOrderbookEntry;
CREATE STREAM SDeleteAsks SOrderbookEntry;

/* Post-update serialized streams */
CREATE STREAM BidsInserted SOrderbookEntry;
CREATE STREAM BidsDeleted  SOrderbookEntry;
CREATE STREAM AsksInserted SOrderbookEntry;
CREATE STREAM AsksDeleted  SOrderbookEntry;


/* Tuple identification across union of input streams 
 * Currently this uses an unordered union operation. Alternatively one could
 * use a merge on the order book entry's timestamp field.
 */
CREATE SCHEMA TaggedInputs (evt int, tag int, o OrderbookEntry);
CREATE STREAM MultiplexedInputs TaggedInputs AS
      SELECT 0 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM InsertBids
UNION SELECT 1 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteBids
UNION SELECT 0 AS evt, 2 AS tag, OrderbookEntry(* AS *) AS o FROM InsertAsks
UNION SELECT 1 AS evt, 2 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteAsks;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET Lock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK Lock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
UPDATE Counter FROM (SELECT i FROM UpdateCounter) AS S
RETURNING S.* => CREATE STREAM CounterUpdated;
SELECT Counter+1 as i, InputLocked.* FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 1 INTO SInsertBids;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 1 INTO SDeleteBids;
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 2 INTO SInsertAsks;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 2 INTO SDeleteAsks;


/* Maintain Bids and Asks */
INSERT INTO Bids SELECT o.* FROM SInsertBids
RETURNING SInsertBids.* INTO BidsInserted;

DELETE FROM Bids USING SDeleteBids
WHERE SDeleteBids.o.timestamp = Bids.timestamp
  AND SDeleteBids.o.orderId = Bids.orderId
  AND SDeleteBids.o.brokerId = Bids.brokerId
RETURNING DeleteBids.* INTO BidsDeleted;

INSERT INTO Asks SELECT o.* FROM SInsertAsks
RETURNING SInsertAsks.* INTO AsksInserted;

DELETE FROM Asks USING SDeleteAsks
WHERE SDeleteAsks.o.timestamp = Asks.timestamp
  AND SDeleteAsks.o.orderId = Asks.orderId
  AND SDeleteAsks.o.brokerId = Asks.brokerId
RETURNING SDeleteAsks.* INTO AsksDeleted;


/* Query body goes here.
 * TODO: body must unlock the stream.
 */
/* Track changes to Bids */
CREATE STREAM BidsChanged AS BidsInserted UNION BidsDeleted;
CREATE STREAM AsksChanged AS AsksInserted UNION AsksDeleted;


CREATE STREAM Result AS BidsResult UNION AsksResult;  


/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertBids.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertBids, FileEvents;
  
APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertAsks.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertAsks, FileEvents;

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Vwap.dbtdat", IfFileDoesntExist="Create new file")
  FROM Result;

/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
