CREATE SCHEMA OrderbookEntry
(timestamp double, orderId int, brokerId int, volume double, price double);

/* Order book input streams. Trim to your needs */ 
CREATE INPUT STREAM InsertBids OrderbookEntry;
CREATE INPUT STREAM DeleteBids OrderbookEntry;
CREATE INPUT STREAM InsertAsks OrderbookEntry;
CREATE INPUT STREAM DeleteAsks OrderbookEntry;

/* Main memory order book tables */
CREATE MEMORY TABLE Bids OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);
CREATE MEMORY TABLE Asks OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);

/*
 * Table change notification streams
 */
CREATE SCHEMA SOrderbookEntry (tid int, o OrderbookEntry);

/* Pre-update serialized streams */
CREATE STREAM SInsertBids SOrderbookEntry;
CREATE STREAM SDeleteBids SOrderbookEntry;
CREATE STREAM SInsertAsks SOrderbookEntry;
CREATE STREAM SDeleteAsks SOrderbookEntry;

/* Post-update serialized streams */
CREATE STREAM BidsInserted SOrderbookEntry;
CREATE STREAM BidsDeleted  SOrderbookEntry;
CREATE STREAM AsksInserted SOrderbookEntry;
CREATE STREAM AsksDeleted  SOrderbookEntry;


/* Tuple identification across union of input streams 
 * Currently this uses an unordered union operation. Alternatively one could
 * use a merge on the order book entry's timestamp field.
 */
CREATE SCHEMA TaggedInputs (evt int, tag int, o OrderbookEntry);
CREATE STREAM MultiplexedInputs TaggedInputs AS
      SELECT 0 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM InsertBids
UNION SELECT 1 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteBids
UNION SELECT 0 AS evt, 2 AS tag, OrderbookEntry(* AS *) AS o FROM InsertAsks
UNION SELECT 1 AS evt, 2 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteAsks;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET Lock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK Lock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
UPDATE Counter FROM (SELECT i FROM UpdateCounter) AS S
RETURNING S.* => CREATE STREAM CounterUpdated;
SELECT Counter+1 as i, InputLocked.* FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 1 INTO SInsertBids;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 1 INTO SDeleteBids;
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 2 INTO SInsertAsks;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 2 INTO SDeleteAsks;


/* Maintain Bids and Asks */
INSERT INTO Bids SELECT o.* FROM SInsertBids
RETURNING SInsertBids.* INTO BidsInserted;

DELETE FROM Bids USING SDeleteBids
WHERE SDeleteBids.o.timestamp = Bids.timestamp
  AND SDeleteBids.o.orderId = Bids.orderId
  AND SDeleteBids.o.brokerId = Bids.brokerId
RETURNING DeleteBids.* INTO BidsDeleted;

INSERT INTO Asks SELECT o.* FROM SInsertAsks
RETURNING SInsertAsks.* INTO AsksInserted;

DELETE FROM Asks USING SDeleteAsks
WHERE SDeleteAsks.o.timestamp = Asks.timestamp
  AND SDeleteAsks.o.orderId = Asks.orderId
  AND SDeleteAsks.o.brokerId = Asks.brokerId
RETURNING SDeleteAsks.* INTO AsksDeleted;


/* Track changes to Bids */
CREATE STREAM TableChanged AS
SELECT tid FROM  BidsInserted UNION BidsDeleted;
           UNION AsksInserted UNION AsksDeleted;

/* Recompute on changes to Bids */
CREATE STREAM TotalBids AS
SELECT B.tid, sum(Bids.volume) as sumBV FROM TableChanged AS B, Bids;

CREATE STREAM TotalBA AS 
SELECT T.*, sum(Asks.volume) as sumAV FROM TotalBids AS T, Asks;

CREATE STREAM ReplayBids AS
SELECT T.*, B.brokerId, B.price, B.volume FROM TotalBA AS T, Bids AS B;

CREATE STREAM FilteredBids AS
SELECT tid, brokerId as bbid, bpv, sumAV
FROM
 (SELECT B.tid, B.brokerId, B.price*B.volume AS bpv,
         B.sumBV, B.sumAV, sum(B2.volume) as sumBV2
  FROM ReplayBids AS B, Bids AS B2
  WHERE B2.price > B.price) AS S
WHERE sumBV > sumBV2;

CREATE STREAM ReplayBA AS
SELECT B.*, A.price, A.volume FROM FilteredBids AS B, Asks AS A;

CREATE STREAM BidsResult AS
SELECT bbid as brokerId, sum(diff) as mt
FROM
(SELECT tid, bbid, apv-bpv AS diff FROM
   (SELECT A.tid, A.bbid, A.bpv, A.price*A.volume as apv,
           A.sumAV, sum(A2.volume) as sumAV2
    FROM ReplayBA as A, Asks A2
    WHERE A2.price > A.price) AS S
 WHERE sumAV > sumAV2)[SIZE 1 ADVANCE 1 ON tid] as S2
GROUP BY bbid;



/* Unlock and output */
CREATE STREAM LockedResult AS
SELECT now() as t, * FROM BidsResult UNION AsksResult;  

CREATE STREAM Result (t timestamp, brokerId int, mt double);
UNLOCK Lock 0 FROM LockedResult INTO Result;


/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertBids.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertBids, FileEvents;
  
APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertAsks.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertAsks, FileEvents;

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Missedtrades.csv", IfFileDoesntExist="Create new file")
  FROM Result;

/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
