/* Repetitive VWAP query implementation.
 *
 * @author Yanif Ahmad
 */

CREATE SCHEMA OrderbookEntry
(timestamp double, orderId int, brokerId int, volume double, price double);

/* Order book input streams. Trim to your needs */ 
CREATE STREAM InsertBids OrderbookEntry;
CREATE STREAM DeleteBids OrderbookEntry;

/* Main memory order book tables */
CREATE MEMORY TABLE Bids OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);
CREATE INDEX BidsByPrice ON Bids(price);

/*
 * Table change notification streams
 */
CREATE SCHEMA SOrderbookEntry (tid int, o OrderbookEntry);

/* Pre-update serialized streams */
CREATE STREAM SInsertBids SOrderbookEntry;
CREATE STREAM SDeleteBids SOrderbookEntry;

/* Post-update serialized streams */
CREATE STREAM BidsInserted SOrderbookEntry;
CREATE STREAM BidsDeleted  SOrderbookEntry;


/* Tuple identification across union of input streams 
 * Currently this uses an unordered union operation. Alternatively one could
 * use a merge on the order book entry's timestamp field.
 */
CREATE SCHEMA TaggedInputs (evt int, tag int, o OrderbookEntry);
CREATE STREAM MultiplexedInputs AS
      SELECT 0 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM InsertBids
UNION SELECT 1 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteBids;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET InputLock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK InputLock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
CREATE STREAM UpdateCounter (i int);
UPDATE Counter FROM (SELECT i FROM UpdateCounter);
SELECT Counter+1 as i FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT Counter as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 1 INTO SInsertBids;
SELECT Counter as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 1 INTO SDeleteBids;


/* Maintain Bids table */
INSERT INTO Bids SELECT o.* FROM SInsertBids
RETURNING SInsertBids.* INTO BidsInserted;

DELETE FROM Bids USING SDeleteBids
WHERE SDeleteBids.o.timestamp = Bids.timestamp
  AND SDeleteBids.o.orderId = Bids.orderId
  AND SDeleteBids.o.brokerId = Bids.brokerId
RETURNING SDeleteBids.* INTO BidsDeleted;


/* Track changes to Bids */
CREATE STREAM BidsChanged AS SELECT tid FROM BidsInserted UNION BidsDeleted;

/* Compute the total Bids volume */
CREATE STREAM BidsVolume AS
SELECT B.tid, sum(Bids.volume) as sumBV FROM BidsChanged as B, Bids;

/* For a given total, turn the Bids relation into a stream,
   i.e. perform a scan over Bids. This is the outer loop of a
   correlated subquery.
*/
CREATE STREAM CurrentBids AS
SELECT BV.*, Bids.* FROM BidsVolume as BV, Bids;

/* Perform the correlated subquery, via a nested loops join with
   the above CurrentBids stream, and the Bids table.
   Each tuple in CurrentBids has been decorated with the total volume,
   and compares this to an aggregate applied over the Bids table.
   Subsequently we use a windowed aggregate to compute the VWAP
   over the outer Bids relation's tuples which we turned into a stream.
   The use of a monotonically increasing counter per query invocation
   ensures that the windowed aggregate is performed over only those
   tuples corresponding to a single modification to Bids.
 */
 
CREATE STREAM BidsSubquery AS
SELECT tid, pv
FROM (SELECT b1.tid, b1.sumBV, b1.price*b1.volume as pv,
             sum(b2.volume) as sumBV2
      FROM CurrentBids AS b1, Bids AS b2
      WHERE b2.price > b1.price) AS S
WHERE (0.25*sumBV) > sumBV2;

/* Is a 5 second clock sufficient? It must be strictly greater than the time
 * required to process the above subquery for any input, otherwise it will
 * cause premature aggregation
 */
CREATE METRONOME BidsClock (t,5);
CREATE STREAM BidsFlusher AS BidsSubquery UNION BidsClock;

CREATE STREAM BidsValid AS
SELECT (if isnull(tid) then Counter+1 else tid) as tid,
       (if isnull(pv) then 0 else pv) as pv
FROM BidsFlusher;

/* Perform a final aggregation over the outer stream, having run the subquery */
CREATE STREAM BidsResult AS
SELECT now() as t, sum(pv) as vwap
FROM BidsValid[SIZE 1 ADVANCE 1 ON tid] AS S2;

/* Unlock and output */
CREATE STREAM Result (t timestamp, vwap double);
UNLOCK InputLock ON 0 FROM BidsResult INTO Result;


/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertBids.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertBids, FileEvents;

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Vwap.csv", IfFileDoesntExist="Create new file")
  FROM Result;

/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
