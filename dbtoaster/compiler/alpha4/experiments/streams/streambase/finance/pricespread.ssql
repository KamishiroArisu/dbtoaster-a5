CREATE SCHEMA OrderbookEntry
(timestamp double, orderId int, brokerId int, volume double, price double);

/* Order book input streams. Trim to your needs */ 
CREATE INPUT STREAM InsertBids OrderbookEntry;
CREATE INPUT STREAM DeleteBids OrderbookEntry;
CREATE INPUT STREAM InsertAsks OrderbookEntry;
CREATE INPUT STREAM DeleteAsks OrderbookEntry;

/* Main memory order book tables */
CREATE MEMORY TABLE Bids OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);
CREATE MEMORY TABLE Asks OrderbookEntry PRIMARY KEY (timestamp, orderId, brokerId);

/*
 * Table change notification streams
 */
CREATE SCHEMA SOrderbookEntry (tid int, o OrderbookEntry);

/* Pre-update serialized streams */
CREATE STREAM SInsertBids SOrderbookEntry;
CREATE STREAM SDeleteBids SOrderbookEntry;
CREATE STREAM SInsertAsks SOrderbookEntry;
CREATE STREAM SDeleteAsks SOrderbookEntry;

/* Post-update serialized streams */
CREATE STREAM BidsInserted SOrderbookEntry;
CREATE STREAM BidsDeleted  SOrderbookEntry;
CREATE STREAM AsksInserted SOrderbookEntry;
CREATE STREAM AsksDeleted  SOrderbookEntry;


/* Tuple identification across union of input streams 
 * Currently this uses an unordered union operation. Alternatively one could
 * use a merge on the order book entry's timestamp field.
 */
CREATE SCHEMA TaggedInputs (evt int, tag int, o OrderbookEntry);
CREATE STREAM MultiplexedInputs TaggedInputs AS
      SELECT 0 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM InsertBids
UNION SELECT 1 AS evt, 1 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteBids
UNION SELECT 0 AS evt, 2 AS tag, OrderbookEntry(* AS *) AS o FROM InsertAsks
UNION SELECT 1 AS evt, 2 AS tag, OrderbookEntry(* AS *) AS o FROM DeleteAsks;

/* Lockset for serial execution across updates and queries. */
CREATE LOCKSET Lock (i int);
CREATE STREAM InputLocked TaggedInputs;
LOCK Lock ON 0 FROM MultiplexedInputs INTO InputLocked; 

/* Counter for barriering */
DECLARE Counter int DEFAULT 0;
UPDATE Counter FROM (SELECT i FROM UpdateCounter) AS S
RETURNING S.* => CREATE STREAM CounterUpdated;
SELECT Counter+1 as i, InputLocked.* FROM InputLocked INTO UpdateCounter;


/* Partition into serialized streams after locking */
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 1 INTO SInsertBids;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 1 INTO SDeleteBids;
SELECT i as tid, o  FROM InputLocked WHERE evt = 0 AND tag = 2 INTO SInsertAsks;
SELECT i as tid, o  FROM InputLocked WHERE evt = 1 AND tag = 2 INTO SDeleteAsks;


/* Maintain Bids and Asks */
INSERT INTO Bids SELECT o.* FROM SInsertBids
RETURNING SInsertBids.* INTO BidsInserted;

DELETE FROM Bids USING SDeleteBids
WHERE SDeleteBids.o.timestamp = Bids.timestamp
  AND SDeleteBids.o.orderId = Bids.orderId
  AND SDeleteBids.o.brokerId = Bids.brokerId
RETURNING DeleteBids.* INTO BidsDeleted;

INSERT INTO Asks SELECT o.* FROM SInsertAsks
RETURNING SInsertAsks.* INTO AsksInserted;

DELETE FROM Asks USING SDeleteAsks
WHERE SDeleteAsks.o.timestamp = Asks.timestamp
  AND SDeleteAsks.o.orderId = Asks.orderId
  AND SDeleteAsks.o.brokerId = Asks.brokerId
RETURNING SDeleteAsks.* INTO AsksDeleted;


/* Track changes to Bids */
CREATE STREAM TableChanged AS
SELECT tid FROM  BidsInserted UNION BidsDeleted;
           UNION AsksInserted UNION AsksDeleted;

/* Bids replay and join */
CREATE STREAM TotalBids AS
SELECT B.tid, sum(Bids.volume) as sumBV FROM TableChanged AS B, Bids;

CREATE STREAM TotalBA AS
SELECT T.*, sum(Asks.volume) as sumAV FROM TotalBids AS T, Asks;

CREATE STREAM ReplayBids AS
SELECT T.*, B.price, B.volume from TotalBA AS T, Bids AS B; 

CREATE STREAM BidsResult AS
SELECT sum(diff) AS ps FROM
 (SELECT B.tid, sum(A.price-B.price) AS diff
  FROM ReplayBids AS B, Asks AS A
  WHERE ( B.volume > 0.0001 * B.sumBV )
  AND   ( A.volume > 0.0001 * B.sumAV ))[SIZE 1 ADVANCE 1 ON tid] AS S;


/* Unlock and output */
CREATE STREAM LockedResult AS
SELECT now() as t, ps FROM BidsResult UNION AsksResult;  

CREATE STREAM Result (t timestamp, ps double);
UNLOCK Lock ON 0 FROM LockedResult INTO Result;

/* Load data. */
CREATE STREAM FileEvents;

APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertBids.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertBids, FileEvents;
  
APPLY JAVA "com.streambase.sb.adapter.csvreader.CSVReader"
  (FileName="InsertAsks.dbtdat", Delimiter=",", StartEventPort="true",
   Schema=(timestamp double, orderId int, brokerId int, volume double, price double))
  INTO InsertAsks, FileEvents;

/* Log outputs */
APPLY JAVA "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="Pricespread.csv", IfFileDoesntExist="Create new file")
  FROM Result;

/* Track data file open and close for timing */
CREATE OUTPUT STREAM TimedFileEvents AS
SELECT now() as t, * FROM FileEvents;

/* Log data file events */
APPLY JAVA  "com.streambase.sb.adapter.csvwriter.CSVWriter"
  (FileName="FileEvents.csv", IfFileDoesntExist="Create new file")
  FROM TimedFileEvents;
  
