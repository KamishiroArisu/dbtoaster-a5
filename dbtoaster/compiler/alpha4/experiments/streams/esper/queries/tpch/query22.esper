create window Orders.win:keepall()   /* as InsertOrders */
as (
    orderkey         int,
    custkey          int,
    orderstatus      int,
    totalprice       double,
    orderdate        int,
    orderpriority    int,
    clerk            int,
    shippriority     int,
    comment          int
);

create window Customer.win:keepall() /* as InsertCustomer */
as (
    custkey          int,
    name             int,
    address          int,
    nationkey        int,
    phone            int,
    acctbal          double,
    mktsegment       int,
    comment          int
);

insert into InsertOrders 
  select
    orderkey, custkey, orderstatus, totalprice, orderdate, orderpriority,
    clerk, shippriority, comment
  from Dispatch
  where streamname = "ORDERS" and event = 1;

insert into InsertCustomer 
  select
    custkey, name, address, nationkey, phone, acctbal, mktsegment, comment
  from Dispatch
  where streamname = "CUSTOMER" and event = 1;

insert into Orders   select * from InsertOrders;
insert into Customer select * from InsertCustomer;

on Orders   insert into TableChanged select 1;
on Customer insert into TableChanged select 1;

create variable int current_update = 0;
on TableChanged set current_update = current_update+1;

insert into Subquery1
  select current_update as tid, sum(c2.acctbal) as sumab
  from TableChanged as t unidirectional, Customer as c2
  where c2.acctbal > 0;

insert into ReplayCustomer
  select s.tid as tid, c1.custkey as ck, c1.nationkey as nk, c1.acctbal as cab
  from Subquery1 as s unidirectional, Customer as c1
  where c1.acctbal < s.sumab;

/* We need a left outer join here to ensure that the stream produces an
   output when no matches occur, that we then detect with a count of 0 on
   orders.custkey.
 */
insert into FilteredCustomer
  select c1.tid as tid, c1.nk as nk, c1.cab as cab
  from ReplayCustomer as c1 unidirectional left outer join Orders as o
  on c1.ck = o.custkey
  group by c1.tid, c1.nk, c1.cab
  having count(o.custkey) = 0;

create window AggOuter.win:keepall()
  as (tid int, nk long, sumab double, sz long);
  
insert into AggOuter
  select tid, nk, sum(cab) as sumab, count(*) as sz 
  from FilteredCustomer.win:ext_timed(tid, 1 msec)
  group by nk;

/* We have a new invocation, produce results for any prior invocations before
   deleting their partials.
 */ 
on AggOuter(sz=1) as e
  select current_timestamp() as t, w.tid as tid, w.nk as nk, max(w.sumab) as sumab
  from AggOuter as w
  where w.tid < e.tid
  group by w.tid, w.nk;

/* We are starting a new invocation, delete results for prior ones.
   This ensures that only the current invocation is active in AggOuter.
 */
on AggOuter(sz=1) as e delete from AggOuter as w where w.tid < e.tid;

/* We have a new partial result for the current invocation,
   delete prior partials for the current invocation. This ensures the query
   produces a single aggregate result for a window.
 */
on AggOuter(sz>1) as e
  delete from AggOuter as w
  where w.tid = e.tid and w.sz < e.sz;

/* Progress stream */
insert into ProgressCounter
  select current_timestamp() as t, current_update as tid
  from TableChanged where (current_update % 20) = 0;
