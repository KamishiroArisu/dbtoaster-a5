
This is the DBToaster query compiler.

There are two usage modes:
i) compiling to query processing engines, i.e. binaries

ii) interactive compilation to various output formats, or 
intermediate stages (i.e. map algebra, bytecode, spread messages,
ck's strange/random/beautiful output format), in a toplevel.

Software requirements:
    boost-1.4.0

Build:

To build the dbtoaster compiler, run:
   #> make dbtoaster

To build the dbtoaster interactive toplevel run:
   #> make top

Also available:
   #> make clean

DBToaster compiler:
-------------------

The DBToaster compiler parses, and compiles queries to C++ code and
invokes g++ on the resulting source code to produce a binary query
processing engine. To support this, queries must include source
specifications for any tables declared. The query engine produced is
a simple single threaded engine, running on a multiplexed stream of
all input sources, that periodically reports simple memory usage and
execution time statistics.

See examples/vwap.sql and examples/ssb.sql for file source declaration
and usage. Note the C++ source code for these sources and adaptors can
be found in include/datasets/ .

Available compilation options:

#> ./dbtoaster --help
dbtoaster <options> <SQL files>
Recognized options:

  -s {sql} input file type
  -o output file prefix
  -d data sources configuration
  -m {code|query|test} compilation mode
  -r recursive compilation level
  -cI C++ include flags
  -cL C++ linker flags
  -cl C++ linker libraries
  -with-boost Boost directory
  -allocator {stl|boost} stl::map allocator
  -simple-profiler {on|off} enable simple profiling
  -progress-counter progress reporting frequency for simple profiling
  -help  Display this list of options
  --help  Display this list of options

Example usage:
#> ./dbtoaster -o vwap -progress-counter 500 -cI include/ \
        -with-boost /Users/yanif/software/boost vwap.sql

Note: to compile to C++ code, run dbtoaster with '-m code', e.g.:

#> ./dbtoaster -m code -o vwap -progress-counter 500 -cI include/ \
        -with-boost /Users/yanif/software/boost vwap.sql


DBToaster toplevel:
-------------------

The DBToaster toplevel is useful for compiling queries to a variety
of output formats, for developing, testing and debugging purposes.

Example usage:
#> ./dbtoaster.top
        Objective Caml version 3.10.2

# open DBToasterTop;;
# parse_sql_to_term "create table r(a int, b int); create table s(b int, c int); select sum(a*c) from r,s where r.b=s.b;";;
- : Algebra.readable_term_t list =
[Algebra.RVal
  (Algebra.AggSum
    (Algebra.RProd
      [Algebra.RVal (Algebra.Var ("A", Algebra.TInt));
       Algebra.RVal (Algebra.Var ("C", Algebra.TInt))],
     Algebra.RA_MultiNatJoin
      [Algebra.RA_MultiNatJoin
        [Algebra.RA_Leaf
          (Algebra.Rel ("R", [("A", Algebra.TInt); ("R__B", Algebra.TInt)]));
         Algebra.RA_Leaf
          (Algebra.Rel ("S", [("S__B", Algebra.TInt); ("C", Algebra.TInt)]))];
       Algebra.RA_Leaf
        (Algebra.AtomicConstraint (Algebra.Eq,
          Algebra.RVal (Algebra.Var ("R__B", Algebra.TInt)),
          Algebra.RVal (Algebra.Var ("S__B", Algebra.TInt))))]))]
# 
#
# compile_sql_to_spread "create table r(a int, b int); create table s(b int, c int); create table t(c int, d int); select sum(a*d) from r,s,t where r.b=s.b and s.c=t.c;";;
R	A;R__B	Map q[]		(A*Map qR1[R__B])
S	S__B;S__C	Map q[]		(Map qS1[S__B]*Map qS2[S__C])
T	T__C;D	Map q[]		(Map qT1[T__C]*D)
S	S__B;S__C	Map qR1[S__B]		Map qS2[S__C]
T	T__C;D	Map qR1[x_qR_R__B]		(D*Map qR1T1[x_qR_R__B,T__C])
S	S__B;S__C	Map qR1T1[S__B,S__C]		1
R	A;R__B	Map qS1[R__B]		A
T	T__C;D	Map qS2[T__C]		D
R	A;R__B	Map qT1[x_qT_T__C]		(A*Map qR1T1[R__B,x_qT_T__C])
S	S__B;S__C	Map qT1[S__C]		Map qS1[S__B]
R	A;R__B	Map q[]		(-1*A*Map qR1[R__B])
S	S__B;S__C	Map q[]		(-1*Map qS1[S__B]*Map qS2[S__C])
T	T__C;D	Map q[]		(-1*Map qT1[T__C]*D)
S	S__B;S__C	Map qR1[S__B]		(-1*Map qS2[S__C])
T	T__C;D	Map qR1[x_qR_R__B]		(-1*D*Map qR1T1[x_qR_R__B,T__C])
S	S__B;S__C	Map qR1T1[S__B,S__C]		-1
R	A;R__B	Map qS1[R__B]		(-1*A)
T	T__C;D	Map qS2[T__C]		(-1*D)
R	A;R__B	Map qT1[x_qT_T__C]		(-1*A*Map qR1T1[R__B,x_qT_T__C])
S	S__B;S__C	Map qT1[S__C]		(-1*Map qS1[S__B])
- : unit = ()
# 
#
# compile_sql_to_messages "create table r(a int, b int); create table s(b int, c int); create table t(c int, d int); select sum(a*d) from r,s,t where r.b=s.b and s.c=t.c;";;
+R(x_qR_A, x_qR_R__B): q[] += (x_qR_A*qR1[x_qR_R__B])
+S(x_qS_S__B, x_qS_S__C): q[] += (qS1[x_qS_S__B]*qS2[x_qS_S__C])
+T(x_qT_T__C, x_qT_D): q[] += (qT1[x_qT_T__C]*x_qT_D)
+S(x_qR1S_S__B, x_qR1S_S__C): qR1[x_qR1S_S__B] += qS2[x_qR1S_S__C]
+T(x_qR1T_T__C, x_qR1T_D): foreach x_qR_R__B do qR1[x_qR_R__B] += (x_qR1T_D*qR1T1[x_qR_R__B, x_qR1T_T__C])
+S(x_qR1T1S_S__B, x_qR1T1S_S__C): qR1T1[x_qR1T1S_S__B, x_qR1T1S_S__C] += 1
+R(x_qS1R_A, x_qS1R_R__B): qS1[x_qS1R_R__B] += x_qS1R_A
+T(x_qS2T_T__C, x_qS2T_D): qS2[x_qS2T_T__C] += x_qS2T_D
+R(x_qT1R_A, x_qT1R_R__B): foreach x_qT_T__C do qT1[x_qT_T__C] += (x_qT1R_A*qR1T1[x_qT1R_R__B, x_qT_T__C])
+S(x_qT1S_S__B, x_qT1S_S__C): qT1[x_qT1S_S__C] += qS1[x_qT1S_S__B]
-R(x_qR_A, x_qR_R__B): q[] += (-1*x_qR_A*qR1[x_qR_R__B])
-S(x_qS_S__B, x_qS_S__C): q[] += (-1*qS1[x_qS_S__B]*qS2[x_qS_S__C])
-T(x_qT_T__C, x_qT_D): q[] += (-1*qT1[x_qT_T__C]*x_qT_D)
-S(x_qR1S_S__B, x_qR1S_S__C): qR1[x_qR1S_S__B] += (-1*qS2[x_qR1S_S__C])
-T(x_qR1T_T__C, x_qR1T_D): foreach x_qR_R__B do qR1[x_qR_R__B] += (-1*x_qR1T_D*qR1T1[x_qR_R__B, x_qR1T_T__C])
-S(x_qR1T1S_S__B, x_qR1T1S_S__C): qR1T1[x_qR1T1S_S__B, x_qR1T1S_S__C] += -1
-R(x_qS1R_A, x_qS1R_R__B): qS1[x_qS1R_R__B] += (-1*x_qS1R_A)
-T(x_qS2T_T__C, x_qS2T_D): qS2[x_qS2T_T__C] += (-1*x_qS2T_D)
-R(x_qT1R_A, x_qT1R_R__B): foreach x_qT_T__C do qT1[x_qT_T__C] += (-1*x_qT1R_A*qR1T1[x_qT1R_R__B, x_qT_T__C])
-S(x_qT1S_S__B, x_qT1S_S__C): qT1[x_qT1S_S__C] += (-1*qS1[x_qT1S_S__B])
- : unit = ()
# 
#
# compile_sql_to_bytecode "create table r(a int, b int); create table s(b int, c int); create table t(c int, d int); select sum(a*d) from r,s,t where r.b=s.b and s.c=t.c;";;

...

Note the bytecode representation produces a lot of output, and is often shortened in
the ocaml toplevel with ellipses. To view the full output, change the depth and length
of toplevel output:

# #print_depth 10000;;
# #print_length 10000;;

# compile_sql_to_bytecode "create table r(a int, b int); create table s(b int, c int); create table t(c int, d int); select sum(a*d) from r,s,t where r.b=s.b and s.c=t.c;";;




TODOs:

* Unit tests for Bytecode, and Codegen modules.

* Java, LLVM code generation.

* Integrate Thrift Viewer, Engine and debugger from alpha2.

* Clean up network sources.

* Subclass pool allocator to enable precise measurement, rather
  than model-based estimation of map sizes.

* The code still has to be cleaned up and better documented.

* The code does not generate partition hints yet.


Recent changes:

* Ability to set recursive compilation level, e.g. 1 corresponds to
  standard view maintenance, while DBToaster recurs as far as possible.

* Toplevel, with support for outputting spread messages.

* Added support for delete handlers, including computing negative
  deltas for constraints and semirings

* Support for automatic flattening of nested constraints during compilation.

* Detection and elimination of duplicate map construction during
  recursive compilation.

* Implemented core compiler components, including:
  -- SQL parser
  -- internal bytecode format, representing a simple accumulator language
  -- fully recursive map algebra -> bytecode translation
  -- query code generation, with simpler code generation interfaces
  -- integrated simple runtime code generation from alpha2
  -- simplified compiler driver interface, the thrift driver can be
     easily integrated in the future

* Simple generation of instrumentation code, including estimating map
  space usage, and profiling per-tuple and per-handler overhead.


---

* Inequality constraints and self-joins now work.

* RelAlg and MapAlg have been merged into Algebra. MapAlg expressions are
  now called terms. AtomicConstraints are over terms, so relalg_t and
  term_t are mutually recursive.

* Types now supported.

