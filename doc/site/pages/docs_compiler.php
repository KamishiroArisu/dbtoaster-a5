
<div class="codeblock">$&gt; dbtoaster [options] &lt;input file 1&gt; [&lt;input file 2&gt; [...]]
</div>

<a name="options"></a>
<?= chapter("Command Line Options") ?>
<dl>
<dt class="code">-c &lt;target file&gt;</dt>
<dd>Compile the query into a standalone binary.  By default, the C++ code generator will be used with g++ to generate the binary.  An alternate compiled target language (C++ or Scala) may be selected using the <span class="code">-l</span> flag.</dd>

<dt class="code">-l &lt;language&gt;</dt>
<dd>Compile the query into the specified target language (see below).  The default language is C++.  The use of this flag overrides any previous <span class="code">-l</span> or <span class="code">-r</span>.</dd>

<dt class="code">-o &lt;output file&gt;</dt>
<dd>Redirect the compiler's output to the specified file.  If used in conjunction with <span class="code">-c</span>, the source code for the compiled binary will be directed to this file.  By default, output is directed to stdout or discarded if <span class="code">-c</span> is used.</dd>

<dt class="code">-r</dt>
<dd>Run the query (queries) after code generation and compilation. If no target language is specified using the <span class="code">-l</span> flag, the C++ code generator will be used.</dd>

<dt class="code">-F &lt;optimization&gt;</dt>
<dd>Activate the specified optimization flag.  These are documented below.</dd>

<dt class="code">-O[123]</dt>
<dd>Set the optimization level to 1, 2, or 3 respectively.  At optimization level 1, compilation is faster and generated code is (usually) easier to understand and follow.  At optimization level 3, compilation is slower, but more efficient code is produced.  Optimization level 2 is the default.  Overrides any prior <span class="code">-O</span> flags provided on the command line.</dd>
<dt class="code">-d &lt;depth&gt;</dt>
<dd>Limit the compiler's maximum recursive depth. By default, DBToaster compiles queries with the depth set to infinity. </dd>

<dt class="code">-n &lt;name&gt;</dt>
<dd>Name of the structures (classes, objects) generated by DBToaster (default: Query).</dd>

</dl>

<a name="languages"></a>
<?= chapter("Supported Languages") ?>
<table class="table">
  <tr>
    <th>Language</th>
    <th>Argument</th>
    <th>Output Format</th>
    <th>Description</th>
  </tr>

  <tr>
    <td>DBT Relational Calculus</td>
    <td class="code">calc</td>
    <td>output</td>
    <td>DBToaster's internal query representation.  This is a direct translation of the input queries.</td>
  </tr>
  
  <tr>
    <td>M3</td>
    <td class="code">m3</td>
    <td>output</td>
    <td>A map-maintenance messages program.  This is the set of triggers (written in DBT Relational Calculus) that will incrementally maintain the input queries and all supporting datastructures.</td>
  </tr>

  <tr>
    <td>C++</td>
    <td class="code">cpp</td>
    <td>output/compiled</td>
    <td>A C++ class implementing the queries.</td>
  </tr>

  <tr>
    <td>Scala</td>
    <td class="code">scala</td>
    <td>output/compiled</td>
    <td>A Scala class implementing the queries.</td>
  </tr>

</table>

<a name="opt_flags"></a>
<?= chapter("Optimization Flags"); ?>

These flags are passed to the DBToaster compiler with the <span class="code">-F</span> flag.  The <span class="code">-O1</span> and <span class="code">-O3</span> flags each activate a subset of these flags. <span class="code">-O2</span> is used by default (no optimization flags active).

<dl>
<!--
   The new backend currently does not handle input variables: https://github.com/TCKnet/DDBToaster/issues/23

  <dt class="code">HEURISTICS-ENABLE-INPUTVARS</dt>
  <dd>Enable experimental support for incremental view caches.  Queries with joins (and correlations) on inequality predicates are implemented in a way that corresponds roughly to nested-loop one-way joins in stream processing (a tree-based implementation is in development).  If this flag is on, the compiler will cache and incrementally maintain the results of this one-way join.  This is typically a bad idea, since the cost of maintaining the cached values is often higher than the cost of the nested loop scan.  However, if the domains of the variables appearing in the join predicate are small, this flag can drastically improve performance (e.g., for the VWAP example query).  Future versions of DBToaster will include a cost-based optimizer that automatically applies this flag when appropriate.  This optimization is not activated by default at any optimization level.</dd>  

  <dt class="code">HEURISTICS-AGGRESSIVE-INPUTVARS</dt>
  <dd> Enable experimental support for aggresive materialization of maps with input variables (view caches). It requires the HEURISTICS-ENABLE-INPUTVARS flag to be active. If the calculus optimizations are disabled (see CALC-NO-OPTIMIZE), this option might significantly prolong the compilation time. Note: the C++ backend might fail to compile certain classes of queries when this flag is on.</dd>  
-->
  <dt class="code">HEURISTICS-PULL-OUT-VALUES</dt>
  <dd>Prevent value terms (variables and comparisons) from being materialized inside maps. In certain cases (e.g., mddb/query2.sql), this option reduces the number of generated maps and speed-ups the compilation time at the expense of doing more computation at runtime.</dd>  

  <dt class="code">EXPRESSIVE-TLQS</dt>
  <dd>By default, each user-provided (top-level) query is materialized as a single map. If this flag is turned on, the compiler will materialize top-level queries as multiple maps (if it is more efficient to do so), and only combine them on request.  For more complex queries (in particular nested aggregate, and  AVG aggregate queries), this results in faster processing rates, and if fresh results are required less than once per update, a lower overall computational cost as well.  However, because the final evaluation of the top-level query is not performed until a result is requested, access latencies are higher.  This optimization is not activated by default at any optimization level.</dd>
  
  <dt class="code">IGNORE-DELETES</dt>
  <dd>Do not generate code for deletion triggers.  The resulting programs will be simpler, and sometimes have fewer datastructures, but will not support deletion events.  This optimization is not activated by default at any optimization level.</dd>
  
  <dt class="code">HEURISTICS-ALWAYS-UPDATE</dt>
  <dd>In some cases, it is more efficient to re-evaluate expressions from scratch than maintaining them with their deltas (for example, certain queries containing nested aggregates).  Normally, the compiler's heuristics will make a best-effort guess on whether to re-evaluate or incrementally maintain the expression.  If this flag is on, the compiler will incrementally maintain all expressions and never re-evaluate.</dd>  
  
  <dt class="code">COMPILE-WITH-STATIC</dt>
  <dd>Perform static linking on compiled binaries (e.g., invoke g++ with <span class="code">-static</span>).  The resulting binaries will be faster the first time they are run.  This optimization is not activated by default at any optimization level.</dd>  

  <dt class="code">AGGRESSIVE-FACTORIZE</dt>
  <dd>When optimizing expressions in DBToaster relational calculus, perform factorization as aggressively as possible.  For some queries, particularly those with nested subqueries, this can generate much more efficient code.  However, it makes compilation slower on some queries.  This optimization is automatically activated by <span class="code">-O3</span>.</dd>
  
  <dt class="code">AGGRESSIVE-UNIFICATION</dt>
  <dd>When optimizing expressions in DBToaster relational calculus, inline lifted variables wherever possible, even if the lift term cannot be eliminated entirely.  This can produce substantially tighter code for queries with lots of constants, but slightly increases compilation time.  This optimization is automatically activated by <span class="code">-O3</span>.</dd>

  <dt class="code">COMPILE-WITHOUT-OPT</dt>
  <dd>Request that the second-stage compiler disable any unnecessary optimizations (e.g., by default, g++ is invoked with <span class="code">-O3</span>, but not if this flag is active). This optimization is automatically activated by <span class="code">-O1</span>.</dd>

  <dt class="code">WEAK-EXPR-EQUIV</dt>
  <dd>When testing for expression equivalence, perform only a naive structural comparison rather than a (at least quadratic, and potentially exponential) matching.  This accelerates compilation, but may result in the creation of duplicate maps.  This optimization is automatically activated by <span class="code">-O1</span>.</dd>
    
  <dt class="code">CALC-NO-OPTIMIZE</dt>
  <dd>Do not apply calculus optimizations that simplify delta expressions. This option prevents range restrictions from being propragated through expressions, which usually leads to significantly worse performance. The resulting code is close to what the naive recursive incremental algorithm would produce. This flag is not activated by default at any optimization level.</dd>
    
  <dt class="code">CALC-NO-DECOMPOSITION</dt>
  <dd>Do not apply query decomposition when computing deltas. This option is not activated by default at any optimization level.</dd>

  <dt class="code">DUMB-LIFT-DELTAS</dt>
  <dd>When computing the viewlet transform, use the delta rule for lifts precisely as described in the <a href="http://www.dbtoaster.org/papers/pods2010-ring.pdf">PODS10 paper</a>.  If this flag is <b>not</b> active, a postprocessing step is applied to lift deltas that range-restricts the resulting expression to only those tuples that are affected, as described in the <a href="http://www.dbtoaster.org/papers/2013-dbtoaster-report.pdf">VLDBJ paper</a>.  This optimization is automatically activated by <span class="code">-O1</span>.</dd>

</dl>
